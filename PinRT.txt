<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>GeoVue Interactive Report</title>
		<link rel="icon" href="https://www.atsps2.net/LogoLargeTransparent48x48.ico" type="image/x-icon">
		<link rel="shortcut icon" href="https://www.atsps2.net/LogoLargeTransparent48x48.ico" type="image/x-icon">
		<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
		<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
		<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
		<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
		<style>
			.header {
				align-items: left;
				padding: 10px 20px;
			}
			.header img {
				width: 50px;
				height: 50px;
				margin-right: 10px;
			}
			.header h1 {
				margin: 0;
				color: #555;
			}
			.wait-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				display: none;
				justify-content: center;
				align-items: center;
			}
			.wait-message {
				color: white;
				font-size: 24px;
				 margin-bottom: 10px;
			}
			.spinner {
				width: 40px;
				height: 40px;
				border-radius: 50%;
				border: 4px solid rgba(255, 255, 255, 0.3);
				border-top-color: #fff;
				animation: spin 1s linear infinite;
			}
			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}
			.Introheading-container {
				display: flex;
				align-items: center;
			}
			.audio-button {
				padding: 10px 110px;
				font-size: 16px;
				color: #fff;
				background-color: #555;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				transition: background-color 0.3s;
				margin-left: 0px;
				margin-bottom: 20px;
			}
			.audio-button:hover {
				background-color: #0056b3;
			}
			.heading-container {
				display: flex;
				align-items: center;
			 }
			.play-symbol {
				font-size: 16px;
				margin-left: 5px;
			}
			.collapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.collapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.desccontent {
				padding: 0 4px;
				border: 1px solid #ccc;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
				border-radius: 10px;
			}
			.GIScollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.GIScollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.GISccontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.GISiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.GISiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.CORRcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.CORRcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.CORRcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.CORRiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.CORRiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.WELLcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.WELLcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.WELLcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.WELLiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.WELLiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.SAVEcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.SAVEcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.SAVEcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.SAVEiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.SAVEiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.Importcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Importcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Importcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.Importiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.Importiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.Presentationcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Presentationcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Presentationcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.Presentationiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.Presentationiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.iframe-container {
				position: relative;
				padding-bottom: 140%;
				height: 0;
				overflow: hidden;
			}
			.iframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			h2{
				text-decoration: underline;
			}
			#content
			{
				display: none;
			}
			#checkboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#checkboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ContourcheckboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ContourcheckboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ModelcheckboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ModelcheckboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListOne {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListOne li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListTwo {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListTwo li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListThree {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListThree li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#selectedRowData {
				width: 100%;
				max-width: 1100px;
				border-collapse: collapse;
				font-size: 11px;
			}
			.map-container {
				height: 620px;
				width: 100%;
				max-width: 1100px;
				margin-bottom: 20px;
			}
			@media only screen and (max-width: 1100px) {
				.map-container {
					width: 100%;
					margin: auto;
				}
			}
			img {
				max-width: 100%;
				height: auto;
				display: block;
				margin: 0 auto;
				float: left;
			}
			.image-break {
				clear: both;
			}
			@media only screen and (max-width: 1100px) {
				img {
					width: 100%;
				}
			}
			.text-label {
				background: none;
				color: white;
				font-size: 12px;
				font-weight: bold;
				text-shadow: 1px 1px 2px black;
				text-align: center;
				line-height: 1.5;
				border: none;
			}
			.chart-container {
				
				width: 100%;
				max-width: 1100px;
			}

			@media only screen and (max-width: 1100px) {
				.chart-container {
					width: 100%;
					margin: auto;
				}
			}	
			table {
				width: 1000;
				border-collapse: collapse;
				border: 1px solid #ccc;
				font-size: 12px;
			}
			th, td {
				padding: 8px;
				text-align: left;
				border-bottom: 1px solid #ddd;
			}
			th 
			{
				background-color: #f2f2f2;
			}
			tr:nth-child(even) 
			{
				background-color: #f5f5f5;
			}
			tr:hover 
			{
				background-color: #e0e0e0;
			}
			.disclaimer-box {
				padding: 10px;
				width: 100%;
				max-width: 1090px;
				border: 1px solid #ccc;
				border-radius: 10px;
				background-color: #f9f9f9;
				margin-top: 20px;
				float: left;
			}
			.note-box {
				width: 100%;
				max-width: 1090px;
				border: 1px solid #ccc;
				border-radius: 10px;
				background-color: #f9f9f9;
				float: left;
				margin-top: 20px;
				margin-bottom: 20px;
				padding: 10px;
			}
			#plot-container {
			  display: flex;
			  align-items: center; /* Center vertically */
			}

			#plot {
			  flex: 1;
			}
			#Sectionslider-container {
			  display: flex;
			  flex-direction: column;
			  justify-content: center;
			  height: 100%; /* Match height of the plot */
			}
			#Sectionslider {
			  margin: auto;
			  
			  height: 100%; /* Match height of the color bar */
			  width: 10px; /* Adjust width as needed */
			}
			#Sectionmax-value {
			  text-align: center;
			  margin-top: 10px; /* Move the max value label 10px lower */
			}
			#controls {
				margin-bottom: 20px;
			}
			#description {
				width: 800px; /* Adjust this value as needed to make the text box wider */
			}		
			.block-container {
				border: 2px solid lightgrey;
				padding: 5px; /* Adds some padding inside the border */
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}		
			.newtable-container {
				overflow-x: auto; /* Enables horizontal scrolling */
				max-width: 100%; /* Ensures the container does not exceed the parent width */
				margin-bottom: 10px; /* Adds some space below the table for the button */
			}

			/* Optional: Make sure the table fills the width of the scrollable container */
			table {
				width: 100%; /* Ensures the table uses the full width available */
				border-collapse: collapse; /* Optional: for a clean table look */
				background-color: white;
			}
		
			.Limitscollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Limitscollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Limitscontent {
				padding: 0 10px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1090px;
				margin: 0 auto;
				margin-left: 0;
				border-radius: 10px;
			}
			.Limitsiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 2300px;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 0px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1090px;
				border-radius: 10px;
			}
			.Limitsiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}		
			.Methcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Methcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Methcontent {
				padding: 0 10px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1090px;
				margin: 0 auto;
				margin-left: 0;
				border-radius: 10px;
			}
			.Methiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1400px;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 0px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1090px;
				border-radius: 10px;
			}
			.Methiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.editform-container {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.editform-row {
				display: flex;
				align-items: left;
				gap: 10px;
			}
			.editform-row label {
				min-width: 80px; /* Adjust this width as needed */
				
			}
			.editform-row input {
				flex-grow: 1;
				min-width: 80px;
				max-width: 150px;
			}
			.Temperaturecollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Temperaturecollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Temperaturecontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.Temperatureiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.Temperatureiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}		
			.DEFcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.DEFcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.DEFcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.DEFiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.DEFiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}			
			.POINTScollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.POINTScollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.POINTScontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.POINTSiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.POINTSiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.EXPcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.EXPcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.EXPcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.EXPiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.EXPiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			
			#help-btn {
				position: fixed;
				bottom: 20px;
				right: 20px;
				background-color: grey;      /* Button background color */
				color: white;                /* Question mark color */
				border: none;
				border-radius: 10%;
				padding: 15px;
				font-size: 24px;
				cursor: pointer;
				box-shadow: 0 2px 5px rgba(0,0,0,0.3);
				z-index: 1000;
				transition: background-color 0.3s ease; /* Smooth transition on hover */
			}
			#help-btn:hover {
				background-color: #555;      /* Dark grey on hover */
			}
			#help-btn {
				color: white !important;
			}
		
			#YoutubeButton {
				position: absolute;
				top: 10px;
				left: max(10px, min(1070px, 100% - 65px)); /* Modern CSS clamp-like behavior */
				width: 50px;
				height: 50px;
				background-color: #6c757d;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
				transition: background-color 0.3s ease;
				display: flex;
				align-items: center;
				justify-content: center;
			}
			#YoutubeButton:hover {
				background-color: #e0e0e0;
			}
			#YoutubeButton img {
				width: 30px;
				height: 30px;
			}
			#waitOverlay{
				position:fixed; inset:0; display:none;
				align-items:center; justify-content:center;
				/* changed to the same grey tone as the original */
				background:rgba(17,24,39,0.55);
				backdrop-filter:saturate(1.1) blur(2px);
				z-index:2147483647; /* on top of everything */
		    }
		    #waitOverlay .wait-card{
				background:#fff; padding:24px 28px; border-radius:14px;
				box-shadow:0 12px 40px rgba(0,0,0,.18);
				display:flex; flex-direction:column; align-items:center; gap:12px; min-width:260px;
		    }
		    #waitOverlay .spinner{
				width:56px; height:56px; border-radius:50%;
				border:4px solid #e6e9ef; border-top-color:#2f6fed;
				animation:spin 1s linear infinite;
		    }
		    @keyframes spin { to { transform: rotate(360deg); } }

			  #waitOverlay .wait-msg{ font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:#1f2937; text-align:center; }
			  #waitOverlay .progress{ width:220px; height:4px; border-radius:9999px; background:#eef2f7; overflow:hidden; }
			  #waitOverlay .progress > i{ display:block; width:40%; height:100%; background:#2f6fed; animation:indeterminate 1.6s ease-in-out infinite; }
			  @keyframes indeterminate {
				0% { transform: translateX(-100%); }
				50% { transform: translateX(20%); }
				100%{ transform: translateX(100%); }
		    }		
			.PDFcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.PDFcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.PDFcontent {
				padding: 0 0px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
			}
			.PDFiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 5px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1110px;
				border-radius: 10px;
			}
			.PDFiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<div class="wait-overlay" id="waitOverlay">
			<div class="wait-message">Document Loading. Please wait...   </div>
			<div class="spinner"></div>
		</div>
		
		<div class="header">
			<img src="https://www.atsps2.net/StandardLogoLargeTransparent.PNG" alt="Icon">
			<h1>GeoVue Interactive Report</h1>
		</div>
		<div class="image-break"></div>
		
		<button id="YoutubeButton" onclick="window.open('https://youtu.be/GfVLQ5FsdB0', '_blank')" >
			<img src="https://www.atsps2.net/icons8-youtube-48.png" alt="Web Link Icon" >
		</button>
		
		<div class="disclaimer-box">
		  <p><strong>Terms of Use:</strong> All the data sets, interpretations, recommendations, logs, and risk assessments, presented in this document are calculated estimates of the values and parameters they represent, as they are derived from the signal attributes of multiple sets of sensor collected data. These sensors are subject to variance, drift, noise, error and uncertainty. As such, the data collected from these sensors, and the data sets derived from the sensor collected data, are subject to the same variance, drift, noise, error and uncertainty. As such, the data sets discussed in this document cannot, and should not, be viewed or interpreted as being absolute in nature. Any actions or decisions made by the user with reference to the data provided in this document, should consider the uncertainties and risks involved in its use. As such, the client accepts and agrees in full, not to hold ‘GeoVue Ltd’, its owners, directors, or employees, liable for any financial or physical losses, damages, injuries, or claims incurred or made by any persons, companies, organizations, or institutions who make use of ‘GeoVue Ltd’ field or consulting services, or the information, interpretations, findings, and recommendations discussed in this report. As Electro-seismic technologies are geophysical technologies with inherent uncertainties and risks, the client accepts and agrees in full, that ‘GeoVue Ltd’, its owners, directors, or employees, does not, and cannot, guarantee that the results published in this report to be absolutely accurate and will not accept, or be liable for, any claim of financial losses due to unsuccessful or unsatisfactory exploration results, or otherwise, due to the use of the information discussed in this report, on the part of the client and/or their associates, subsidiaries, contractors, consultants, employees, or investors.</p>
		</div>

		<div class="image-break"></div>
		
		<div class="note-box">
		  <p><strong>Load Time Note:</strong> The report may take some time to load after the "Accept Terms and Load Report" button is selected. Should a "page unresponsive" message appear on your browser, either ignore the message until the document has loaded or select the "Wait" option.</p>
		</div>
		<div class="image-break"></div>
		
		<button id="acceptButton" style="background-color: #555; 
		  border: none;
		  color: white;
		  padding: 10px 85px;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		  font-size: 16px;
		  margin: 4px 2px;
		  transition-duration: 0.4s;
		  cursor: pointer;
		  border-radius: 8px;
		  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
		  ">
		  &#10004;  Accept Terms and Load Report
		</button>
		<div id="content">
			
			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioSurveySiteMap()">
					<h2>Survey Site Map</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				
				<button id="download-btn1">Download Map</button>
				<button type="button" onclick="AutoLineCreate()">Auto Create Lines</button>
				<button type="button" onclick="DeleteSelectionAll()">Delete All Lines</button>
				<div id="map1" class="map-container"></div>
				<figure>
					<figcaption>Map Marker Legend</figcaption>
					<img src="https://atsps2.net/recommendationslegend.png" alt="Map Marker Legend " width="500" height="35">
				</figure>
				<div class="image-break"></div>
				
				<div class="heading-container" onclick="playSiteMapSettings()">
					<h4>Site Map Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>

				<div>
					<input type="checkbox" id="ShowRecomendations-checkbox" onchange="toggleSiteMapShowRecomendations()" unchecked>
					<label for="ShowRecomendations-checkbox">Show recommendation points</label>
				</div>
				
				<div>
					<input type="checkbox" id="RecPoints-checkbox" onchange="toggleSiteMapRecPoints()" unchecked>
					<label for="RecPoints-checkbox">Show recommendation points only </label>
				</div>

				<div>
					<input type="checkbox" id="ShowLines-checkbox" onchange="toggleSiteMapShowLines()" unchecked>
					<label for="ShowLines-checkbox">Show selection lines</label>
				</div>

				<div class="heading-container" onclick="playReportDataElevationSettings()">
					<h4>Report Data Elevation Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<input type="checkbox" id="SRTMElevation-checkbox" onchange="toggleSRTM()" unchecked>
				<label for="SRTMElevation-checkbox">Use SRTM Elevation Data</label>
			
				<br>
				<input type="checkbox" id="ZeroElevation-checkbox" onchange="toggleZero()" unchecked>
				<label for="ZeroElevation-checkbox">Use Zero Elevation Data</label>
				<div><br></div>
			</div>
			
			<p style="page-break-after: always;">&nbsp;</p>
			<button class="POINTScollapsible"><h2>Survey Points</h2></button>
			<div class="POINTScontent">
				<div class="POINTSiframe-container">
						<div class="heading-container" style="max-width: 1100px;" onclick="playAudioSurveyPoints()">
							<span class="play-symbol">&#128266;</span>
						</div>
						<div id="dataTable"></div>	
					<br>
				</div>
			</div>

			<div><br></div>
			<button class="DEFcollapsible"><h2>Recommendations</h2></button>
			<div class="DEFcontent">
			  <div class="DEFiframe-container">
				<div class="heading-container" onclick="playAudioRecommendations()">
					
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="RecdataTable"></div>
				<div class="image-break"></div>
				
				<h2>Definitions</h2>
				<div style="max-width: 1100px;" style="text-align: justify;">
					<p class=MsoNormal></p>
						<p class=MsoNormal><b>Risk</b> - The calculated total risk of attaining the
						specified point yield parameters indicated in the recommendations table. Risk is defined by the
						site noise content, data correlation, data signal to noise ratios and number of
						strikes used in processing.<o:p></o:p></p>


						<p class=MsoNormal><b>Confidence</b> - The calculated measure of confidence in
						attaining the point specified yield parameters indicated in the recommendations table.
						Confidence is defined by the area, volume, min and max
						yield, correlating points and composition of the aquifers detected under the
						point.<o:p></o:p></p>


						<p class=MsoNormal><b>Min Yield </b>- The estimated minimum yield, in litres per
						second, the point will produce if drilled to the specified depth. This estimated
						value is calculated by assuming no fractures or dual porosity formations are
						intersected under the point and thus represents the lowest calculated yield for
						the point. All aquifers above the specified static water level or user defined casing
						depth is excluded from the yield estimation.<o:p></o:p></p>


						<p class=MsoNormal><b>Max Yield </b>- The estimated maximum yield, in litres per
						second, the point will produce if drilled to the specified depth. This estimated
						value is calculated by assuming large, extensive, well connected and 
						well developed fractures or dual porosity formations are
						intersected under the point and thus represents the highest calculated yield
						for the point. All aquifers above the specified static water level or user
						defined casing depth is excluded from the yield
						estimation.<o:p></o:p></p>


						<p class=MsoNormal><b>Sustainable Yield </b>- The estimated sustainable yield,
						in litres per second, the point should produce if drilled to the specified
						depth. All aquifers above the specified static water level or user defined
						casing depth is excluded from the yield estimation.
						This value is calculated by applying the area, volume, composition, min and max
						yield, risk and confidence parameters for the aquifers indicated to be
						intersected by the point, to estimate what the sustainable yield of the points
						will be. This value includes both the local and wide area aquifers sustainable
						yield estimates, within the specified yield influence radius, to provide the
						most realistic estimate for sustainable yield at any given point location. The
						sustainable yield value specified in the recommendations table, is a calculated estimate for sustainable
						yield a point will produce. As such, the estimated sustainable yield, specified
						on the recommendations table, is subject to variation from the true sustainable yield
						encountered at the point. The true sustainable yield encountered at the point
						can and may vary between the specified estimated minimum and maximum yield
						values for the point.<o:p></o:p></p>

						<p class=MsoNormal><b>Rec Drill Depth </b>– The maximum depth to which a
						recommended point should be drilled.</p>
				
						<p class=MsoNormal><b>Vert. Res </b>– The maximum calculated vertical resolution of interpreted geological interface depths. </p>
				
						<p class=MsoNormal><b>Uncertainty </b>– The maximum calculated uncertainty of the interpreted geological interface depths.</p>
				</div>
			  </div>
			</div>

			<div><br></div>
			<button class="collapsible"><h2>Description</h2></button>
			<div class="desccontent">
			  <div class="iframe-container">
				<div class="heading-container" onclick="playAudioViewDataSetDescriptions()">
					<span class="play-symbol">&#128266;</span>
				</div>
				<iframe src="https://www.atsps2.net/Description/Description.htm" frameborder="0" allowfullscreen></iframe>
			  </div>
			</div>
			<div><br></div>
			
			<button class="Limitscollapsible"><h2>Limitations</h2></button>
			<div class="Limitscontent">
			  <div class="Limitsiframe-container">
				<iframe src="https://www.atsps2.net/limits.html" frameborder="0" allowfullscreen></iframe>
			  </div>
			</div>
			<div><br></div>

			<button class="Methcollapsible"><h2>Methodology</h2></button>
			<div class="Methcontent">
			  <div class="Methiframe-container">
				<iframe src="https://www.atsps2.net/Methodology.png" frameborder="0" allowfullscreen></iframe>
			  </div>
			</div>
			<div><br></div>
			
			<button class="SAVEcollapsible"><h2>Save Report</h2></button>
			<div class="SAVEcontent">
				<div class="SAVEiframe-container">
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– To save any updates made to the report points, use the Save Report option. A new report will be generated with the updates included.</p>
						</div>
						<div>
							<button id="fetchButton">Save Report</button>
						</div>
					<br>
				</div>
			</div>
			<div><br></div>
						
			<button class="PDFcollapsible"><h2>Export Report to PDF</h2></button>
			<div class="PDFcontent">
				<div class="PDFiframe-container">
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– To export the report data to a PDF document.</p>
						</div>
						<div>
							<button id="createPdfBtn" type="button" onclick="generateReports()">Create PDF Report</button>
						</div>
					<br>
				</div>
			</div>
			<div><br></div>
			
			<button class="CORRcollapsible"><h2>Edit Point Data</h2></button>
			<div class="CORRcontent">
				<div class="CORRiframe-container">
			
					<div class="block-container">
						<div class="heading-container">
							<h2>Update Point Data</h2>
						</div>

						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– This feature allow for the updating of the selected points Latitude, Longitude and elevation data. Select the point to be updated, then enter the new latitude, longitude, or elevation. Once entered, select the Update option. The point data will be updated, along with all the maps displaying the point. Alternatively, the point can be dragged to a new position on the site map. When this method is used, the updated point position is automatically updated, however, the the elevation data will remain the same.</p>
						</div>
						
						<div>
							<select id="rowSelectorEditPoint" onchange="selectRowEditPoint()">
								<option value="" disabled selected>Select Point</option>
							</select>
						</div>
						<br>
						<div class="editform-container">
							<div class="editform-row">
								<label for="LatInput">Latitude:</label>
								<input type="text" id="LatInput" value="0.0">
								<label for="LatInput">(WGS84 Dec°)</label>
							</div>
							<div class="editform-row">
								<label for="LonInput">Longitude:</label>
								<input type="text" id="LonInput" value="0.0">
								<label for="LonInput">(WGS84 Dec°)</label>
							</div>
							<div class="editform-row">
								<label for="ElevInput">Elevation:</label>
								<input type="text" id="ElevInput" value="0.0">
								<label for="ElevInput">(masl)</label>
							</div>
						</div>
						<br>
						
						<div>
							<button id="SaveEditsButton" onclick="UpdatePointData()">Update</button>
						</div>
						
						<div style="max-width: 1100px;" style="text-align: justify;">
						</div>
					
					</div>

					<p style="page-break-after: always;">&nbsp;</p>
						<div class="block-container">
							<div class="heading-container">
								<h2>Bulk Update Point Data</h2>
							</div>
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– This feature allow for the loading of a KML, KMZ, CSV or GPX file to complete a bulk correction of the coordinates of the points within the project. Coordinate data must be in WGS84 Decimal degree format and elevation data must be included within the files in MASL format. The CSV data format must be as follows (Point number, Latitude, Longitude, Elevation)</p>
						</div>
						<div>
							<input type="file" id="fileInput" accept=".kml, .kmz, .gpx, .csv" style="display:none" onchange="loadCorrFile()">
							<button id="LoadCorrectionFile"onclick="selectAndLoadFile()">Load File</button>
						</div>
					</div>
				</div>
			</div>
			<div><br></div>

			<button class="Importcollapsible"><h2>Import External Data</h2></button>
			<div class="Importcontent">
				<div class="Importiframe-container">
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– To import data, a CSV (Microsoft Comma Delimited) file must be created with data in the following format - Point (The project point to which the data is assigned), Depth(below ground level in meters), Value (the magintude of the CPT or other readings), Label (such as the CPT number). A number of external data points can be added to the CSV file. Click on the Load External Data button, then select the CSV file to import. The Loaded data will be normilised to the maximum value detected in the Value column of the CSV file. This males all the imported data sets relative in ampltude to one another. To see the imported data on the Section Data plot, select the view Imported data checkbox and regenerate the plot.</p>
						</div>
						<div>
							<button id="loadExtDataButton">Load External Data</button>
							<input type="file" id="ExtfileInput" accept=".csv" style="display: none;" />
						</div>
					<br>
				</div>
			</div>
			<div><br></div>
			
			<button class="EXPcollapsible"><h2>Export Data to CSV</h2></button>
			<div class="EXPcontent">
				<div class="EXPiframe-container">
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– To save all the data in this report to a CSV file.</p>
						</div>
						<div>
							<button onclick="exportAllBoxDataToCSV()">Export all data to CSV</button>
						</div>	
					<br>
				</div>
			</div>
			<div><br></div>
			
			<button class="WELLcollapsible"><h2>Well Parameters</h2></button>
			<div class="WELLcontent">
				<div class="WELLiframe-container">			
					<div class="block-container">
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– This feature allows for the updating of the applied well diameter (in mm), as well as case and screen depth in meters below ground level (mbgl), used in the calculation of yield estimates.</p>
						</div>
						<div style="margin-bottom:8px;">
						  <label for="WellDiameter" style="display:inline-block; width:120px;">Well Diameter:</label>
						  <input type="text" id="WellDiameter" value="152.4" style="width:200px;">
						  (mm)
						</div>
						<div style="margin-bottom:8px;">
						  <label for="CaseDepth" style="display:inline-block; width:120px;">Case Depth:</label>
						  <input type="text" id="CaseDepth" value="0" style="width:200px;">
						  (mbgl)
						</div>
						<div style="margin-bottom:8px;">
						  <label for="ScreenDepth" style="display:inline-block; width:120px;">Screen Depth:</label>
						  <input type="text" id="ScreenDepth" value="10000" style="width:200px;">
						  (mbgl)
						</div>
						<br>						
						<div>
							<button id="WellDiameterButton" onclick="UpdateWellDiameter()">Update</button>
						</div>
					</div>
				</div>
			</div>
			<div><br></div>
			
			<button class="Temperaturecollapsible"><h2>Temperature Calibration</h2></button>
			<div class="Temperaturecontent">
			  <div class="Temperatureiframe-container">
					
					<div>
					<label for="temperatureInput">Maximum formation temperature (degC):</label>
					<input type="text" id="temperatureInput" value="25" oninput="updateTemperature()">
					</div>
					<div style="max-width: 1100px;" style="text-align: justify;">
					<p class=MsoNormal><b>Note </b>– This parameter allows the user to calibrate the thermal data provided in this document, to known or estimated values in degrees Celsius. By default, the site natural thermal gradient is set to 25 degrees per km to estimate the maximum expected temperature at the project processed depth. If the survey is conducted on an active geothermal field, then the maximum geothermal resource temperature within the data processing depth range, can be used to calibrate the thermal data. Thermal data plots are available on the selectable dataset drop down lists for every chart in this document. When changing this value, it is important to regenerate the data plots to reflect the change.</p>
					</div>
			  </div>
			</div>
			<div><br></div>
			
			<button class="Presentationcollapsible"><h2>Presentation Views</h2></button>
			<div class="Presentationcontent">
				<div class="Presentationiframe-container">
					<div class="heading-container" onclick="playPresentationViews()">
						<span class="play-symbol">&#128266;</span>
					</div>
					<div id="plotly-presentation" class="chart-container"></div>
					<div class="image-break"></div>
					
					<div class="heading-container" onclick="playPresentationViews()">
						<h4>Select presentation view :</h4>
						<span class="play-symbol">&#128266;</span>
					</div>
					<div id="controls">
						<select id="viewSelector9" onchange="updateDescription9()">
							<option value="0">View 1</option>
							<option value="1">View 2</option>
							<option value="2">View 3</option>
							<option value="3">View 4</option>
							<option value="4">View 5</option>
							<option value="5">View 6</option>
							<option value="6">View 7</option>
							<option value="7">View 8</option>
							<option value="8">View 9</option>
							<option value="9">View 10</option>
							<option value="10">View 11</option>
							<option value="11">View 12</option>
							<option value="12">View 13</option>
							<option value="13">View 14</option>
							<option value="14">View 15</option>
							<option value="15">View 16</option>
							<option value="16">View 17</option>
							<option value="17">View 18</option>
							<option value="18">View 19</option>
							<option value="19">View 20</option>
							<option value="20">View 21</option>
							<option value="21">View 22</option>
							<option value="22">View 23</option>
							<option value="23">View 24</option>
							<option value="24">View 25</option>
							<option value="25">View 26</option>
							<option value="26">View 27</option>
							<option value="27">View 28</option>
							<option value="28">View 29</option>
							<option value="29">View 30</option>
							<option value="30">View 31</option>
							<option value="31">View 32</option>
							<option value="32">View 33</option>
							<option value="33">View 34</option>
							<option value="34">View 35</option>
							<option value="35">View 36</option>
							<option value="36">View 37</option>
							<option value="37">View 38</option>
							<option value="38">View 39</option>
							<option value="39">View 40</option>
							<option value="40">View 41</option>
							<option value="41">View 42</option>
							<option value="42">View 43</option>
							<option value="43">View 44</option>
							<option value="44">View 45</option>
							<option value="45">View 46</option>
							<option value="46">View 47</option>
							<option value="47">View 48</option>
							<option value="48">View 49</option>
							<option value="49">View 50</option>
						</select>
						<input type="text" id="description9" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
						<button onclick="prevView9()">&#8593;</button>
						<button onclick="nextView9()">&#8595;</button>
						<button onclick="loadPlot9()">Load View</button>
					</div>

					<br>
					<!--<div class="block-container">
						<br><div class="heading-container" onclick="playViewControls()">
							<h2>View Controls</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<div id="controls">
							<button onclick="saveAllDataToFile()">Save All View Data to File</button>
							<input type="file" id="fileInput" style="display:none;" onchange="loadAllDataFromFile(event)">
							<button onclick="document.getElementById('fileInput').click()">Load all View Data from File</button>
						</div>
					</div>-->					
				</div>
			</div>

			<div><br></div>
			<button class="GIScollapsible"><h2>GIS Data Maps</h2></button>
			<div class="GIScontent">
				<div class="GISiframe-container">
					<div class="heading-container" onclick="playViewGISDataMaps()">
						<span class="play-symbol">&#128266;</span>
					</div>
					<div class="heading-container" onclick="playAudioAquiferClassification()">
						<h2>Aquifer Classification</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn2">Download Map</button>
					<div id="map2" class="map-container"></div>
					<figure>
						<figcaption>Aquifer Classification Legend</figcaption>
						<img src="https://atsps2.net/AquiferClassificationLegend.png" alt="Aquifer Classification Legend " width="1000" height="40">
					</figure>
					<div class="image-break"></div>

					<br><div class="heading-container" onclick="playAudioWaterSheds()">
						<h2>Water Sheds</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn6">Download Map</button>
					<div id="map6" class="map-container"></div>
					<div class="image-break"></div>
					<figure>
						<figcaption>Water Shed Boundaries</figcaption>
						<img src="https://atsps2.net/WaterShedBoundaryLegend.png" alt="Water Shed Boundary Legend " width="1000" height="35">
					</figure>
					<div class="image-break"></div>
					
					<p style="page-break-after: always;">&nbsp;</p>
					<div class="heading-container" onclick="playAudioLithology()">
						<h2>Lithology</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn5">Download Map</button>
					<div id="map5" class="map-container"></div>
					<figure>
						<figcaption>Lithology Legend</figcaption>
						<img src="https://atsps2.net/LithologyLegend.jpg" alt="Lithology Legend"width="1000" height="590">
					</figure>
					<div class="image-break"></div>

					<p style="page-break-after: always;">&nbsp;</p>
					<div class="heading-container" onclick="playAudioGroundwaterLevel()">
						<h2>Groundwater Level</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn3">Download Map</button>
					<div id="map3" class="map-container"></div>
					<figure>
						<figcaption>Groundwater Level Legend</figcaption>
						<img src="https://atsps2.net/GWLLegend.png" alt="Groundwater Level Legend" width="1000" height="150">
					</figure>
					<div class="image-break"></div>
					
					<br><div class="heading-container" onclick="playAudioFaulting()">
						<h2>Faulting</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn4">Download Map</button>
					<div id="map4" class="map-container"></div>
					<figure>
						<figcaption>Faulting Legend</figcaption>
						<img src="https://atsps2.net/FaultLegend.png" alt="Faulting Legend" width="1000" height="35">
					</figure>
					<div class="image-break"></div>
					
					<p style="page-break-after: always;">&nbsp;</p>
					<div class="heading-container" onclick="playAudioSalineAquifers()">
						<h2>Saline Aquifers</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn7">Download Map</button>
					<div id="map7" class="map-container"></div>
					<figure>
						<figcaption>Saline Aquifers Legend</figcaption>
						<img src="https://atsps2.net/SalineAquiferLegend.png" alt="Saline Aquifers Legend" width="1000" height="35">
					</figure>
					<div class="image-break"></div>
					
					<br><div class="heading-container" onclick="playAudioGeothermal()">
						<h2>Geothermal Maps</h2>
						<span class="play-symbol">&#128266;</span>
					</div>
					<button id="download-btn8">Download Map</button>
					<div id="map8" class="map-container"></div>
					<figure>
						<figcaption>Geothermal Legend</figcaption>
						<img src="https://atsps2.net/GeothermalLegend.png" alt="Geothermal Legend" width="1000" height="40">
					</figure>
					<div class="image-break"></div>

				</div>
			</div>

			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioSiteParameterMaps()">
					<h2>Site Parameter Maps</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-contour" class="chart-container"></div>
				<div class="image-break"></div>				
				<form>
					<p style="font-size:18px;"><b>Select parameter to view: </b></p>
					<select onchange="updateContourPlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Yield Estimates">
							<option value="dataset1">Sustainable Yield</option>
							<option value="dataset2">Minimum Yield</option>
							<option value="dataset3">Maximum Yield</option>
						</optgroup>
						<optgroup label="Well Parameters">	
							<option value="dataset11">GPS Elevation</option>
							<option value="dataset5">Drilling Depth</option>
							<option value="dataset4">Ground water level</option>	
						</optgroup>
						<optgroup label="Quality Control">	
							<option value="dataset6">Risk</option>
							<option value="dataset7">Confidence</option>
							<option value="dataset8">Correlation</option>
							<option value="dataset9">Signal to Noise Ratio</option>
							<option value="dataset39">Noise</option>
							<option value="dataset41">Vertical Resolution</option>
							<option value="dataset42">Uncertainty</option>
							<option value="dataset10">Strikes Used</option>
						</optgroup>
						<optgroup label="Depth Yield Estimates">	
							<option value="dataset12">Sustainable Yield 100m</option>
							<option value="dataset13">Sustainable Yield 200m</option>
							<option value="dataset14">Sustainable Yield 300m</option>
							<option value="dataset15">Sustainable Yield 400m</option>
							<option value="dataset16">Sustainable Yield 500m</option>
							<option value="dataset17">Sustainable Yield 600m</option>
							<option value="dataset18">Sustainable Yield 700m</option>
							<option value="dataset19">Sustainable Yield 800m</option>
							<option value="dataset20">Sustainable Yield 900m</option>
							<option value="dataset21">Sustainable Yield 1000m</option>				
						</optgroup>
						<optgroup label="GeoTechnical Parameters">	
							<option value="dataset22">Soil Depth</option>
							<option value="dataset23">Soil Density</option>
							<option value="dataset24">Soil Porosity</option>
							<option value="dataset25">Soil Shear Modulus</option>
							<option value="dataset26">Soil Bulk Modulus</option>
							<option value="dataset27">Soil Compressibility</option>
							<option value="dataset28">Soil Poisson Ratio</option>
							<option value="dataset29">Soil Youngs Modulus</option>
							<option value="dataset30">Soil Acoustic Impeadance</option>
							<option value="dataset31">Soil Storativity</option>
							<option value="dataset32">Soil Diffusivity</option>
							<option value="dataset33">Soil Hydraulic Conductivity</option>
							<option value="dataset34">Soil Transmissivity</option>
							<option value="dataset35">Soil Permeability</option>
							<option value="dataset36">Soil Clay Content</option>
							<option value="dataset37">Soil SPTN</option>
							<option value="dataset38">Soil SPTRQD</option>
						</optgroup>
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
					<p class="MsoNormal"><b>Note</b> – Point numbers shown on chart</p>
				</div>
				
				<div class="heading-container" onclick="playCreateSiteParameterMapViews()">
					<h4>Create Site Parameter Map Views:</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector1" onchange="updateDescription1()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description1" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView1()">&#8593;</button>
					<button onclick="nextView1()">&#8595;</button>
					<button onclick="savePlot1()">Save View</button>
					<button onclick="loadPlot1()">Load View</button>
				</div>
				
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views:</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector5" onchange="updateDescription5()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description5" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot5()">Save View</button>
				</div>
				
				<div class="heading-container" onclick="playAudioSelectContourPoints()">
					<h4>Select Contour Map Points:</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleContourForm()">View Contour Map Points</button>
					<form id="ContourcheckboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Contour Points:</legend>
							<ul id="ContourcheckboxList"></ul>
						</fieldset>
						<button type="button" onclick="ContourselectAll()">Select All</button>
						<button type="button" onclick="ContourdeselectAll()">Deselect All</button>
						<button type="button" onclick="ContourshowSelectedPoints()">Render Contour</button>
						<input type="text" id="ContourSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ContoursaveSelection()">Save Selection</button>
						<select id="ContourSelectionDropdown"></select>
						<button type="button" onclick="ContourloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionContour()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>

			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioSiteSectionLine()">
					<h2>Site Section Line</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				
				<div id="plotly-Sections" class="chart-container"></div>

				<div class="image-break"></div>
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateSectionPlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
							<option value="dataset44">Seismic Reflection</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Electric Field Strength</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<!-- <optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>-->
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>
				
				<div class="heading-container" onclick="playAudioSectionSettings()">
					<h4>Section Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div>
				<input type="checkbox" id="show-sectionlogs-checkbox" onchange="togglesectionLogs()" unchecked>
				<label for="show-sectionlogs-checkbox">Show Recommended Drilling Depth Logs</label>
				</div>
				<div>
				<input type="checkbox" id="show-Fracturepoints-checkbox" onchange="togglefracturePoints()" unchecked>
				<label for="show-Fracturepoints-checkbox">Show Detected Fracture points</label>
				</div>
				<div>
				<input type="checkbox" id="show-ExternalData-checkbox" onchange="toggleExternalData()" unchecked>
				<label for="show-ExternalData-checkbox">Show Imported Data</label>
				</div>
				
				<div>
				<input type="checkbox" id="show-VerticalLable-checkbox" onchange="toggleVerticalLable()" unchecked>
				<label for="show-VerticalLable-checkbox">Show Vertical Labels</label>
				</div>
								
				<div class="heading-container" onclick="playSectionAmplitudeSettings()">
					<h4>Section Amplitude Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
				<label for="Sectionslider" style="width: 170px;">Data Max Relative Value:</label>
				<input type="range" min="0" max="100" value="100" id="range-slider" style="width: 400px;">
				<span id="Sectionmax-value">100</span>
				</div>
				
				<div class="heading-container" onclick="playCreateSiteSectionLineViews()">
					<h4>Create Site Section Line Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
					<select id="viewSelector2" onchange="updateDescription2()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description2" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView2()">&#8593;</button>
					<button onclick="nextView2()">&#8595;</button>
					<button onclick="savePlot2()">Save View</button>
					<button onclick="loadPlot2()">Load View</button>
				</div>	
						  
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector6" onchange="updateDescription6()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description6" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot6()">Save View</button>
				</div>	

				<div class="heading-container" onclick="playAudioSelectSectionPoints()">
					<h4>Select Section Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleSectionForm()">View Section Points</button>
					<form id="checkboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Section Points:</legend>
							<ul id="checkboxList"></ul>
						</fieldset>
						<button type="button" onclick="selectAll()">Select All</button>
						<button type="button" onclick="deselectAll()">Deselect All</button>
						<button type="button" onclick="showSelectedPoints()">Render Section</button>
						<input type="text" id="SectionSelectionName" placeholder="Selection Name">
						<button type="button" onclick="SectionsaveSelection()">Save Selection</button>
						<select id="SectionSelectionDropdown"></select>
						<button type="button" onclick="SectionloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionSection()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>
			
			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioSiteModels()">
					<h2>Site Profiles</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-Profile1" class="chart-container"></div>
				<div class="image-break"></div>
				<button id="Profanimation-btn">Start Profile Rotation</button>
				<div class="image-break"></div>
				
				<label for="correct-chart-checkbox">Correct Chart</label>
				<input type="checkbox" id="correct-chart-checkbox">
				<div class="image-break"></div>
				
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateProfilePlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Electric Field Strength</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<!-- <optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>-->
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>

				<div class="heading-container" onclick="playCreateSiteProfileViews()">
					<h4>Create Site Profile Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
					<select id="viewSelector3" onchange="updateDescription3()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description3" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView3()">&#8593;</button>
					<button onclick="nextView3()">&#8595;</button>
					<button onclick="savePlot3()">Save View</button>
					<button onclick="loadPlot3()">Load View</button>
				</div>
				
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector7" onchange="updateDescription7()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description7" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot7()">Save View</button>
				</div>
				
				<div class="heading-container" onclick="audioPlayerSelectProfilePoints()">
					<h4>Select Profile Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileOneForm()">View Profile One Points</button>
					<div id="profileFormOne" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormOne">
							<fieldset>
								<legend>Select Profile One Points:</legend>
								<ul id="ProfilecheckboxListOne"></ul>
							</fieldset>
							<button type="button" onclick="ProfileselectAllOne()">Select All</button>
							<button type="button" onclick="ProfiledeselectAllOne()">Deselect All</button>
							<button type="button" onclick="ProfileshowSelectedPointsOne()">Render Profile</button>
							<input type="text" id="ProfileOneSelectionName" placeholder="Selection Name">
							<button type="button" onclick="ProfileOnesaveSelection()">Save Selection</button>
							<select id="ProfileOneSelectionDropdown"></select>
							<button type="button" onclick="ProfileOneloadSelection()">Load Selection</button>
							<button type="button" onclick="DeleteSelectionProfileOne()">Delete Selection</button>
							<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
				
				<br><div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileTwoForm()">View Profile Two Points</button>
					<div id="profileFormTwo" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormTwo">
							<fieldset>
								<legend>Select Profile Two Points:</legend>
								<ul id="ProfilecheckboxListTwo"></ul>
							</fieldset>
							<button type="button" onclick="ProfileselectAllTwo()">Select All</button>
							<button type="button" onclick="ProfiledeselectAllTwo()">Deselect All</button>
							<button type="button" onclick="ProfileshowSelectedPointsTwo()">Render Profile</button>
							<input type="text" id="ProfileTwoSelectionName" placeholder="Selection Name">
							<button type="button" onclick="ProfileTwosaveSelection()">Save Selection</button>
							<select id="ProfileTwoSelectionDropdown"></select>
							<button type="button" onclick="ProfileTwoloadSelection()">Load Selection</button>
							<button type="button" onclick="DeleteSelectionProfileTwo()">Delete Selection</button>
							<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
				
				<br><div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileThreeForm()">View Profile Three Points</button>
					<div id="profileFormThree" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormThree">
							<fieldset>
							<legend>Select Profile Three Points:</legend>
							<ul id="ProfilecheckboxListThree"></ul>
						</fieldset>
						<button type="button" onclick="ProfileselectAllThree()">Select All</button>
						<button type="button" onclick="ProfiledeselectAllThree()">Deselect All</button>
						<button type="button" onclick="ProfileshowSelectedPointsThree()">Render Profile</button>
						<input type="text" id="ProfileThreeSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ProfileThreesaveSelection()">Save Selection</button>
						<select id="ProfileThreeSelectionDropdown"></select>
						<button type="button" onclick="ProfileThreeloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionProfileThree()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
			</div>
			
			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioSiteModels()">
					<h2>Site Models</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-Model1" class="chart-container"></div>
				<div class="image-break"></div>
				<button id="animation-btn">Start Model Rotation</button>
				<div class="image-break"></div>

				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateVolumePlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Electric Field Strength</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<!-- <optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>-->
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>

				<div class="heading-container" onclick="playAudioModelSettings()">
					<h4>Model Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
				  <label for="isomin-slider" style="width: 170px;">Iso-Surface Minimum %:</label>
				  <input type="range" min="0" max="100" value="70" class="slider" id="isomin-slider" style="width: 400px;">
				  <span id="isomin-value">70</span>
				</div>
				<div style="display: flex; align-items: center;">
				  <label for="isomax-slider" style="width: 170px;">Iso-Surface Maximum %:</label>
				  <input type="range" min="0" max="100" value="100" class="slider" id="isomax-slider" style="width: 400px;">
				  <span id="isomax-value">100</span>
				</div><br>
				<div>
				<input type="checkbox" id="show-topography-checkbox" onchange="toggleTopography()" checked>
				<label for="show-topography-checkbox">Show Topography</label>
				</div>
				<div>
				<input type="checkbox" id="show-survey-points-checkbox" onchange="toggleSurveyPoints()" checked>
				<label for="show-survey-points-checkbox">Show Survey Points</label>
				</div>
				<div>
				<input type="checkbox" id="show-logs-checkbox" onchange="toggleLogs()" checked>
				<label for="show-logs-checkbox">Show Logs</label>
				</div>
				
				<div>
				<input type="checkbox" id="show-orthographic-checkbox" onchange="toggleorthographic()" unchecked>
				<label for="show-orthographic-checkbox">Orthographic View</label>
				</div>
				
				<div class="heading-container" onclick="playAudioSliceSettings()">
					<h4>Slice Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
					<label for="DepthsliceSlider" style="width: 170px;">Depth Slice Position:</label>
					<input type="range" min="0" max="99" value="50" step="1" id="DepthsliceSlider" style="width: 400px;">
				</div>
				<div style="display: flex; align-items: center;">
					<label for="LatsliceSlider" style="width: 170px;">Latitude Slice Position:</label>
					<input type="range" min="0" max="29" value="15" step="1" id="LatsliceSlider" style="width: 400px;">
				</div>
				<div style="display: flex; align-items: center;">
					<label for="LonsliceSlider" style="width: 170px;">Longitude Slice Position:</label>
					<input type="range" min="0" max="29" value="15" step="1" id="LonsliceSlider" style="width: 400px;">
				</div><br>
				
				<div>
				<input type="checkbox" id="show-DepthSlice-checkbox" onchange="toggleDepthSlice()" checked>
				<label for="show-DepthSlice-checkbox">Show Depth Slice</label>
				</div>
				<div>
				<input type="checkbox" id="show-LatSlice-checkbox" onchange="toggleLatSlice()" checked>
				<label for="show-LatSlice-checkbox">Show Lat Slice</label>
				</div>
				<div>
				<input type="checkbox" id="show-LonSlice-checkbox" onchange="toggleLonSlice()" checked>
				<label for="show-LonSlice-checkbox">Show Lon Slice</label>
				</div>
				
				<div class="heading-container" onclick="playCreateSiteModelViews()">
					<h4>Create Site Model Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
					<select id="viewSelector4" onchange="updateDescription4()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description4" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView4()">&#8593;</button>
					<button onclick="nextView4()">&#8595;</button>
					<button onclick="savePlot4()">Save View</button>
					<button onclick="loadPlot4()">Load View</button>
				</div>
				
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector8" onchange="updateDescription8()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description8" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot8()">Save View</button>
				</div>
				
				<div class="heading-container" onclick="audioPlayerSelectModelPoints()">
					<h4>Select Model Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleModelForm()">View Model Points</button>
					<form id="ModelcheckboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Model Points:</legend>
							<ul id="ModelcheckboxList"></ul>
						</fieldset>
						<button type="button" onclick="ModelselectAll()">Select All</button>
						<button type="button" onclick="ModeldeselectAll()">Deselect All</button>
						<button type="button" onclick="ModelshowSelectedPoints()">Render Model</button>
						<input type="text" id="ModelSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ModelsaveSelection()">Save Selection</button>
						<select id="ModelSelectionDropdown"></select>
						<button type="button" onclick="ModelloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionModel()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>
			
			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioPointDataTraces()">
					<h2>Point Data Traces</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<select id="PointSelector" onchange="selectPoint()">
					<option value="" disabled selected>Select Point</option>
				</select><br>
				<div id="Traceplot-0-Lith" style="display: inline-block;"></div>
				<div id="Traceplot-1-Aqui" style="display: inline-block;"></div>
				<div id="Traceplot-2-Cond" style="display: inline-block;"></div>
				<div id="Traceplot-3-Frac" style="display: inline-block;"></div>
				<div id="Traceplot-4-Min" style="display: inline-block;"></div>
				<div id="Traceplot-5-Max" style="display: inline-block;"></div>
				<div id="Traceplot-6-Sus" style="display: inline-block;"></div>
				<div id="Traceplot-7-PrimK" style="display: inline-block;"></div>
				<div id="Traceplot-8-SecK" style="display: inline-block;"></div>
				<div id="Traceplot-9-Poro" style="display: inline-block;"></div>
				<div id="Traceplot-10-SStor" style="display: inline-block;"></div>
				<div id="Traceplot-11-Stor" style="display: inline-block;"></div>
				<div id="Traceplot-12-Diff" style="display: inline-block;"></div>
				<div id="Traceplot-13-Clay" style="display: inline-block;"></div>
				<div id="Traceplot-14-Dens" style="display: inline-block;"></div>
				<div id="Traceplot-15-Shear" style="display: inline-block;"></div>
				<div id="Traceplot-16-Bulk" style="display: inline-block;"></div>
				<div id="Traceplot-17-Comp" style="display: inline-block;"></div>
				<div id="Traceplot-18-Yong" style="display: inline-block;"></div>
				<div id="Traceplot-19-WQ" style="display: inline-block;"></div>
				<div id="Traceplot-20-AI" style="display: inline-block;"></div>
				<div id="Traceplot-21-FC" style="display: inline-block;"></div>
				<div id="Traceplot-22-SPTN" style="display: inline-block;"></div>
				<div id="Traceplot-23-SPTRQD" style="display: inline-block;"></div>
				<div id="Traceplot-24-SV" style="display: inline-block;"></div>
				<div id="Traceplot-25-AcouI" style="display: inline-block;"></div>
				<div id="Traceplot-26-FR" style="display: inline-block;"></div>
				<div id="Traceplot-27-TC" style="display: inline-block;"></div>
				<div id="Traceplot-28-CA" style="display: inline-block;"></div>
				<div id="Traceplot-29-QP" style="display: inline-block;"></div>
				<div id="Traceplot-30-QS" style="display: inline-block;"></div>
				<div id="Traceplot-31-Res" style="display: inline-block;"></div>
				<div id="Traceplot-32-ET" style="display: inline-block;"></div>
				<div id="Traceplot-33-MT" style="display: inline-block;"></div>
				<div id="Traceplot-34-PT" style="display: inline-block;"></div>
				<div id="Traceplot-35-PP" style="display: inline-block;"></div>
				<div id="Traceplot-36-MT" style="display: inline-block;"></div>
				<div id="Traceplot-37-MP" style="display: inline-block;"></div>
				<div id="Traceplot-38-PC" style="display: inline-block;"></div>
				<div id="Traceplot-39-AP" style="display: inline-block;"></div>
				<div id="Traceplot-40-Temp" style="display: inline-block;"></div>
				<div id="Traceplot-41-AC" style="display: inline-block;"></div>
				<div id="Traceplot-42-OIL" style="display: inline-block;"></div>
				<div id="Traceplot-43-SAT" style="display: inline-block;"></div>
				<br><br>
			</div>
			
			<p style="page-break-after: always;">&nbsp;</p>
			<div class="block-container">
				<div class="heading-container" onclick="playAudioPointVirtualLogs()">
					<h2>Point Virtual Logs</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<select id="rowSelector" onchange="selectRow()">
					<option value="" disabled selected>Select Point Log</option>
				</select><br><br>
				
				<div class="newtable-container">
				<table id="selectedRowData">
					<thead>
						<tr>
							<th>No</th>
							<th>L</th>
							<th>A</th>
							<th>From (mbgl)</th>
							<th>To (mbgl)</th>
							<th>Lithology</th>
							<th>Aquifer</th>
							<th>Condition</th>
							<th>Fractured Aquifer</th>
							<th>Min Yield (l/s)</th>
							<th>Max Yield (l/s)</th>
							<th>Sus Yield (l/s)</th>
							<th>Porespace Hydraulic Conductivity (m/d)</th>
							<th>Matrix  Hydraulic Conductivity (m/d)</th>
							<th>Porosity (%)</th>
							<th>Specific Storage (1/m)</th>
							<th>Storativity</th>
							<th>Diffusivity (m2/d)</th>
							<th>Clay(%)</th>
							<th>Density (kg/m3)</th>
							<th>Shear Mod (Pa)</th>
							<th>Bulk Mod (Pa)</th>
							<th>Compressibility (1/Pa)</th>
							<th>Youngs Mod (Pa)</th>
							<th>Water Quality (%)</th>
							<th>Formation Aquifer Indicator</th>
							<th>Formation Fracturing</th>
							<th>SPTN</th>
							<th>SPTRQD</th>
							<th>Seismic Velocity (m/s)</th>
							<th>Acoustic Impedance (Pa s/m3)</th>
							<th>Frenzel Radius (m)</th>
							<th>Transmission Coefficient</th>
							<th>Critical Angle (Deg)</th>
							<th>Seismic Attenuation Qp (GPa)</th>
							<th>Seismic Attenuation Qs (GPa)</th>
							<th>Apparent Electric Field Strength (V/m)</th>
							<th>Poisson Ratio (Ratio)</th>
							<th>Specific Volume (m3/kg)</th>
							<th>Porespace Transmissivity (m2/d)</th>
							<th>Porespace Permeability (md)</th>
							<th>Matrix Transmissivity (m2/d)</th>
							<th>Matrix Permeability (md)</th>
							<th>Permeability Contrast (Ratio)</th>
							<th>Aquifer Probability (%)</th>
							<th>Formation Temperature (degC)</th>
							<th>Aquiclude Probability (%)</th>
							<th>Hydrocarbon Probability (%)</th>
							<th>Saturation (%)</th>
						</tr>
					</thead>
					<tbody id="selectedRow">
					</tbody>
				</table>
				</div>
				<br>
				<button onclick="exportTableToExcel('selectedRowData', 'ExportedData')">Export to Excel</button>
			</div>
		</div>

		<button id="help-btn" title="Help">
			<b>?</b>
		</button>
		
		<audio id="audioPlayerIntroduction" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Introduction 2.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSurveySiteMap" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Survey Site Map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerRecommendations" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Recommendations.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSurveyPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Survey Points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerViewDataSetDescriptions" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View data descriptions.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerAquiferClassification" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Aquifer classification map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerWaterSheds" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Water Shed map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerLithology" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Lithology map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerGroundwaterLevel" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Groundwater level map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerFaulting" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Faulting map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSalineAquifers" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Saline aquifers map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerGeothermal" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Geothermal map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteParameterMaps" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site parameters maps.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteSectionLine" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site Section Line.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSectionSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Section Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSelectSectionPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select section points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteModels" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site models.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerModelSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Model settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSliceSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Slice settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerPointDataTraces" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Point data traces.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerPointVirtualLogs" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Point Virtual Logs.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSelectModelPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select Model points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>

		<audio id="audioPlayerSelectProfilePoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select Model points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>

		<audio id="audioPlayerSiteMapSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site Map Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerReportDataElevationSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Report Data Elevation Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerViewGISDataMaps" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View GIS Data Maps.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteParameterMapViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Parameter Map Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreatePresentationViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Presentation Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteSectionLineViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Section Line Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerSectionAmplitudeSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Section Amplitude Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteProfileViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Profile Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteModelViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Model Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerViewControls" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View Controls.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerPresentationViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Presentation Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>

		<script>
			var VolData =[];
			var VolDataMax = 0;
			var isominValue = 70;
			var isomaxValue = 100;
			var selectedDataHold = 'dataset1'
			var HoldModelUnit = '';
			var TopEndMeshdataHold = [];
			var rawTopdataHold = [];
			var logscatterdataHold = [];
			var VolumeState = 1;
			var TopographyState = 1;
			var PointsState = 1;
			var LogState = 1;
			var OrthoState = 0;
			var OrthoString = '';
			var DepthSliceState = 1;
			var LatSliceState = 1;
			var LonSliceState = 1;
			var SectionLogsState = 0;			
			var FracturePointState = 0;			
			var ExternalDataState = 0;
			var HoldFracscatterData = [];			
			var HoldSectioncontourData = [];
			var HoldSectionLogscatterData = [];
			var HoldSectionExtLogscatterData = [];
			var HoldSectionToplineData = [];
			var HoldSectionBottomlineData = [];
			var HoldSectionlayout = [];
			var HoldcontourDataScatter = [];
			var HoldLayout = [];
			var DepthSliceCount = 50;
			var LatSliceCount = 15;
			var LonSliceCount = 15;
			var UpdateSliceDepthArray = [];
			var UpdateSliceLatArray = [];
			var UpdateSliceLonArray = [];
			var SiteMapcontourData = []; 
			var SiteMapscatterData = [];
			var HoldSiteMaplayout = [];
			var SectionBoxData = [];
			var ModelBoxData = [];
			var HoldselectedData = '';
			var HolddataLith = [];
			var HolddataAqui = [];
			var HolddataCond = [];
			var HolddataFrac = [];
			var HolddataMin = [];
			var HolddataMax = [];
			var HolddataSus = [];
			var HolddataPrimK = [];
			var HolddataSecK = [];
			var HolddataPoro = [];
			var HolddataSStor = [];
			var HolddataStor = [];
			var HolddataDiff = [];
			var HolddataClay = [];
			var HolddataDens = [];
			var HolddataShear = [];
			var HolddataBulk = [];
			var HolddataComp = [];
			var HolddataYong = [];
			var HolddataWQ = [];
			var HolddataAI = [];
			var HolddataFC = [];
			var HolddataSPTN = [];
			var HolddataSPTRQD = [];
			var HolddataSV = [];
			var HolddataAcouI = [];
			var HolddataFR = [];
			var HolddataTC = [];
			var HolddataCA = [];
			var HolddataQP = [];
			var HolddataQS = [];
			var HolddataRes = [];
			var HolddataET = [];
			var HolddataMagT = [];
			var HolddataPT = [];
			var HolddataPP = [];
			var HolddataMT = [];
			var HolddataMP = [];
			var HolddataPC = [];
			var HolddataAP = [];
			var HolddataTemp = [];
			var HolddataAquilude = [];
			var HolddataOil = [];
			var HolddataSAT = [];
			var ProfileBoxData = new Array(3);
			for (var i = 0; i < ProfileBoxData.length; i++) {
				ProfileBoxData[i] = [];
			}
			var HoldProfileSurfaceGroup = [];
			var HoldProfilerawTopdata = [];
			var HoldProfileLayout = [];
			var ProfileselectedDataHold = 'dataset1';
			var ContourBoxData = [];
			var ContourHoldselectedData = '';
			var gd = document.getElementById('plotly-Model1');
			var animationButton = document.getElementById('animation-btn');
			var animationInterval;
			var isAnimating = false;
			var Profgd = document.getElementById('plotly-Profile1');
			var ProfanimationButton = document.getElementById('Profanimation-btn');
			var ProfanimationInterval;
			var ProfisAnimating = false;
			var SiteMapShowRecPointsOnly = false;
			var SiteMapShowRecPointsOnlychanged = false;
			var SiteMapmarkers = [];
			var SiteMapmarkersInst;
			var UserSetmaxValue = 100;
			var map1;
			var map2;
			var map3;
			var map4;
			var map5;
			var map6;
			var map7;
			var map8;			
			var HoldPresentationLayout =[];			
			var SRTMLoaded = 0;
			var BoxElevationArray = [];
			let SRTMelevations = [];			
			let GlobalTemperature = 25;			
			let CorrectChart = 0;						
			var SiteMaplines = [];
			var SiteMapShowLines = false;
			var SiteMapShowRecomendationPoints = false;
			var RecDetected = false;
			
			var VerticalLable = 0;
			
			const FormationFractureCondition = [
			  'Unfractured',
			  'Fractured'
			];
			
			const FormationCondition = [
			  'Unaltered',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Porous',
			  'Fractured',
			  'Course',
			  'Fine',
			  'Soil'
			];

			const AquiferTypeFull = [  
			  'Unclassified',
			  'Weathered Ultra Mafic',
			  'Fractured Ultra Mafic',
			  'Weathered Metamorphic',
			  'Fractured Metamorphic',
			  'Weathered Mafic',
			  'Fractured Mafic',
			  'Weathered Igneous',
			  'Fractured Igneous',
			  'Weathered Conglomerate',
			  'Fractured Conglomerate',
			  'Weathered Volcanic',
			  'Fractured Volcanic',
			  'Weathered Sedimentary',
			  'Fractured Sedimentary',
			  'Dual Porosity Sediment',
			  'Unconsolidated Sediment',
			  'Saturated Soil'
			];
			
			const AquiferType = [
			  'Unclassified',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Conglomerate',
			  'Conglomerate',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Dual Porosity',
			  'Unconsolidated',
			  'Saturated'
			];

			const LithType = [
			  'Unclassified',
			  'Soil',
			  'Sediment',
			  'Volcanic',
			  'Conglomerate',
			  'Sedimentary',
			  'Igneous',
			  'Salt',
			  'Mafic',
			  'Metamorphic',
			  'Ultra Mafic'
			];
			
			const AquiferTypeColor = [
			  'LightGrey',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'Blue',
			  'Navy',
			  'Aqua'
			];

			const LithTypeColor = [
			  'LightGrey',
			  'Brown',
			  'Yellow',
			  'Silver',
			  'Green',
			  'Orange',
			  'MediumGray',
			  'Cream',
			  'Gray',
			  'DarkGrey',
			  'Black'
			];
			
			let CaseDepth = 0;
			let ScreenDepth = 10000;
			let WellD = 152.4;
			const selectionPointArray = [];
			let ExternalDataArray = [];
			const plotDataStorage1 = Array(20).fill(null).map(() => ({ data: null, layout: null, description: "" }));
			const plotDataStorage2 = Array(20).fill(null).map(() => ({ data: null, layout: null, description: "" }));
			const plotDataStorage3 = Array(20).fill(null).map(() => ({ data: null, layout: null, description: "" }));
			const plotDataStorage4 = Array(20).fill(null).map(() => ({ data: null, layout: null, description: "" }));
			const plotDataStorage5 = Array(50).fill(null).map(() => ({ data: null, layout: null, description: "" }));

			&&&###
			
			var datasets = {
				dataset1: {
				  name: 'Calculated Sustainable Yield Estimate(l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cjegt9c5l1x672qqghx7cya9p',
				  SectionName : 'Calculated Formation Type Estimate',
				  LegendUnit: 'Lith Group',
				  SectionIndex : 2,
				  Index : 0
				},
				dataset2: {
				  name: 'Calculated Minimum Yield Estimate (l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cjegw9m9q5xi32sn7gk1h9cyr',
				  SectionName : 'Calculated Aquifer Type Estimate',
				  LegendUnit: 'Aqui Group',
				  SectionIndex : 3,
				  Index : 1
				},
				dataset3: {
				  name: 'Calculated Maximum Yield Estimate (l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cj574xv2o32t32so13rwxp8xd',
				  SectionName : 'Calculated Formation Condition Estimate',
				  LegendUnit: 'Cond',
				  SectionIndex : 4,
				  Index : 2
				},
				dataset4: {
				  name: 'Calculated Ground water level Estimate (mbgl)',
				  unit: 'mbgl',
				  ID : 'atsgeosuite/cj4kr154256zy2sn5j1fhpjru',
				  SectionName : 'Calculated Aquifer Formation Fracturing Estimate',
				  LegendUnit: 'Frac',
				  SectionIndex : 5,
				  Index : 3
				},
				dataset5: {
				  name: 'Calculated Drilling Depth Estimate (mbgl)',
				  unit: 'mbgl',
				  ID : 'atsgeosuite/cj574ejge327j2rmtgchz8002',
				  SectionName : 'Calculated Min Yeild Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 6,
				  Index : 4
				},
				dataset6: {
				  name: 'Calculated Risk (%)',
				  unit: '%',
				  ID : 'atsgeosuite/cjegvjtxi1zbg2qqg0kgzsqul',
				  SectionName : 'Calculated Max Yield Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 7,
				  Index : 5
				},
				dataset7: {
				  name: 'Calculated Interpretion Confidence (%)',
				  unit: '%',
				  ID : 'atsgeosuite/cjfs65s3j1fd52sn2fl9rfc74',
				  SectionName : 'Calculated Sus Yield Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 8,
				  Index : 6
				},
				dataset8: {
				  name: 'Measured Correlation (%)',
				  unit: '%',
				  ID : '',
				  SectionName : 'Calculated Porespace Hydraulic Conductivity Estimate (m/d)',
				  LegendUnit: 'm/d',
				  SectionIndex : 9,
				  Index : 7
				},
				dataset9: {
				  name: 'Measured Signal to Noise Ratio',
				  unit: 'SNR',
				  ID : '',
				  SectionName : 'Calculated Matrix Hydraulic Conductivity Estimate (m/d)',
				  LegendUnit: 'm/d',
				  SectionIndex : 10,
				  Index : 8
				},
				dataset10: {
				  name: 'Measured Strikes Used',
				  unit: 'Strikes',
				  ID : '',
				  SectionName : 'Calculated Porosity Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 11,
				  Index : 9
				},
				dataset11: {
				  name: 'Measured GPS Elevation (masl)',
				  unit: 'masl',
				  ID : '',
				  SectionName : 'Calculated Specific Storage Estimate (1/m)',
				  LegendUnit: '1/m',
				  SectionIndex : 12,
				  Index : 10
				},
				dataset12: {
				  name: 'Calculated Sustainable Yield Estimate 100m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Storativity Estimate',
				  LegendUnit: 'unitless',
				  SectionIndex : 13,
				  Index : 11
				},
				dataset13: {
				  name: 'Calculated Sustainable Yield Estimate 200m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Porespace Diffusivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 14,
				  Index : 12
				},
				dataset14: {
				  name: 'Calculated Sustainable Yield Estimate 300m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Clay Content Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 15,
				  Index : 13
				},
				dataset15: {
				  name: 'Calculated Sustainable Yield Estimate 400m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Density Estimate (kg/m3)',
				  LegendUnit: 'kg/m3',
				  SectionIndex : 16,
				  Index : 14
				},
				dataset16: {
				  name: 'Calculated Sustainable Yield Estimate 500m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Shear Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 17,
				  Index : 15
				},
				dataset17: {
				  name: 'Calculated Sustainable Yield Estimate 600m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Bulk Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 18,
				  Index : 16
				},
				dataset18: {
				  name: 'Calculated Sustainable Yield Estimate 700m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Compressibility Estimate (1/Pa)',
				  LegendUnit: '1/Pa',
				  SectionIndex : 19,
				  Index : 17
				},
				dataset19: {
				  name: 'Calculated Sustainable Yield Estimate 800m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Youngs Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 20,
				  Index : 18
				},
				dataset20: {
				  name: 'Calculated Sustainable Yield Estimate 900m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Relative Water Quality Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 21,
				  Index : 19
				},
				dataset21: {
				  name: 'Calculated Sustainable Yield Estimate 1000m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Formation Aquifer Indicator',
				  LegendUnit: 'unitless',
				  SectionIndex : 22,
				  Index : 20
				},
				dataset22: {
				  name: 'Calculated Soil Depth (mbgl)',
				  unit: 'mbgl',
				  ID : '',
				  SectionName : 'Measured Formation Fracturing (Count)',
				  LegendUnit: 'Count',
				  SectionIndex : 23,
				  Index : 21
				},
				dataset23: {
				  name: 'Calculated Soil Density (kg/m3)',
				  unit: 'kg/m3',
				  ID : '',
				  SectionName : 'Calculated SPTN Estimate (Unitless)',
				  LegendUnit: 'Unitless',
				  SectionIndex : 24,
				  Index : 22
				},
				dataset24: {
				  name: 'Calculated Soil Porosity (%)',
				  unit: '%',
				  ID : '',
				  SectionName : 'Calculated SPTRQD Estimate (Unitless)',
				  LegendUnit: 'Unitless',
				  SectionIndex : 25,
				  Index : 23
				},
				dataset25: {
				  name: 'Calculated Soil Shear Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Seismic P-Wave Velocity Estimate (m/s)',
				  LegendUnit: 'm/s',
				  SectionIndex : 26,
				  Index : 24
				},
				dataset26: {
				  name: 'Calculated Soil Bulk Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Acoustic Impeadance Estimate (Pa s/m3)',
				  LegendUnit: 'Pa s/m3',
				  SectionIndex : 27,
				  Index : 25
				},
				dataset27: {
				  name: 'Calculated Soil Compressibility (1/Pa)',
				  unit: '1/Pa',
				  ID : '',
				  SectionName : 'Calculated Frenzel Radius Estimate (m)',
				  LegendUnit: 'm',
				  SectionIndex : 28,
				  Index : 26
				},
				dataset28: {
				  name: 'Calculated Soil Poisson Ratio (Ratio)',
				  unit: 'Ratio',
				  ID : '',
				  SectionName : 'Calculated Transmittion Coefficient Estimate (Coeff)',
				  LegendUnit: 'Coeff',
				  SectionIndex : 29,
				  Index : 27
				},
				dataset29: {
				  name: 'Calculated Soil Youngs Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Critical Angle Estimate (Deg)',
				  LegendUnit: 'Deg',
				  SectionIndex : 30,
				  Index : 28
				},
				dataset30: {
				  name: 'Calculated Soil Acoustic Impeadance (Pa s/m3)',
				  unit: 'Pa s/m3',
				  ID : '',
				  SectionName : 'Calculated Seismic Attenuation Qp Estimate (GPa)',
				  LegendUnit: 'GPa',
				  SectionIndex : 31,
				  Index : 29
				},
				dataset31: {
				  name: 'Calculated Soil Storativity',
				  unit: 'unitless',
				  ID : '',
				  SectionName : 'Calculated Seismic Attenuation Qs Estimate (GPa)',
				  LegendUnit: 'GPa',
				  SectionIndex : 32,
				  Index : 30
				},
				dataset32: {
				  name: 'Calculated Soil Diffusivity (m2/d)',
				  unit: 'm2/d',
				  ID : '',
				  SectionName : 'Calculated Apparent Electric Field Strength Estimate (V/m)',
				  LegendUnit: 'V/m',
				  SectionIndex : 33,
				  Index : 31
				},
				dataset33: {
				  name: 'Calculated Soil Hydraulic Conductivity (m/d)',
				  unit: 'm/d',
				  ID : '',
				  SectionName : 'Calculated Poisson Ratio Estimate (Ratio)',
				  LegendUnit: 'Ratio',
				  SectionIndex : 34,
				  Index : 32
				},
				dataset34: {
				  name: 'Calculated Soil Transmissivity (m2/d)',
				  unit: 'm2/d',
				  ID : '',
				  SectionName : 'Calculated Specific Volume Estimate (m3/kg)',
				  LegendUnit: 'm3/kg',
				  SectionIndex : 35,
				  Index : 33
				},
				dataset35: {
				  name: 'Calculated Soil Permeability (md)',
				  unit: 'md',
				  ID : 'QUl6YQ==',
				  SectionName : 'Calculated Porespace Transmissivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 36,
				  Index : 34
				},
				dataset36: {
				  name: 'Calculated Soil Clay Content (%)',
				  unit: '%',
				  ID : 'U3lBcw==',
				  SectionName : 'Calculated Porespace Permeability Estimate (md)',
				  LegendUnit: 'md',
				  SectionIndex : 37,
				  Index : 35
				},
				dataset37: {
				  name: 'Calculated Soil SPTN (Unitless)',
				  unit: 'Unitless',
				  ID : 'RkJ3Zw==',
				  SectionName : 'Calculated Matrix Transmisivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 38,
				  Index : 36
				},
				dataset38: {
				  name: 'Calculated Soil SPTRQD (Unitless)',
				  unit: 'Unitless',
				  ID : 'bWQzX2I=',
				  SectionName : 'Calculated Matrix Permeability Estimate (md)',
				  LegendUnit: 'md',
				  SectionIndex : 39,
				  Index : 37
				},
				dataset39: {
				  name: 'Noise (v)',
				  unit: 'V',
				  ID : 'VzF0LVpv',
				  SectionName : 'Calculated Permeability Contrast Estimate (Ratio)',
				  LegendUnit: 'Ratio',
				  SectionIndex : 40,
				  Index : 38
				},
				dataset40: {
				  name: 'Processing Depth (m)',
				  unit: 'm',
				  ID : 'MV9OZnM=',
				  SectionName : 'Calculated Aquifer Probability (%)',
				  LegendUnit: '%',
				  SectionIndex : 41,
				  Index : 39
				},
				dataset41: {
				  name: 'Vertical Resolution (m)',
				  unit: 'm',
				  ID : 'ZW9fTlE5',
				  SectionName : 'Calculated Formation Temperature Estimate (DegC)',
				  LegendUnit: 'DegC',
				  SectionIndex : 42,
				  Index : 40
				},
				dataset42: {
				  name: 'Uncertainty (%)',
				  unit: '%',
				  ID : 'ZWl3MkE=',
				  SectionName : 'Calculated Relative Formation Aquiclude Probability (%)',
				  LegendUnit: '%',
				  SectionIndex : 43,
				  Index : 41
				},
				dataset43: {
				  name: '',
				  unit: '',
				  ID : '',
				  SectionName : 'Calculated Hydrocarbon Potential (%)',
				  LegendUnit: '%',
				  SectionIndex : 44,
				  Index : 42
				},
				dataset44: {
				  name: '',
				  unit: '',
				  ID : '',
				  SectionName : 'Calculated Seismic Reflection',
				  LegendUnit: '',
				  SectionIndex : 45,
				  Index : 43
				},
				dataset45: {
				  name: '',
				  unit: '',
				  ID : '',
				  SectionName : 'Calculated Formation Saturation',
				  LegendUnit: '%',
				  SectionIndex : 45,//This index is 45 because the Seismic reflection data is calculated and not in BoxData
				  Index : 44
				}
			};
			
			document.getElementById("WellDiameter").value = WellD;
			document.getElementById("CaseDepth").value = CaseDepth;
			document.getElementById("ScreenDepth").value = ScreenDepth;
			
			for (let i = 0; i < BoxData.data.length; i++)
			{
				BoxData.data[i][1] = parseFloat(BoxData.data[i][1]);
				BoxData.data[i][2] = parseFloat(BoxData.data[i][2]);
				BoxData.data[i][3][10] = parseFloat(BoxData.data[i][3][10]);
			}
			
			for (let i = 0; i < BoxData.data.length; i++)
			{
				if (BoxData.data[i][4] > 0)
				{
					RecDetected = true;
				}
			}
			if (RecDetected == false)
			{
				let indexedData = BoxData.data.map((item, index) => ({ originalIndex: index, data: item }));
				indexedData.sort((a, b) => b.data[3][0] - a.data[3][0]);
				indexedData.forEach((item, rank) => {
					item.data[4] = rank + 1;
				});
				
			
			}
			
			var tableHTML = '<table>';
			var ReccomCount = 1;
			tableHTML += '<tr><th>Rec No.</th><th>Point</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th></th></tr>';
			
			for (var i = 0; i < 10; i++)
			{
			BoxData.data.forEach(function(row) 
			{
				if (row[4] == i)
				{
					tableHTML += '<tr>';
					tableHTML += '<td>' + row[4] + '</td>';
					tableHTML += '<td>' + row[0] + '</td>';
					tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>'; // Lat
					tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>'; // Lon
					tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
					tableHTML += '<td>' + row[3][0] + '</td>';
					tableHTML += '<td>' + row[3][1] + '</td>';
					tableHTML += '<td>' + row[3][2] + '</td>';
					tableHTML += '<td>' + row[3][5] + '</td>';
					tableHTML += '<td>' + row[3][6] + '</td>';
					tableHTML += '<td>' + row[3][4] + '</td>';
					tableHTML += '</tr>';
				}
			});
			}
			tableHTML += '</table>';
			document.getElementById('RecdataTable').innerHTML = tableHTML;

			function refreshRecTable() {
				// Initialize the table HTML with headers
				var tableHTML = '<table>';
				tableHTML += '<tr><th>Rec No.</th><th>Point</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th></th></tr>';

				// Loop through data and populate the table rows
				for (var i = 0; i < 10; i++) {
					BoxData.data.forEach(function(row) {
						if (row[4] == i) {
							tableHTML += '<tr>';
							tableHTML += '<td>' + row[4] + '</td>'; // Rec No.
							tableHTML += '<td>' + row[0] + '</td>'; // Point
							tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>'; // Lat
							tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>'; // Lon
							tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
							tableHTML += '<td>' + row[3][0] + '</td>'; // Sust. yield (l/s)
							tableHTML += '<td>' + row[3][1] + '</td>'; // Min yield (l/s)
							tableHTML += '<td>' + row[3][2] + '</td>'; // Max yield (l/s)
							tableHTML += '<td>' + row[3][5] + '</td>'; // Risk (%)
							tableHTML += '<td>' + row[3][6] + '</td>'; // Interp. Confidence (%)
							tableHTML += '<td>' + row[3][4] + '</td>'; // Drill Depth (mbgl)
							tableHTML += '</tr>';
						}
					});
				}

				// Close the table tag
				tableHTML += '</table>';

				// Update the DOM with the new table HTML
				document.getElementById('RecdataTable').innerHTML = tableHTML;
			}
			
			function ProfilecreateCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ProfilecheckboxListOne');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ProfileBoxData[0].push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointOne';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedOne(checkbox);
					});
				}
			
				const checkboxListTwo = document.getElementById('ProfilecheckboxListTwo');
				for (let i = 0; i < DataArray.length; i++) 
				{
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointTwo';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = false;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxListTwo.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedTwo(checkbox);
					});
				}
			
				const checkboxListThree = document.getElementById('ProfilecheckboxListThree');
				for (let i = 0; i < DataArray.length; i++) 
				{
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointThree';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = false;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxListThree.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedThree(checkbox);
					});
				}
			}
			ProfilecreateCheckboxes();
			
			function ProfileselectAllOne() 
			{
				ProfileBoxData[0] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointOne');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[0].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllOne() 
			{
				ProfileBoxData[0] = [];
				const checkboxes = document.getElementsByName('PPointOne');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedOne(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[0].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsOne() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointOne');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ProfileselectAllTwo() 
			{
				ProfileBoxData[1] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointTwo');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[1].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllTwo() 
			{
				ProfileBoxData[1] = [];
				const checkboxes = document.getElementsByName('PPointTwo');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedTwo(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[1].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsTwo() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointTwo');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ProfileselectAllThree() 
			{
				ProfileBoxData[2] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointThree');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[2].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllThree() 
			{
				ProfileBoxData[2] = [];
				const checkboxes = document.getElementsByName('PPointThree');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedThree(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[2].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsThree() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointThree');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ModelcreateCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ModelcheckboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ModelBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'MPoint';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ModelcheckboxChanged(checkbox);
					});
				}
			}
			ModelcreateCheckboxes();
			
			function ModelselectAll() 
			{
				ModelBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('MPoint');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ModelBoxData.push(DataArray[checkbox.value]);
				});
			}

			function ModeldeselectAll() 
			{
				ModelBoxData = [];
				const checkboxes = document.getElementsByName('MPoint');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ModelcheckboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ModelBoxData.push(DataArray[checkbox.value]);
				}
			}

			function ModelshowSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('MPoint');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateVolumePlot(selectedDataHold);
					generateSiteMapLines(map1, ModelBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function createCheckboxesContour() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ContourcheckboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ContourBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'CPoint';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ContourcheckboxChanged(checkbox);
					});
				}
			}
			createCheckboxesContour();
			
			function ContourselectAll() 
			{
				ContourBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('CPoint');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ContourBoxData.push(DataArray[checkbox.value]);
				});
			}

			function ContourdeselectAll() 
			{
				ContourBoxData = [];
				const checkboxes = document.getElementsByName('CPoint');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ContourcheckboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ContourBoxData.push(DataArray[checkbox.value]);
				}
			}

			function ContourshowSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('CPoint');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateContourPlot(ContourHoldselectedData);
					generateSiteMapLines(map1, ContourBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function createCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('checkboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					SectionBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'Point';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						checkboxChanged(checkbox);
					});
				}
			}
			createCheckboxes();
			
			function selectAll() 
			{
				SectionBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('Point');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					SectionBoxData.push(DataArray[checkbox.value]);
				});
			}

			function deselectAll() 
			{
				SectionBoxData = [];
				const checkboxes = document.getElementsByName('Point');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function checkboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					SectionBoxData.push(DataArray[checkbox.value]);
				}
			}

			function showSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('Point');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateSectionPlot(HoldselectedData);
					generateSiteMapLines(map1, SectionBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			if ( selectionPointArray.length === 0)
			{
				selectionPointArray.push({
					name: "All",
					data: SectionBoxData
				});
			
				const Contourdropdown = document.getElementById('ContourSelectionDropdown');
				Contourdropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Contourdropdown.appendChild(option);
				});

				const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
				Sectiondropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Sectiondropdown.appendChild(option);
				});
			
				const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
				ProfileOnedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileOnedropdown.appendChild(option);
				});
				
				const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
				ProfileTwodropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileTwodropdown.appendChild(option);
				});
				
				const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
				ProfileThreedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileThreedropdown.appendChild(option);
				});
				
				const Modeldropdown = document.getElementById('ModelSelectionDropdown');
				Modeldropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Modeldropdown.appendChild(option);
				});
			}
			else
			{
				const Contourdropdown = document.getElementById('ContourSelectionDropdown');
				Contourdropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Contourdropdown.appendChild(option);
				});
				
				const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
				Sectiondropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Sectiondropdown.appendChild(option);
				});
				
				const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
				ProfileOnedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileOnedropdown.appendChild(option);
				});
			
				const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
				ProfileTwodropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileTwodropdown.appendChild(option);
				});
			
				const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
				ProfileThreedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileThreedropdown.appendChild(option);
				});
			
				const Modeldropdown = document.getElementById('ModelSelectionDropdown');
				Modeldropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Modeldropdown.appendChild(option);
				});
			}
			
			function updateCheckboxList(checkboxListId, DataArray) {
				// Get the checkbox list element by ID
				const checkboxList = document.getElementById(checkboxListId);

				// Get all checkboxes within the checkbox list
				const checkboxes = checkboxList.getElementsByTagName('input');

				// Uncheck all checkboxes in the list
				for (let i = 0; i < checkboxes.length; i++) {
					checkboxes[i].checked = false; // Uncheck each checkbox
				}

				// Check the checkboxes that match DataArray
				for (let i = 0; i < DataArray.length; i++) {
					const checkboxId = 'Point' + DataArray[i][0]; // Generate checkbox ID from DataArray

					// Loop through checkboxes to find the matching one
					for (let v = 0; v < checkboxes.length; v++) {
						if (checkboxes[v].id === checkboxId) { // Corrected the condition by closing parenthesis
							checkboxes[v].checked = true; // Check the checkbox if the ID matches
						}
					}
				}
			}
			
			function RefreshSelectionDropdownLists() {
			  const Contourdropdown = document.getElementById('ContourSelectionDropdown');
			  Contourdropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Contourdropdown.appendChild(option);
			  });

			  const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
			  Sectiondropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Sectiondropdown.appendChild(option);
			  });

			  const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
			  ProfileOnedropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileOnedropdown.appendChild(option);
			  });

			  const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
			  ProfileTwodropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileTwodropdown.appendChild(option);
			  });

			  const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
			  ProfileThreedropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileThreedropdown.appendChild(option);
			  });

			  const Modeldropdown = document.getElementById('ModelSelectionDropdown');
			  Modeldropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Modeldropdown.appendChild(option);
			  });
			}

			function ContoursaveSelection()
			{
				const selectionName = document.getElementById('ContourSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ContourBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ContourSelectionName').value = "";
			}
			
			function SectionsaveSelection()
			{
				const selectionName = document.getElementById('SectionSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: SectionBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('SectionSelectionName').value = "";
			}
			
			function ProfileOnesaveSelection()
			{
				const selectionName = document.getElementById('ProfileOneSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					//return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[0]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileOneSelectionName').value = "";
			}
			
			function ProfileTwosaveSelection()
			{
				const selectionName = document.getElementById('ProfileTwoSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[1]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileTwoSelectionName').value = "";
			}
			
			function ProfileThreesaveSelection()
			{
				const selectionName = document.getElementById('ProfileThreeSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[2]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileThreeSelectionName').value = "";
			}
			
			function ModelsaveSelection()
			{
				const selectionName = document.getElementById('ModelSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ModelBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ModelSelectionName').value = "";
			}

			function ContourloadSelection()
			{
				const dropdown = document.getElementById('ContourSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ContourBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ContourcheckboxList', ContourBoxData);
				
				ContourshowSelectedPoints();
				generateSiteMapLines(map1, ContourBoxData, selectionName);
			}
			
			function SectionloadSelection()
			{
				const dropdown = document.getElementById('SectionSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					SectionBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('checkboxList', SectionBoxData);
				
				showSelectedPoints();
				generateSiteMapLines(map1, SectionBoxData, selectionName);
			}
			
			function ProfileOneloadSelection()
			{
				const dropdown = document.getElementById('ProfileOneSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[0] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListOne', ProfileBoxData[0]);
				
				ProfileshowSelectedPointsOne();
				generateSiteMapProfileLines(map1);
			}
			
			function ProfileTwoloadSelection()
			{
				const dropdown = document.getElementById('ProfileTwoSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[1] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListTwo', ProfileBoxData[1]);
				
				ProfileshowSelectedPointsTwo();
				generateSiteMapProfileLines(map1);
			}
			
			function ProfileThreeloadSelection()
			{
				const dropdown = document.getElementById('ProfileThreeSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[2] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListThree', ProfileBoxData[2]);
				
				ProfileshowSelectedPointsThree();
				generateSiteMapProfileLines(map1);
			}
			
			function ModelloadSelection()
			{
				const dropdown = document.getElementById('ModelSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ModelBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ModelcheckboxList', ModelBoxData);
				
				ModelshowSelectedPoints();
				generateSiteMapLines(map1, ModelBoxData, selectionName);
			}

			function selectTracePoint(Index) 
			{
			  var selectElement = document.getElementById("PointSelector");
			  selectElement.selectedIndex = Index;
			}
			
			function populateTraceDropdown() 
			{
				var dropdown = document.getElementById("PointSelector");
				dropdown.innerHTML = "<option value='' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}
			populateTraceDropdown();
			
			function selectPoint() 
			{
				var dropdown = document.getElementById("PointSelector");
				var selectedIndex = dropdown.value;
				if (selectedIndex === "") 
				{
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];
				var dataLith = [];
				var dataAqui = [];
				var dataCond = [];
				var dataFrac = [];
				var dataMin = [];
				var dataMax = [];
				var dataSus = [];
				var dataPrimK = [];
				var dataSecK = [];
				var dataPoro = [];
				var dataSStor = [];
				var dataStor = [];
				var dataDiff = [];
				var dataClay = [];
				var dataDens = [];
				var dataShear = [];
				var dataBulk = [];
				var dataComp = [];
				var dataYong = [];
				var dataWQ = [];
				var dataAI = [];
				var dataFC = [];
				var dataSPTN = [];
				var dataSPTRQD = [];
				var dataSV = [];
				var dataAcouI = [];
				var dataFR = [];
				var dataTC = [];
				var dataCA = [];
				var dataQP = [];
				var dataQS = [];
				var dataRes = [];
				var dataET = [];
				var dataMagT = [];
				var dataPT = [];
				var dataPP = [];
				var dataMT = [];
				var dataMP = [];
				var dataPC = [];
				var dataAP = [];
				var dataTemp = [];
				var dataAquilude = [];
				var dataOil = [];
				var dataSAT = [];
				
				for (var i = 0; i < selectedRowData[6].length; i++) 
				{
					dataLith.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][2]});
					dataLith.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][2]});
					dataAqui.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][3]});
					dataAqui.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][3]});
					dataCond.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][4]});
					dataCond.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][4]});
					dataFrac.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][5]});
					dataFrac.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][5]});
					dataMin.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][6]});
					dataMin.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][6]});
					dataMax.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][7]});
					dataMax.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][7]});
					dataSus.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][8]});
					dataSus.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][8]});
					dataPrimK.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][9]});
					dataPrimK.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][9]});
					dataSecK.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][10]});
					dataSecK.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][10]});
					dataPoro.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][11]});
					dataPoro.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][11]});
					dataSStor.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][12]});
					dataSStor.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][12]});
					dataStor.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][13]});
					dataStor.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][13]});
					dataDiff.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][14]});
					dataDiff.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][14]});
					dataClay.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][15]});
					dataClay.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][15]});
					dataDens.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][16]});
					dataDens.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][16]});
					dataShear.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][17]});
					dataShear.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][17]});
					dataBulk.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][18]});
					dataBulk.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][18]});
					dataComp.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][19]});
					dataComp.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][19]});
					dataYong.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][20]});
					dataYong.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][20]});
					dataWQ.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][21]});
					dataWQ.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][21]});		
					dataAI.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][22]});
					dataAI.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][22]});
					dataFC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][23]});
					dataFC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][23]});
					dataSPTN.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][24]});
					dataSPTN.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][24]});
					dataSPTRQD.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][25]});
					dataSPTRQD.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][25]});
					dataSV.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][26]});
					dataSV.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][26]});
					dataAcouI.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][27]});
					dataAcouI.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][27]});
					dataFR.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][28]});
					dataFR.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][28]});
					dataTC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][29]});
					dataTC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][29]});
					dataCA.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][30]});
					dataCA.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][30]});
					dataQP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][31]});
					dataQP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][31]});
					dataQS.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][32]});
					dataQS.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][32]});
					dataRes.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][33]});
					dataRes.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][33]});
					dataET.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][34]});
					dataET.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][34]});
					dataMagT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][35]});
					dataMagT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][35]});
					dataPT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][36]});
					dataPT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][36]});
					dataPP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][37]});
					dataPP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][37]});
					dataMT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][38]});
					dataMT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][38]});
					dataMP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][39]});
					dataMP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][39]});
					dataPC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][40]});
					dataPC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][40]});
					dataAP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][41]});
					dataAP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][41]});
					dataTemp.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][42] * GlobalTemperature + 10});
					dataTemp.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][42] * GlobalTemperature + 10});
					dataAquilude.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][43]});
					dataAquilude.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][43]});
					dataOil.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][44]});
					dataOil.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][44]});
					dataSAT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][45]});
					dataSAT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][45]});
				}
				HolddataLith = dataLith;
				HolddataAqui = dataAqui;
				HolddataCond = dataCond;
				HolddataFrac = dataFrac;
				HolddataMin = dataMin;
				HolddataMax = dataMax;
				HolddataSus = dataSus;
				HolddataPrimK = dataPrimK;
				HolddataSecK = dataSecK;
				HolddataPoro = dataPoro;
				HolddataSStor = dataSStor;
				HolddataStor = dataStor;
				HolddataDiff = dataDiff;
				HolddataClay = dataClay;
				HolddataDens = dataDens;
				HolddataShear = dataShear;
				HolddataBulk = dataBulk;
				HolddataComp = dataComp;
				HolddataYong = dataYong;
				HolddataWQ = dataWQ;
				HolddataAI = dataAI;
				HolddataFC = dataFC;
				HolddataSPTN = dataSPTN;
				HolddataSPTRQD = dataSPTRQD;
				HolddataSV = dataSV;
				HolddataAcouI = dataAcouI;
				HolddataFR = dataFR;
				HolddataTC = dataTC;
				HolddataCA = dataCA;
				HolddataQP = dataQP;
				HolddataQS = dataQS;
				HolddataRes = dataRes;
				HolddataET = dataET;
				HolddataMagT = dataMagT;
				HolddataPT = dataPT;
				HolddataPP = dataPP;
				HolddataMT = dataMT;
				HolddataMP = dataMP;
				HolddataPC = dataPC;
				HolddataAP = dataAP;
				HolddataTemp = dataTemp;
				HolddataAquilude = dataAquilude;
				HolddataOil = dataOil;
				HolddataSAT = dataSAT;
				UpdateTraces('Traceplot-0-Lith', dataLith, 'Lithology Type', 'Type');
				UpdateTraces('Traceplot-1-Aqui', dataAqui, 'Aquifer Type', 'Type');
				UpdateTraces('Traceplot-2-Cond', dataCond, 'Condition Type', 'Type');
				UpdateTraces('Traceplot-3-Frac', dataFrac, 'Fractured Aquifer', 'Presences');
				UpdateTraces('Traceplot-4-Min', dataMin, 'Minimum Yield', 'l/s');
				UpdateTraces('Traceplot-5-Max', dataMax, 'Maximum Yield', 'l/s');
				UpdateTraces('Traceplot-6-Sus', dataSus, 'Sustainable Yield', 'l/s');
				UpdateTraces('Traceplot-7-PrimK', dataPrimK, 'PoreSpace Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-8-SecK', dataSecK, 'Matrix Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-9-Poro', dataPoro, 'Porosity', '%');
				UpdateTraces('Traceplot-10-SStor', dataSStor, 'Specific Storage', '1/m');
				UpdateTraces('Traceplot-11-Stor', dataStor, 'Storativity', 'Unitless');
				UpdateTraces('Traceplot-12-Diff', dataDiff, 'Porespace Diffusivity', 'm2/s');
				UpdateTraces('Traceplot-13-Clay', dataClay, 'Clay Content', '%');
				UpdateTraces('Traceplot-14-Dens', dataDens, 'Density', 'kg/m3');
				UpdateTraces('Traceplot-15-Shear', dataShear, 'Shear Modulus', 'Pa');
				UpdateTraces('Traceplot-16-Bulk', dataBulk, 'Bulk Modulus', 'Pa');
				UpdateTraces('Traceplot-17-Comp', dataComp, 'Compressibility', '1/Pa');
				UpdateTraces('Traceplot-18-Yong', dataYong, 'Youngs Modulus', 'Pa');
				UpdateTraces('Traceplot-19-WQ', dataWQ, 'Relative Water Quality', 'Rel %');
				UpdateTraces('Traceplot-20-AI', dataAI, 'Aquifer Indicator', 'Presence');
				UpdateTraces('Traceplot-21-FC', dataFC, 'Formation Fracturing', 'Count');
				UpdateTraces('Traceplot-22-SPTN', dataSPTN, 'SPTN', 'Unitless');
				UpdateTraces('Traceplot-23-SPTRQD', dataSPTRQD, 'SPTRQD', 'Unitless');
				UpdateTraces('Traceplot-24-SV', dataSV, 'Seismic P-Wave Velocity', 'm/s');
				UpdateTraces('Traceplot-25-AcouI', dataAcouI, 'Acoustic Impeadance', 'Pa s/m3');
				UpdateTraces('Traceplot-26-FR', dataFR, 'Frenzel Radius', 'm');
				UpdateTraces('Traceplot-27-TC', dataTC, 'Transmission Coefficient', 'Coeff');
				UpdateTraces('Traceplot-28-CA', dataCA, 'Critical Angle', 'Deg');
				UpdateTraces('Traceplot-29-QP', dataQP, 'Seismic Attenuation Qp', 'GPa');
				UpdateTraces('Traceplot-30-QS', dataQS, 'Seismic Attenuation Qs', 'GPa');
				UpdateTraces('Traceplot-31-Res', dataRes, 'Apparent Electric Field Strength', 'V/m');
				UpdateTraces('Traceplot-32-ET', dataET, 'Poisson Ratio', 'Ratio');
				UpdateTraces('Traceplot-33-MT', dataMagT, 'Specific Volume', 'm3/kg');
				UpdateTraces('Traceplot-34-PT', dataPT, 'Porespace Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-35-PP', dataPP, 'Porespace Permeability', 'md');
				UpdateTraces('Traceplot-36-MT', dataMT, 'Matrix Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-37-MP', dataMP, 'Matrix Permeability', 'md');
				UpdateTraces('Traceplot-38-PC', dataPC, 'Permeability Contrast', 'Ratio');
				UpdateTraces('Traceplot-39-AP', dataAP, 'Aquifer Probability', '%');
				UpdateTraces('Traceplot-40-Temp', dataTemp, 'Calculated Temperature Estimate', 'degC');
				UpdateTraces('Traceplot-41-AC', dataAquilude, 'Calculated Relative Aquiclude Probability Estimate', '%');
				UpdateTraces('Traceplot-42-OIL', dataOil, 'Calculated Hydrocarbon Potential', '%');
				UpdateTraces('Traceplot-43-SAT', dataSAT, 'Calculated Saturation', '%');
			}

			function UpdateTraces(Chart, DataSet, ChartTitle, Units)
			{
				try {
				let depths = DataSet.map(item => item.depth);
				let values = DataSet.map(item => item.value);
				let trace = {
					x: depths,
					y: values,
					type: 'scatter',
					mode: 'lines',
					orientation: 'h',
					fill: 'tozeroy',
					fillcolor: 'rgba(211,211,211,0.3)',
					line: {
						color: 'black'
					}
				};
				let layout = {
					margin: {t:25,r:5,b:5,l:5},
					title: {
						automargin: true,
						standoff: 5,
						text: '<b>' + ChartTitle + '</b>',
						
						font: {
							size: 16

						}
					},
					xaxis: {
						title: 'Depth (mbgl)',
						automargin: true,
						standoff: 5
					},
					yaxis: {
						title: Units,
						automargin: true,
						standoff: 5
					},
					width: Math.min(window.outerWidth, window.innerWidth, 1100),
					height: 140
				};
				Plotly.newPlot(Chart, [trace], layout);
				} catch (error) {}
			}

			function LogPoint(Index) {
			  var selectElement = document.getElementById("rowSelector");
			  selectElement.selectedIndex = Index;
			}

			function populateDropdown() 
			{
				var dropdown = document.getElementById("rowSelector");
				dropdown.innerHTML = "<option value='' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}

			function DC(Str) {
				try {
					return atob(Str); // atob is a built-in function to decode Base64 strings
				} catch (error) {
					return null; // Return null if decoding fails
				}
			}
			
			function selectRow() 
			{
				var dropdown = document.getElementById("rowSelector");
				var selectedIndex = dropdown.value;
				if (selectedIndex === "") 
				{
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];
				var tableBody = document.getElementById("selectedRow");
				tableBody.innerHTML = "";
				for (var i = 0; i < selectedRowData[6].length; i++) 
				{
					var newRow = document.createElement("tr");
					var rowHeight = Math.floor(Math.abs(selectedRowData[6][i][1] - selectedRowData[6][i][0])*5);
					newRow.style.height = rowHeight + "px";
					var cell = document.createElement("td");
					cell.textContent = i + 1;
					newRow.appendChild(cell);
					var cell2 = document.createElement("td");
					cell2.textContent = '';
					cell2.style.backgroundColor = LithTypeColor[selectedRowData[6][i][2]];
					newRow.appendChild(cell2);
					var cell3 = document.createElement("td");
					cell3.textContent = '';
					cell3.style.backgroundColor = AquiferTypeColor[selectedRowData[6][i][3]];
					newRow.appendChild(cell3);
					for (var x = 0; x < selectedRowData[6][i].length; x++) 
					{
						var cell = document.createElement("td");
						if (x == 2)
						{
							if (selectedRowData[6][i][x] < 11)
							{
								cell.textContent = LithType[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==3)
						{
							if (selectedRowData[6][i][x] < 18)
							{
								cell.textContent = AquiferType[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==4)
						{
							if (selectedRowData[6][i][x] < 18)
							{
								cell.textContent = FormationCondition[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==5)
						{
							if (selectedRowData[6][i][x] == 1)
							{
								cell.textContent = 'Fractured';
							}
							else
							{
								cell.textContent = '';
							}
						}
						else
						{
							if (x == 0)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 1)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 6)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 7)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 8)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 9)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 10)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 11)
							{
								cell.textContent = selectedRowData[6][i][x];//*100;
							}
							else if (x == 12)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 13)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 14)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 15)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 16)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 17)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 18)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 19)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 20)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 21)
							{
								cell.textContent = selectedRowData[6][i][x];//*100;
							}
							else if (x == 22)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 23)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 24)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 25)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 26)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 27)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 28)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 29)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 30)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 31)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 32)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 33)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 34)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 35)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 36)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 37)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 38)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 39)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 40)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 41)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 42)
							{
								cell.textContent = (selectedRowData[6][i][x] * GlobalTemperature + 10).toExponential(2);
							}
							else if (x == 43)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 44)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 45)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
						}
						newRow.appendChild(cell);
					}
					tableBody.appendChild(newRow);
				}
			}
			populateDropdown();
			
			const AAC = DC(datasets['dataset35'].ID) +
						DC(datasets['dataset36'].ID) + 
						DC(datasets['dataset37'].ID) +
						DC(datasets['dataset38'].ID) +
						DC(datasets['dataset39'].ID) +
						DC(datasets['dataset40'].ID) +
						DC(datasets['dataset41'].ID) +
						DC(datasets['dataset42'].ID);
			
			var tableHTML = '<table>';
			tableHTML += '<tr><th>Point</th><th>Rec No.</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th>Vert. Res (m)</th><th>Uncertainty (%)</th><th></th></tr>';
			BoxData.data.forEach(function(row) 
			{
				tableHTML += '<tr>';
				tableHTML += '<td>' + row[0] + '</td>';
				tableHTML += '<td>' + row[4] + '</td>';
				tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>';     // Lat
				tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>';     // Lon
				tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
				tableHTML += '<td>' + row[3][0] + '</td>';
				tableHTML += '<td>' + row[3][1] + '</td>';
				tableHTML += '<td>' + row[3][2] + '</td>';
				tableHTML += '<td>' + row[3][5] + '</td>';
				tableHTML += '<td>' + row[3][6] + '</td>';
				tableHTML += '<td>' + row[3][4] + '</td>';
				tableHTML += '<td>' + row[3][40] + '</td>';
				tableHTML += '<td>' + row[3][41] + '</td>';
				tableHTML += '</tr>';
			});
			tableHTML += '</table>';
			document.getElementById('dataTable').innerHTML = tableHTML;
			
			function refreshdataTable() {
				// Initialize the table HTML with headers
				var tableHTML = '<table>';
				tableHTML += '<tr><th>Point</th><th>Rec No.</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th>Vert. Res (m)</th><th>Uncertainty (%)</th><th></th></tr>';

				// Loop through BoxData data and populate the table rows
				BoxData.data.forEach(function(row) {
					tableHTML += '<tr>';
					tableHTML += '<td>' + row[0] + '</td>';                            // Point
					tableHTML += '<td>' + row[4] + '</td>';                            // Rec No.
					tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>';     // Lat
					tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>';     // Lon
					tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
					tableHTML += '<td>' + row[3][0] + '</td>';
					tableHTML += '<td>' + row[3][1] + '</td>';
					tableHTML += '<td>' + row[3][2] + '</td>';
					tableHTML += '<td>' + row[3][5] + '</td>';
					tableHTML += '<td>' + row[3][6] + '</td>';
					tableHTML += '<td>' + row[3][4] + '</td>';
					tableHTML += '<td>' + row[3][40] + '</td>';
					tableHTML += '<td>' + row[3][41] + '</td>';
					tableHTML += '</tr>';
					tableHTML += '</tr>';
				});

				// Close the table tag
				tableHTML += '</table>';

				// Update the DOM with the new table HTML
				document.getElementById('dataTable').innerHTML = tableHTML;
			}
			
			function generateWaypoints(map, data) {
				
				//for (var i = 0; i < GISMapmarkers.length; i++) {
				//		map.removeLayer(GISMapmarkers[i]);
				//	}
				
				//map.eachLayer(function (layer) {
				//	map.removeLayer(layer);
				//});
				
				map.eachLayer(function (layer) {
					// Check if the layer is a marker
					if (layer instanceof L.Marker) {
						map.removeLayer(layer);
					}
				});
				
				//GISMapmarkers = [];
				
				let CurrentIndex = 0;
				data.forEach(function (waypoint) {
					var IconLink = '';
					if ((waypoint[4] <= 9)  && (SiteMapShowRecomendationPoints == true)) {
						IconLink = 'http://maps.google.com/mapfiles/kml/paddle/' + waypoint[4] + '.png';
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [40, 40],
							iconAnchor: [20, 24],
							popupAnchor: [0, -24]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: false }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -20], className: 'text-label' }).openTooltip();

						
					} else {
						IconLink = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle_highlight.png';
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [20, 20],
							iconAnchor: [10, 12],
							popupAnchor: [0, -12]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: false }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -4], className: 'text-label' }).openTooltip();

						
					}
				});
			}
			
			function generateSiteMapWaypoints(map, data) {
				if (SiteMapShowRecPointsOnlychanged == true) {
					for (var i = 0; i < SiteMapmarkers.length; i++) {
						map.removeLayer(SiteMapmarkers[i]);
					}
				}
				else
				{
					for (var i = 0; i < SiteMapmarkers.length; i++) {
						map.removeLayer(SiteMapmarkers[i]);
					}
				}

				SiteMapmarkers = [];

				let CurrentIndex = 0;
				
				data.forEach(function (waypoint) {
					var tableHTML = "<table>";
					tableHTML += "<tr><th>Property</th><th>Value</th><th>Unit</th></tr>";
					tableHTML += "<tr><td>Point</td><td>" + waypoint[0] + "</td><td>no</td></tr>";
					tableHTML += "<tr><td>Recommendation</td><td>" + waypoint[4] + "</td><td>no</td></tr>";
					tableHTML += "<tr><td>Latitude</td><td>" + waypoint[1] + "</td><td>WGS84</td></tr>";
					tableHTML += "<tr><td>Longitude</td><td>" + waypoint[2] + "</td><td>WGS84</td></tr>";
					tableHTML += "<tr><td>Elevation</td><td>" + waypoint[3][10] + "</td><td>masl</td></tr>";
					tableHTML += "<tr><td>Sustainable Yield</td><td>" + waypoint[3][0] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>Minimum Yield</td><td>" + waypoint[3][1] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>Maximum Yield</td><td>" + waypoint[3][2] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>GWL</td><td>" + waypoint[3][3] + "</td><td>mbgl</td></tr>";
					tableHTML += "<tr><td>Drill Depth</td><td>" + waypoint[3][4] + "</td><td>mbgl</td></tr>";
					tableHTML += "<tr><td>Risk</td><td>" + waypoint[3][5] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>Confidence</td><td>" + waypoint[3][6] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>Correlation</td><td>" + waypoint[3][7] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>SNR</td><td>" + waypoint[3][8] + "</td><td>Ratio</td></tr>";
					tableHTML += "</table>";

					var IconLink = 'http://maps.google.com/mapfiles/kml/paddle/' + waypoint[4] + '.png';
					if ((waypoint[4] <= 9) && (SiteMapShowRecomendationPoints == true)) {
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [40, 40],
							iconAnchor: [20, 24],
							popupAnchor: [0, -24]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: true }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -20], className: 'text-label' }).openTooltip();
						marker.bindPopup(tableHTML, { maxWidth: 500 });
						marker.index = CurrentIndex;
						CurrentIndex = CurrentIndex + 1;
						SiteMapmarkers.push(marker);
					
						marker.on('dragend', function (event) {
							let marker = event.target;
							let position = marker.getLatLng();
							console.log(`Marker moved to: Lat: ${position.lat}, Lng: ${position.lng}`);
							
							document.getElementById("rowSelectorEditPoint").selectedIndex = marker.index+1;
							
							document.getElementById("LatInput").value = position.lat;
							document.getElementById("LonInput").value = position.lng;
							
							BoxData.data[marker.index][1] = parseFloat(document.getElementById("LatInput").value);
							BoxData.data[marker.index][2] = parseFloat(document.getElementById("LonInput").value);
							refreshRecTable();
							refreshdataTable();
							updateAllMaps();
							EditSectionData();
						});
					
					} else {
						if (SiteMapShowRecPointsOnly == false) {
							IconLink = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle_highlight.png';
							var customIcon = L.icon({
								iconUrl: IconLink,
								iconSize: [20, 20],
								iconAnchor: [10, 12],
								popupAnchor: [0, -12]
							});
							// Add draggable: true to enable marker dragging
							var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: true }).addTo(map);
							marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -4], className: 'text-label' }).openTooltip();
							marker.bindPopup(tableHTML, { maxWidth: 500 });
							marker.index = CurrentIndex;
							CurrentIndex = CurrentIndex + 1;
							SiteMapmarkers.push(marker);
						
							marker.on('dragend', function (event) {
								let marker = event.target;
								let position = marker.getLatLng();
								console.log(`Marker moved to: Lat: ${position.lat}, Lng: ${position.lng}`);
								
								document.getElementById("rowSelectorEditPoint").selectedIndex = marker.index+1;
								
								document.getElementById("LatInput").value = position.lat;
								document.getElementById("LonInput").value = position.lng;
								
								BoxData.data[marker.index][1] = parseFloat(document.getElementById("LatInput").value);
								BoxData.data[marker.index][2] = parseFloat(document.getElementById("LonInput").value);
								refreshRecTable();
								refreshdataTable();
								updateAllMaps();
								EditSectionData();
							});
						}
					}
				});
			}

			function updateSiteMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = BoxData.data;  
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));  
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				map1 = L.map('map1', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				SiteMapmarkersInst = map1;
				
				L.tileLayer(`https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}&key=${AAC}`, {
					maxZoom: 22,
					subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
				}).addTo(map1);
				generateSiteMapWaypoints(map1, pointData);
				L.control.scale().addTo(map1);
				
				L.Control.LatLngAxis = L.Control.extend({
					onAdd: function(map1) {
						var container = L.DomUtil.create('div');
						container.innerHTML = 'Lat: <span id="lat"></span> | Lng: <span id="lng"></span>';
						container.style.background = 'rgba(255, 255, 255, 0.7)';
						container.style.padding = '5px';
						container.style.borderRadius = '5px';
						return container;
					},

					onRemove: function(map1) {
						// Nothing to do here
					}
				});

				L.control.latLngAxis = function(opts) {
					return new L.Control.LatLngAxis(opts);
				};

				L.control.latLngAxis({ position: 'topright' }).addTo(map1);
				
				map1.on('mousemove', function(e) {
					document.getElementById('lat').textContent = e.latlng.lat.toFixed(6);
					document.getElementById('lng').textContent = e.latlng.lng.toFixed(6);
				});
				
				} catch (error) {}
			}

			function refreshSiteMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = BoxData.data;  
				generateSiteMapWaypoints(SiteMapmarkersInst, pointData);
				} catch (error) {alert('Error: ' + error);}
			}
			
			function updateAquiferMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map2) 
				{
					map2.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				//var map2 = L.map('map2', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				map2 = L.map('map2').setView([avgLat, avgLon], 13);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map2);
				generateWaypoints(map2, pointData);
				L.control.scale().addTo(map2);
				} catch (error) {}
			}
			
			function updateWaterShedMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map6) 
				{
					map6.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				//var map6 = L.map('map6', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				map6 = L.map('map6').setView([avgLat, avgLon], 13);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map6);
				generateWaypoints(map6, pointData);
				L.control.scale().addTo(map6);
				} catch (error) {}
			}
			
			function updateGWLMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map3) 
				{
					map3.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map3 = L.map('map3').setView([avgLat, avgLon], 13);
				//var map3 = L.map('map3', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map3);
				generateWaypoints(map3, pointData);
				L.control.scale().addTo(map3);
				} catch (error) {}
			}
			
			function updateFaultMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map4) 
				{
					map4.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map4 = L.map('map4').setView([avgLat, avgLon], 13);
				//var map4 = L.map('map4', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map4);
				generateWaypoints(map4, pointData);
				L.control.scale().addTo(map4);
				} catch (error) {}
			}
			
			function updateLithMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map5) 
				{
					map5.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map5 = L.map('map5').setView([avgLat, avgLon], 13);
				//var map5 = L.map('map5', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map5);
				generateWaypoints(map5, pointData);
				L.control.scale().addTo(map5);
				} catch (error) {}
			}

			function updateSalineMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map7) 
				{
					map7.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map7 = L.map('map7').setView([avgLat, avgLon], 13);
				//var map7 = L.map('map7', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map7);
				generateWaypoints(map7, pointData);
				L.control.scale().addTo(map7);
				} catch (error) {}
			}
			
			function updateGeothermalMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map8) 
				{
					map8.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map8 = L.map('map8').setView([avgLat, avgLon], 13);
				//var map8 = L.map('map8', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map8);
				generateWaypoints(map8, pointData);
				L.control.scale().addTo(map8);
				} catch (error) {}
			}
			
			
			function updateContourPlot(selectedData) {
			  try {
				ContourHoldselectedData = selectedData;

				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = ContourBoxData; // BoxData.data;
				var gridSize = 25;

				function inverseDistanceWeight(x, y, points, datasetInd) {
				  let sum = 0, wsum = 0;
				  for (let i = 0; i < points.length; i++) {
					const p = points[i];
					const d = Math.hypot(x - p[2], y - p[1]);
					if (d === 0) return Number(p[3][datasetInd]);
					const v = Number(p[3][datasetInd]);
					if (!Number.isFinite(v)) continue;
					const w = 1 / d;
					sum += v * w;
					wsum += w;
				  }
				  return wsum ? (sum / wsum) : NaN;
				}

				var minLat = Math.min.apply(null, pointData.map(function (point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function (point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function (point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function (point) { return point[2]; }));

				var interpolatedZ = [];
				for (var i = 0; i < gridSize; i++) {
				  var row = [];
				  for (var j = 0; j < gridSize; j++) {
					var lat = minLat + (i / (gridSize - 1)) * (maxLat - minLat);
					var lon = minLon + (j / (gridSize - 1)) * (maxLon - minLon);
					var elevation = inverseDistanceWeight(lon, lat, pointData, datasetIndex);
					row.push(elevation);
				  }
				  interpolatedZ.push(row);
				}

				const xs = pointData.map(p => p[2]);
				const ys = pointData.map(p => p[1]);
				const labels = pointData.map(p => String(p[0] ?? ''));
				const anyLong = labels.some(lbl => lbl.length > 3);

				// scatter trace: use text only for the "short label" case
				var scatterData = {
				  x: xs,
				  y: ys,
				  mode: anyLong ? 'markers' : 'markers+text',
				  marker: { color: 'black', size: 10 },
				  type: 'scatter',
				  text: anyLong ? undefined : labels,
				  textposition: anyLong ? undefined : 'top center',
				  textfont: { color: 'black', size: 18 }
				};

				var contourData = {
				  z: interpolatedZ,
				  type: 'contour',
				  contours: { coloring: 'heatmap' },
				  colorscale: 'Rainbow',
				  x: [],
				  y: [],
				  colorbar: { title: dataset.unit }
				};
				for (var k = 0; k < gridSize; k++) {
				  contourData.x.push(minLon + k * ((maxLon - minLon) / (gridSize - 1)));
				  contourData.y.push(minLat + k * ((maxLat - minLat) / (gridSize - 1)));
				}

				// Build annotations for rotated labels when any label is long
				let annotations = [];
				if (anyLong) {
				  annotations = xs.map((xv, i) => ({
					x: xv,
					y: ys[i],
					xref: 'x',
					yref: 'y',
					text: labels[i],
					showarrow: false,
					textangle: -45,          // rotate 45°
					xanchor: 'left',        // place to the right of the point
					yanchor: 'bottom',      // ...and above the point
					xshift: 1,              // pixel offsets from the point
					yshift: 1,
					font: { color: 'black', size: 14 }
				  }));
				}

				var layout = {
				  title: { text: '<b>' + dataset.name + '</b>', font: { size: 16 } },
				  xaxis: { title: 'Longitude' },
				  yaxis: { title: 'Latitude' },
				  width: Math.min(window.outerWidth, window.innerWidth, 1100),
				  height: Math.min(window.outerWidth - 10, window.innerWidth - 10, 1100) * 0.7,
				  annotations: annotations
				};

				SiteMapcontourData = contourData;
				SiteMapscatterData = scatterData;
				HoldSiteMaplayout = layout;

				Plotly.newPlot('plotly-contour', [contourData, scatterData], layout);
			  } catch (error) {}
			}
				
			function createMultiDimensionalArray(rows, cols) 
			{
				var multiArray = [];
				for (var i = 0; i < rows; i++) 
				{
					var innerArray = [];
					for (var j = 0; j < cols; j++) 
					{
						innerArray.push(0);
					}
					multiArray.push(innerArray);
				}
				return multiArray;
			}	
				
			function toRadians(degrees) 
			{
				return degrees * Math.PI / 180;
			}	
				
			function calculateDistance(lat1, lon1, lat2, lon2) 
			{
				const earthRadiusKm = 6371;
				const lat1Rad = toRadians(lat1);
				const lon1Rad = toRadians(lon1);
				const lat2Rad = toRadians(lat2);
				const lon2Rad = toRadians(lon2);
				const dLat = lat2Rad - lat1Rad;
				const dLon = lon2Rad - lon1Rad;
				const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				const distance = earthRadiusKm * c * 1000;
				return distance;
			}	

			function updateSectionPlot(selectedData) 
			{
				try {
				HoldselectedData = selectedData;
				if (selectedData == 'dataset44')
				{
					var DataArray = SectionBoxData;
					const wellLogs = [];
					let Totaldistance = 0.0;
					let PrevLat = DataArray[0][1];
					let PrevLon = DataArray[0][2];

					function calculateStructDistance(lat1, lon1, lat2, lon2) {
						const earthRadiusKm = 6371;
						const lat1Rad = toRadians(lat1);
						const lon1Rad = toRadians(lon1);
						const lat2Rad = toRadians(lat2);
						const lon2Rad = toRadians(lon2);
						const dLat = lat2Rad - lat1Rad;
						const dLon = lon2Rad - lon1Rad;
						const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
								  Math.cos(lat1Rad) * Math.cos(lat2Rad) *
								  Math.sin(dLon / 2) * Math.sin(dLon / 2);
						const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
						return earthRadiusKm * c * 1000; // Convert to meters
					}

					function interpolateReflectivity(wellLogs) {
						const depths = Array.from(new Set(wellLogs.flatMap(well => well.data.map(d => d.depth)))).sort((a, b) => a - b);
						const lateralPositions = Array.from(new Set(wellLogs.map(well => well.x))).sort((a, b) => a - b);

						const reflectivityGrid = depths.map(() => new Array(lateralPositions.length).fill(NaN));

						wellLogs.forEach(well => {
							well.data.forEach(point => {
								const depthIndex = depths.indexOf(point.depth);
								const lateralIndex = lateralPositions.indexOf(well.x);
								if (depthIndex !== -1 && lateralIndex !== -1) {
									reflectivityGrid[depthIndex][lateralIndex] = point.reflectivity;
								}
							});
						});

						// Directional weighting parameters with non-linear emphasis
						const depthWeight = 2;  // Depth continuity weight
						const lateralWeight = 1; // Lateral continuity weight
						const peakEmphasisFactor = 1.5; // Emphasize peaks and troughs

						// Enhanced interpolation with peak and trough emphasis and directional weighting
						for (let i = 0; i < reflectivityGrid.length; i++) {
							for (let j = 0; j < reflectivityGrid[i].length; j++) {
								if (isNaN(reflectivityGrid[i][j])) {
									let weightedSum = 0, weightTotal = 0;
									for (let di = -1; di <= 1; di++) {
										for (let dj = -1; dj <= 1; dj++) {
											// Check for valid indices and apply weighting within the 45-degree slope constraint
											if (di !== 0 || dj !== 0) { 
												const ni = i + di, nj = j + dj;
												if (ni >= 0 && ni < reflectivityGrid.length && nj >= 0 && nj < reflectivityGrid[i].length && !isNaN(reflectivityGrid[ni][nj])) {
													// Apply directional weights with non-linear emphasis on peaks and troughs
													const reflectivity = reflectivityGrid[ni][nj];
													const weight = ((di !== 0 ? depthWeight : 0) + (dj !== 0 ? lateralWeight : 0)) * Math.pow(Math.abs(reflectivity), peakEmphasisFactor);
													weightedSum += reflectivity * weight;
													weightTotal += weight;
												}
											}
										}
									}
									if (weightTotal > 0) {
										reflectivityGrid[i][j] = weightedSum / weightTotal;
									}
								}
							}
						}

						// Null data outside the well log's top and bottom elevations
						wellLogs.forEach(well => {
							let topDepth = well.data[0].depth;
							let bottomDepth = well.endDepth; // Use endDepth for the bottom boundary
							depths.forEach((depth, depthIndex) => {
								if (depth < bottomDepth || depth > topDepth) {
									const lateralIndex = lateralPositions.indexOf(well.x);
									if (lateralIndex !== -1) {
										reflectivityGrid[depthIndex][lateralIndex] = null;
									}
								}
							});
						});

						return { depths, lateralPositions, reflectivityGrid };
					}


					function toRadians(degrees) {
						return degrees * Math.PI / 180;
					}

					function displayWellLogs(wellLogs) {
						const outputDiv = document.getElementById('wellLogsOutput');
						const wellLogsJson = JSON.stringify(wellLogs, null, 2);
						const preElement = document.createElement('pre');
						preElement.textContent = wellLogsJson;
						outputDiv.innerHTML = '';
						outputDiv.appendChild(preElement);
					}

					for (let i = 0; i < DataArray.length; i++) {
						let distance = calculateStructDistance(PrevLat, PrevLon, DataArray[i][1], DataArray[i][2]);
						Totaldistance += distance;
						PrevLat = DataArray[i][1];
						PrevLon = DataArray[i][2];

						let startDepth = DataArray[i][3][10]; 
						let wellLog = [];
						let reflectivityValue = 0;
						for (let x = 0; x < DataArray[i][5]; x++) {
							let currentDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							if (x == 0)
							{
								reflectivityValue = 0;
							}
							else
							{
								reflectivityValue = (DataArray[i][6][x][27]- DataArray[i][6][x-1][27])/(DataArray[i][6][x][27]+ DataArray[i][6][x-1][27]);
							}
							 
							wellLog.push({ depth: currentDepth, reflectivity: reflectivityValue });
						}
						wellLogs.push({ PointName: DataArray[i][0], x: Totaldistance, data: wellLog, startDepth, endDepth: startDepth - DataArray[i][6][DataArray[i][6].length - 1][1] });
					}

					const { depths, lateralPositions, reflectivityGrid } = interpolateReflectivity(wellLogs);

					const topBoundaryLine = {
						x: wellLogs.map(well => well.x),
						y: wellLogs.map(well => well.data[0].depth), // Top depth of each well
						type: 'scatter',
						mode: 'lines',
						line: { color: 'black', width: 2 },
						name: 'Top Elevation Boundary',
						showlegend: false
					};

					const bottomBoundaryLine = {
						x: wellLogs.map(well => well.x),
						y: wellLogs.map(well => well.endDepth), // Bottom depth defined by endDepth
						type: 'scatter',
						mode: 'lines',
						line: { color: 'black', width: 2 },
						name: 'Bottom Elevation Boundary',
						showlegend: false
					};

					Plotly.newPlot('plotly-Sections', [
						{
							z: reflectivityGrid,
							x: lateralPositions,
							y: depths,
							type: 'heatmap',
							colorscale: 'Greys',
							zsmooth: 'best',
							reversescale: true
						},
						{
							x: wellLogs.map(well => well.x),
							y: wellLogs.map(well => well.startDepth),
							mode: 'markers+text',
							marker: { color: 'black', size: 8 },
							text: wellLogs.map(well => well.PointName),
							textposition: 'top right',
							showlegend: false
						},
						topBoundaryLine,
						bottomBoundaryLine
					], {
						title: {
							text: '<b>' + 'Seismic Reflection' + '</b>',
							font: {
								size: 16
							}
						},
						xaxis: {
							title: 'Distance (m)',
							//showgrid: false,
							range: [Math.min(...lateralPositions), Math.max(...lateralPositions)]
						},
						yaxis: {
							title: 'Depth (masl)',
							//showgrid: false
						},
						width: Math.min(window.outerWidth, window.innerWidth, 1100),
						height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7
						//margin: { t: 30, r: 30, b: 40, l: 50 },
						//paper_bgcolor: 'white',
						//plot_bgcolor: 'white',
					});

				}
				else
				{
				
				var gridSize = 100;//300;
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.SectionIndex;
				var DataArray = SectionBoxData;
				var rows1 = DataArray.length * 2 * 1000;
				var cols1 = 4;
				var TempArray = createMultiDimensionalArray(rows1, cols1);
				var rows2 = DataArray.length;
				var cols2 = 3;
				var TopArray = createMultiDimensionalArray(rows2, cols2);
				var rows3 = DataArray.length;
				var cols3 = 3;
				var BottomArray = createMultiDimensionalArray(rows3, cols3);
				var rows4 = DataArray.length * 2;
				var cols4 = 3;
				var PolyArray = createMultiDimensionalArray(rows4, cols4);
				var Count = 0;
				var PolyCount = 0;
				var distance = 0.0;
				var Totaldistance = 0.0;
				var PrevLat = DataArray[0][1];
				var PrevLon = DataArray[0][2];
				var MaxDistance = 0;
				var minLat = 10000000;
				var maxLat = -10000000;
				var minLon = 10000000;
				var maxLon = -10000000;				
				let Fracturedata = [];				
				var MaxVerticalInterpDistance = 5;				
				var ExtName = 0;
				var ExtPoint = 0;
				var ExtDepth = 0.0;
				var ExtDistance = 0.0;
				var ExtValue = 0.0;
				let ExternalLogdata = [];
				var LastPoint = 0;
				var SecondPointDetected = false;				
				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				for (var i = 0; i < DataArray.length; i++) 
				{
					var LastDepth = 0.0;
					distance = calculateDistance(PrevLat, PrevLon, DataArray[i][1], DataArray[i][2]);
					Totaldistance = Totaldistance + distance;
					
					//*************************
					//Insert External data here
					//*************************
					if (ExternalDataArray.length > 0)
					{
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							if ( ExternalDataArray[d][0] == DataArray[i][0])
							{
								ExtPoint = DataArray[i][0];
								if (d == 0)
								{
									ExtName = '';
									ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
									ExtValue = null;
									ExtDistance = null;
									LastPoint = ExtPoint;
								}
								else
								{
									if (ExtPoint == LastPoint)
									{
										if (SecondPointDetected == false)
										{
											ExtName = ExternalDataArray[d][3];
											SecondPointDetected = true;
										}
										else
										{
											ExtName = '';
										}
										ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
										ExtValue = ExternalDataArray[d][2];
										ExtDistance = Totaldistance + ExternalDataArray[d][2];
									}
									else
									{
										SecondPointDetected = false;
										ExtName = '';
										ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
										ExtValue = null;
										ExtDistance = null;
										LastPoint = ExtPoint;
									}
								}
								ExternalLogdata.push({ ExtName, ExtDepth, ExtDistance, ExtValue });
							}	
						}
					}
					//*************************
					
					if (Totaldistance < minLon) 
					{
						minLon = Totaldistance;
					}
					if (Totaldistance > maxLon)
					{
						maxLon = Totaldistance;
					}

					PrevLat = DataArray[i][1];
					PrevLon = DataArray[i][2];
					if (distance > MaxDistance)
					{
						MaxDistance = distance;
					}
					if (DataArray[i][4] > 9)
					{
						TopArray[i][0] = DataArray[i][0];
					}
					else
					{
						if (VerticalLable == 0)
						{
							TopArray[i][0] = '<b style="color:grey;">R' + DataArray[i][4] + '</b><br>' + DataArray[i][3][4] + 'm<br>' + DataArray[i][0];
						}
						else
						{
							TopArray[i][0] = DataArray[i][0];
						}
					}
					TopArray[i][1] = DataArray[i][3][10];
					TopArray[i][2] = Totaldistance;
					PolyArray[PolyCount][0] = DataArray[i][0];
					PolyArray[PolyCount][1] = DataArray[i][3][10];
					PolyArray[PolyCount][2] = Totaldistance;
					PolyCount = PolyCount + 1;
					for (var x = 0; x < DataArray[i][5]; x++) 
					{
						if (DataArray[i][3][10] - DataArray[i][6][x][1] < minLat)
						{
							minLat = DataArray[i][3][10] - DataArray[i][6][x][1];
						}
						if (DataArray[i][3][10] - DataArray[i][6][x][0] > maxLat)
						{
							maxLat = DataArray[i][3][10] - DataArray[i][6][x][0];
						}
						
						var Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
						TempArray[Count][0] = DataArray[i][0];
						TempArray[Count][1] = Midpoint;
						TempArray[Count][2] = Totaldistance;
						TempArray[Count][3] = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
						Count = Count + 1;
						LastDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
					}
					BottomArray[i][0] = DataArray[i][0];
					BottomArray[i][1] = LastDepth;
					BottomArray[i][2] = Totaldistance;
					PolyArray[PolyCount][0] = DataArray[i][0];
					PolyArray[PolyCount][1] = LastDepth;
					PolyArray[PolyCount][2] = Totaldistance;
					PolyCount = PolyCount + 1;
				
				
					//***************************************************
					//add fracture point data
					//***************************************************
					for (var x = 0; x < DataArray[i][7]; x++) 
					{
						var FracDepth = DataArray[i][3][10] - DataArray[i][8][x];
						var FracDistance = Totaldistance;
						Fracturedata.push({ FracDepth, FracDistance });
					}
					//***************************************************
				
				}

				function LoadSectionLogData() 
				{
					let SectionLogdata = [];
					var LogTotaldistance = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						Logdistance = calculateDistance(FirstLat, FirstLon, DataArray[i][1], DataArray[i][2]);
						LogTotaldistance = LogTotaldistance + Logdistance;
						FirstLat = DataArray[i][1];
						FirstLon = DataArray[i][2];
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							
							//if ((thickness/2.0 > MaxVerticalInterpDistance) && (thickness/2.0 < 20.0))
							//{
							//	MaxVerticalInterpDistance = thickness/2.0;
							//}
							
							let NumberofMidPoints = Math.trunc((thickness/MaxVerticalInterpDistance) - 0);
							let PointName = DataArray[i][0];
							let PointDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let PointDistance = LogTotaldistance;
							let PointValue = 0;
							//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							//{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							//}

							if (NumberofMidPoints > 1)
							{
								for (var z = 0; z < NumberofMidPoints; z++) 
								{
									PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + (z*MaxVerticalInterpDistance));
									//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
									//{
										PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
										SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
									//}
								}
							}
							else
							{
								PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2.0));
								//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
								//{
									PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
									SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
								//}
							}
							
							PointDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
							//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							//{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							//}
						}
					}
					return SectionLogdata;
				}
			
				function LoadOverlayLogData() 
				{
					let SectionLogdata = [];
					var LogTotaldistance = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						Logdistance = calculateDistance(FirstLat, FirstLon, DataArray[i][1], DataArray[i][2]);
						LogTotaldistance = LogTotaldistance + Logdistance;
						FirstLat = DataArray[i][1];
						FirstLon = DataArray[i][2];
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let PointName = DataArray[i][0];
							let PointDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let PointDistance = LogTotaldistance;
							let PointValue = 0;
							if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							}

							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
								{
									PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
									SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
								}
							}

							PointDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
							if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							}
						}
					}
					return SectionLogdata;
				}
				
				var pointData = TempArray;
				
				function isValidFloat(number) 
				{
				  return !isNaN(parseFloat(number)) && isFinite(number);
				}
			  
				function logadjustedInverseDistanceWeight(x, y, points, datasetInd, lateralRadius, verticalRadius) {
					var sum = 0;
					var weightsSum = 0;
					if ( (isValidFloat(x)) && (isValidFloat(y)) && (isValidFloat(lateralRadius)) && (isValidFloat(verticalRadius)))
					{
						for (var i = 0; i < points.length; i++) {
							var point = points[i];
							var lateralDistance = Math.abs(x - point.PointDistance);
							var verticalDistance = Math.abs(y - point.PointDepth);
							if ( (isValidFloat(point.PointDistance)) && (isValidFloat(point.PointDepth)) && (isValidFloat(lateralDistance)) && (isValidFloat(verticalDistance)))
							{
								if (lateralDistance <= lateralRadius && verticalDistance <= verticalRadius) {
									var d = Math.sqrt(Math.pow(lateralDistance, 2) + Math.pow(verticalDistance, 2));
									if (d === 0) return point.PointValue;
									sum += (point.PointValue / d);
									weightsSum += (1 / d);
								}
							}
						
						}
						return sum / (weightsSum);
					}
					else
					{
						return 0;
					}
				}
				
				/*function logadjustedInverseDistanceWeight(x, y, points, datasetInd, lateralRadius, verticalRadius) {
					if (!isValidFloat(x) || !isValidFloat(y) || !isValidFloat(lateralRadius) || !isValidFloat(verticalRadius)) {
						return null;
					}
					
					let sum = 0;
					let weightsSum = 0;
					let power = 2;
					
					for (let i = 0; i < points.length; i++) {
						let point = points[i];
						let lateralDistance = Math.abs(x - point.PointDistance);
						let verticalDistance = Math.abs(y - point.PointDepth);

						if (!isValidFloat(point.PointDistance) || !isValidFloat(point.PointDepth)) {
							continue;
						}

						if (lateralDistance <= lateralRadius && verticalDistance <= verticalRadius) {
							let d = Math.sqrt(Math.pow(lateralDistance, 2) + Math.pow(verticalDistance, 2));

							if (d === 0) {
								return point.PointValue;  // Exact match found, return the value directly
							}

							// Applying the power parameter to the distance
							let weight = 1 / Math.pow(d, power);
							sum += point.PointValue * weight;
							weightsSum += weight;
						}
					}

					if (weightsSum === 0) {
						return null;  // No valid points found within the radius
					}

					return sum / weightsSum;
				}*/
				
				function isNorthOfLine(pointLat, pointLng, lineCoordinates) 
				{
					var intersectCount = 0;
					for (var i = 0; i < lineCoordinates.length - 1; i++) 
					{
						var lat1 = lineCoordinates[i][1];
						var lng1 = lineCoordinates[i][2];
						var lat2 = lineCoordinates[i+1][1];
						var lng2 = lineCoordinates[i+1][2];
						if (lng1 < pointLng && lng2 >= pointLng || lng2 < pointLng && lng1 >= pointLng) 
						{
							if (lat1 + (pointLng - lng1) / (lng2 - lng1) * (lat2 - lat1) < pointLat) 
							{
								intersectCount++;
							}
						}
					}
					return intersectCount % 2 === 1;
				}

				let LogScatData = LoadSectionLogData();
				let LogOverlayData = LoadOverlayLogData();
				
				var SectionColorscalemin = Math.min(...LogScatData.map(point => point.PointValue));
				var SectionColorscalemax = Math.max(...LogScatData.map(point => point.PointValue));
				
				
				function setMaxValue(Inarray, UsermaxValue) {
					for (var i = 0; i < Inarray.length; i++) {
						// Assuming each object in the array has a property named 'PointValue'
						if (Inarray[i].PointValue > UsermaxValue) {
							Inarray[i].PointValue = UsermaxValue;
						}
					}
					return Inarray;
				}
				
				LogScatData = setMaxValue(LogScatData,SectionColorscalemax*(UserSetmaxValue/100));
				
				
				//try {
				//var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				//var maxLat = Math.max.apply(null, TopArray.map(function(point) { return point[1]; }));
				//var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				//var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				
				//} catch (error) {
                //alert(error.message + "\n\n" + error.stack);
				//}
				
				var LateralInterpolationDistance = MaxDistance*4;
				var Interscatter= [];
				var interpolatedZ = [];
				for (var i = 0; i < gridSize; i++) 
				{
					var row = [];
					for (var j = 0; j < gridSize; j++) 
					{
						var lat = minLat + (i / (gridSize - 1)) * (maxLat - minLat);
						var lon = minLon + (j / (gridSize - 1)) * (maxLon - minLon);
						
						var elevation = logadjustedInverseDistanceWeight(lon, lat, LogScatData, datasetIndex, LateralInterpolationDistance, MaxVerticalInterpDistance+1);
						if ((isNorthOfLine(lat, lon, TopArray)))
						{
							elevation = null;
						}
						if (isNorthOfLine(lat, lon, BottomArray))
						{
						
						}
						else
						{
							var linemaxLat = Math.max.apply(null, BottomArray.map(function(point) { return point[1]; }));
							if (lat < linemaxLat)
							{
								elevation = null;
							}
						}
						row.push(elevation);
						Interscatter.push({ lon, lat, elevation });
					}
					interpolatedZ.push(row);
				}

				var FracscatterData = {
					x: Fracturedata.map(function(point) { return point.FracDistance; }),
					y: Fracturedata.map(function(point) { return point.FracDepth; }),
					mode: 'markers',
					name: '',
					//coloring: 'heatmap',
					marker: {
						symbol: 'line-ew',
						color: 'white',
						size: 20,  // Adjust size to set the width of the horizontal lines
						line: {
							width: 3,  // Adjust width to set the height of the horizontal lines
							color: 'white'  // Set the color of the lines to white
						}
					},
					type: 'scatter',
					//text: Fracturedata.map(function(point) { return point.PointName; }),
					//textposition: 'top center',
					showscale: false,
					showlegend: false,
					//textfont: {
					//	  color: 'black',
					//	  size: 18
					//}
				};
				
				var scatterData = {
					x: pointData.map(function(point) { return point[2]; }),
					y: pointData.map(function(point) { return point[1]; }),
					mode: 'markers',
					name: '',
					marker: {
						color: 'black',
						size: 10
					},
					type: 'scatter',
					text: pointData.map(function(point) { return point[0]; }),
					textposition: 'top center',
					showscale: false,
					showlegend: false,
					textfont: {
						color: 'black',
						size: 18
					}
				};
				var LogscatterData = {
					x: LogOverlayData.map(function(point) { return point.PointDistance; }),
					y: LogOverlayData.map(function(point) { return point.PointDepth; }),
					mode: 'markers',
					name: '',
					coloring: 'heatmap',
					marker: {
						  symbol: 'square',
						  color: LogOverlayData.map(function(point) { return point.PointValue; }),
						  opacity: 1,
						  size: 2
					},
					type: 'scatter',
					text: LogOverlayData.map(function(point) { return point.PointName; }),
					textposition: 'top center',
					showscale: false,
					showlegend: false,
					textfont: {
						  color: 'black',
						  size: 18
					}
				};
				var ExtLogscatterData = {
					x: ExternalLogdata.map(function(point) { return point.ExtDistance; }),
					y: ExternalLogdata.map(function(point) { return point.ExtDepth; }),
					mode: 'lines+markers+text',
					name: '',
					line: {  // Add this block to set the line color to white
						color: 'white',
					  },
					coloring: 'white',
					marker: {
						  symbol: 'square',
						  color: ExternalLogdata.map(function(point) { return point.ExtValue; }),
						  opacity: 1,
						  size: 2
					},
					type: 'scatter',
					text: ExternalLogdata.map(function(point) { return point.ExtName; }),
					textposition: 'bottom right',
					showscale: false,
					showlegend: false,
					textfont: {
						  color: 'white',
						  size: 14
					}
				};
				if (VerticalLable == 0)
				{
					var ToplineData = {
						x: TopArray.map(function(TopArray) { return TopArray[2]; }),
						y: TopArray.map(function(TopArray) { return TopArray[1]; }),
						name: '',
						mode: 'lines+markers+text',
						marker: {
							color: 'black',
							size: 6
						},
						type: 'scatter',
						name: '',
						showlegend: false,
						text: TopArray.map(function(point) { return point[0]; }),
						textposition: 'top center',
						showscale: false,					
						textfont: {
							color: 'black',
							size: 14
						}
					};
				}
				else
				{
					var ToplineData = {
						x: TopArray.map(function(TopArray) { return TopArray[2]; }),
						y: TopArray.map(function(TopArray) { return TopArray[1]; }),
						name: '',
						//mode: 'lines+markers+text',
						mode: 'lines+markers',
						marker: {
							color: 'black',
							size: 6
						},
						type: 'scatter',
						name: '',
						showlegend: false
					};
				}
				var BottomlineData = {
					x: BottomArray.map(function(BottomArray) { return BottomArray[2]; }),
					y: BottomArray.map(function(BottomArray) { return BottomArray[1]; }),
					mode: 'lines',
					name: '',
					marker: {
						color: 'black',
						size: 12
					},
					type: 'scatter',
					showscale: false,
					showlegend: false,
					name: ''
				};

				if (selectedData == 'dataset1')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 11}, (_, i) => i),
							ticktext: LithType
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset2')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: AquiferTypeFull
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset3')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: FormationCondition
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset4')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 2}, (_, i) => i),
							ticktext: FormationFractureCondition
						},
						x: [],
						y: []
					};
				}
				else 
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit
						},
						x: [],
						y: []
					};
				}

				for (var i = 0; i < gridSize; i++) {
					contourData.x.push(minLon + i * ((maxLon - minLon) / (gridSize - 1)));
					contourData.y.push(minLat + i * ((maxLat - minLat) / (gridSize - 1)));
				}
				if (VerticalLable == 0)
				{
					var layout = {
						title: {
							text: '<b>' + dataset.SectionName + '</b>',
							font: {
								size: 16
							}
						},
						xaxis: {title: 'Distance (m)'},
						yaxis: {title: 'Depth (masl)'},
						width: Math.min(window.outerWidth, window.innerWidth, 1100),
						height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7
					};
				}
				else
				{					
					var annotations = TopArray.map(function(point) {
						return {
							x: point[2],
							y: point[1],
							text: point[0],
							showarrow: false,
							font: {
								size: 14,
								color: 'black',
								align: 'center'
							},
							xanchor: 'center',    // horizontally centered on the point
							yanchor: 'bottom',    // start the text box above the point
							yshift: 10,           // shift the text box 10px further up
							textangle: -90        // vertical rotated text
						};
					});
					
					var layout = {
						title: {
							text: '<b>' + dataset.SectionName + '</b>',
							font: {
								size: 16
							}
						},
						xaxis: {title: 'Distance (m)'},
						yaxis: {title: 'Depth (masl)'},
						width: Math.min(window.outerWidth, window.innerWidth, 1100),
						height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7,
						annotations: annotations
					};
				}
				HoldFracscatterData = FracscatterData;
				HoldSectioncontourData = contourData;
				HoldSectionLogscatterData = LogscatterData;
				HoldSectionExtLogscatterData = ExtLogscatterData;
				HoldSectionToplineData = ToplineData;
				HoldSectionBottomlineData = BottomlineData;
				HoldSectionlayout = layout;
				
				if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, FracscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, FracscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, FracscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, FracscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, ToplineData, BottomlineData], layout);
				}
				else
				{
					Plotly.newPlot('plotly-Sections', [contourData, ToplineData, BottomlineData], layout);
				}

				//if (SectionLogsState == 1)
				//{
				//	Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ToplineData, BottomlineData], layout);
				//}
				//else
				//{
				//	Plotly.newPlot('plotly-Sections', [contourData, FracscatterData, ToplineData, BottomlineData], layout);
				//}
				}
				} catch (error) {}
			}	
					
			function updateVolumePlot(selectedData) 
			{
				try {
				selectedDataHold = selectedData
				var VolumeLateralGridCount = 30;
				var VolumeDepthGridCount = 100;
				var SurfaceLateralGridCount = 30;
				var dataset = datasets[selectedData];
				
				HoldModelUnit = dataset.LegendUnit;
				
				var datasetIndex = dataset.SectionIndex;
				var DataArray = ModelBoxData;//BoxData.data;
				let SliceDepthArray = new Array(VolumeDepthGridCount + 1).fill(0);
				let SliceLatArray = new Array(VolumeLateralGridCount + 1).fill(0);
				let SliceLonArray = new Array(VolumeLateralGridCount + 1).fill(0);

				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				function calculateStatsDistance(Points) 
				{
					let Distance3 = 0.0;
					const RenderPointCount = Points.length;
					for (var I = 0; I < RenderPointCount; I++) 
					{
						let Distance2 = 1000000.0;
						for (var J = 0; J < RenderPointCount; J++) 
						{
							if (I != J) 
							{
								let distance = Math.sqrt(Math.pow(Math.abs(Points[I].latitude - Points[J].latitude), 2) + Math.pow(Math.abs(Points[I].longitude - Points[J].longitude), 2));
								if (distance <= Distance2) 
								{
									Distance2 = distance;
								}
							}
						}
						if (Distance2 >= Distance3) 
						{
							Distance3 = Distance2;
						}
					}
					Distance3 = Distance3 + 2.0;
					return Math.trunc(Distance3)
				}

				function adjustedInverseDistanceWeight(x, y, points, Weightpower) 
				{
					var sum = 0;
					var weightsSum = 0;
					for (var i = 0; i < points.length; i++) 
					{
						var point = points[i];
						var d = Math.sqrt(Math.pow(x - point.longitude, 2) + Math.pow(y - point.latitude, 2));
						if (d === 0) return point.depth;
						var weightFactor = 1 / Math.pow(d, Weightpower);
						sum += (point.depth * weightFactor);
						weightsSum += weightFactor;
					}
					return sum / weightsSum;
				}
				
				function DIDWInterpolation(data, gridSize, Surface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolData = [];
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, Surface, SurfaceWeightPower);
							interpolData.push({x: lon, y: lat, z: surfacevalue, value: surfacevalue});
						}
					}
					return interpolData;
				}
				
				function IDWInterpolation(data, gridSize, depthGridSize, power, TopSurface, BottomSurface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolatedData = [];
					var LatCount = 0;
					var LonCount = 0;
					var DepthCount = 0;
					power = 4;
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						SliceLatArray[LatCount] = lat;
						LatCount = LatCount + 1;
						LonCount = 0;
						DepthCount = 0;
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							SliceLonArray[LonCount] = lon;
							LonCount = LonCount + 1;
							DepthCount = 0;
							let Topsurfacevalue = adjustedInverseDistanceWeight(lon, lat, TopSurface, SurfaceWeightPower);
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, BottomSurface, SurfaceWeightPower);
							for (let dep = minDep; dep <= maxDep; dep += ((maxDep-minDep)/depthGridSize)) 
							{
								SliceDepthArray[DepthCount] = dep;
								DepthCount = DepthCount + 1;
								let numerator = 0;
								let denominator = 0;
								for (let point of data) 
								{
									let distance = Math.sqrt(Math.pow(lat - point.latitude, 2) + Math.pow(lon - point.longitude, 2) + Math.pow(dep - point.depth, 2));
									if (distance === 0) 
									{
										if (dep > Topsurfacevalue  || dep < surfacevalue)
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: null});
										}
										else
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: point.amplitude});
										}
										break;
									}
									let weight = 1 / Math.pow(distance, power);
									numerator += weight * point.amplitude;
									denominator += weight;
								}
								if (denominator !== 0) 
								{
									let interpolatedValue = numerator / denominator;
									if (dep > Topsurfacevalue  || dep < surfacevalue)
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: null});
									}
									else
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: interpolatedValue});
									}
								}
							}
						}
					}
					return interpolatedData;
				}

				function LoadBoxData()
				{
					let Volumedata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
							let latitude = (FirstLat - DataArray[i][1])*100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = Midpoint;
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0])
							
							
							let NumberofMidPoints = Math.trunc(thickness/5) 
							if (NumberofMidPoints > 0)
							{	
								for (var z = 0; z < NumberofMidPoints; z++) 
								{
									depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + (z*5));
									Volumedata.push({latitude, longitude, depth, amplitude, thickness});
								}
							}
							else
							{
								Volumedata.push({latitude, longitude, depth, amplitude, thickness});
							}
							
						
						}	
					}
					return Volumedata;
				}

				function LoadLogData() 
				{
					let Logdata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let latitude = (FirstLat - DataArray[i][1]) * 100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Logdata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								Logdata.push({ latitude, longitude, depth, amplitude });
							}
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							Logdata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Logdata;
				}
				
				function LoadTopSurfaceData()
				{
					let Topdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10];
						let name = DataArray[i][0];
						Topdata.push({latitude, longitude, depth, name});	
					}
					return Topdata;
				}
				
				function LoadBottomSurfaceData()
				{
					let Bottomdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10] - DataArray[i][6][DataArray[i][5]-1][1];
						Bottomdata.push({latitude, longitude, depth});	
					}
					return Bottomdata;
				}
				
				function LoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = SliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = SliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = SliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				let rawData = LoadBoxData();
				let logData = LoadLogData();
				let TopSurfaceData = LoadTopSurfaceData();
				let BottomSurfaceData = LoadBottomSurfaceData();
				const InterpolationDistance = calculateStatsDistance(TopSurfaceData)*4;
				let interpolatedData = IDWInterpolation(rawData, VolumeLateralGridCount, VolumeDepthGridCount, InterpolationDistance, TopSurfaceData, BottomSurfaceData, 2);
				VolData = interpolatedData;
				VolDataMax = Math.max(...interpolatedData.map(point => point.value));
				let interpolatedTopSurfaceData = DIDWInterpolation(rawData, SurfaceLateralGridCount, TopSurfaceData, 2) 
				let DepthSliceData = LoadDepthSliceData(DepthSliceCount, interpolatedData);
				let LatSliceData = LoadLatSliceData(LatSliceCount , interpolatedData);
				let lonSliceData = LoadLonSliceData(LonSliceCount , interpolatedData);
				UpdateSliceDepthArray = SliceDepthArray;
				UpdateSliceLatArray = SliceLatArray;
				UpdateSliceLonArray = SliceLonArray;

				
				var DepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: DepthSliceData.map(point => point.longitude),
					y: DepthSliceData.map(point => point.latitude),
					z: DepthSliceData.map(point => point.depth),
					intensity: DepthSliceData.map(point => point.Amplitude),
					colorbar: {

						title: 'Value'
					}
				
				};
				var LatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: LatSliceData.map(point => point.longitude),
					y: LatSliceData.map(point => point.latitude),
					z: LatSliceData.map(point => point.depth),
					intensity: LatSliceData.map(point => point.Amplitude),
					colorbar: {
						title: 'Value'
					}
				};
				var LonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: lonSliceData.map(point => point.longitude),
					y: lonSliceData.map(point => point.latitude),
					z: lonSliceData.map(point => point.depth),
					intensity: lonSliceData.map(point => point.Amplitude),
					colorbar: {
						title: 'Value'
					}
				};

				if (selectedData == 'dataset1') {
					// compute the 10 isosurface levels
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					// build 10 separate isosurface traces, first one carries the colorbar
					var data = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  data.push({
						type: 'isosurface',
						name: '',
						x:     interpolatedData.map(pt => pt.x),
						y:     interpolatedData.map(pt => pt.y),
						z:     interpolatedData.map(pt => pt.z),
						value: interpolatedData.map(pt => pt.value),

						// carve exactly one shell
						isomin:        level,
						isomax:        level,
						surface_count: 1,

						// share a common color domain so each level picks a different hue
						cmin:   isoMin,
						cmax:   isoMax,
						colorscale: 'Jet',

						// only the first trace shows the colorbar
						showscale: i === 0,
						colorbar: {
						  title: dataset.LegendUnit,
						  tickvals:  Array.from({ length: 11 }, (_, j) => j),
						  ticktext: LithType
						},

						// progressively more opaque
						opacity: (i + 1) / 10,

						// hide end‐caps for cleanliness
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}

				} else if (selectedData == 'dataset2') {
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var data = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  data.push({
						type: 'isosurface',
						name: '',
						x:     interpolatedData.map(pt => pt.x),
						y:     interpolatedData.map(pt => pt.y),
						z:     interpolatedData.map(pt => pt.z),
						value: interpolatedData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:   isoMin,
						cmax:   isoMax,
						colorscale: 'Jet',
						showscale: i === 0,
						colorbar: {
						  title: dataset.LegendUnit,
						  tickvals:  Array.from({ length: 18 }, (_, j) => j),
						  ticktext: AquiferTypeFull
						},
						opacity: (i + 1) / 10,
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}

				} else if (selectedData == 'dataset3') {
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var data = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  data.push({
						type: 'isosurface',
						name: '',
						x:     interpolatedData.map(pt => pt.x),
						y:     interpolatedData.map(pt => pt.y),
						z:     interpolatedData.map(pt => pt.z),
						value: interpolatedData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:   isoMin,
						cmax:   isoMax,
						colorscale: 'Jet',
						showscale: i === 0,
						colorbar: {
						  title: dataset.LegendUnit,
						  tickvals:  Array.from({ length: 18 }, (_, j) => j),
						  ticktext: FormationCondition
						},
						opacity: (i + 1) / 10,
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}

				} else if (selectedData == 'dataset4') {
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var data = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  data.push({
						type: 'isosurface',
						name: '',
						x:     interpolatedData.map(pt => pt.x),
						y:     interpolatedData.map(pt => pt.y),
						z:     interpolatedData.map(pt => pt.z),
						value: interpolatedData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:   isoMin,
						cmax:   isoMax,
						colorscale: 'Jet',
						showscale: i === 0,
						colorbar: {
						  title: dataset.LegendUnit,
						  tickvals:  Array.from({ length: 2 }, (_, j) => j),
						  ticktext: FormationFractureCondition
						},
						opacity: (i + 1) / 10,
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}

				} else {
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var data = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  data.push({
						type: 'isosurface',
						name: '',
						x:     interpolatedData.map(pt => pt.x),
						y:     interpolatedData.map(pt => pt.y),
						z:     interpolatedData.map(pt => pt.z),
						value: interpolatedData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:   isoMin,
						cmax:   isoMax,
						colorscale: 'Jet',
						showscale: i === 0,
						colorbar: {
						  title: dataset.LegendUnit
						},
						opacity: (i + 1) / 10,
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}

				/*var data = [{
					type: 'volume',
					name: '',
					x: interpolatedData.map(point => point.x),
					y: interpolatedData.map(point => point.y),
					z: interpolatedData.map(point => point.z),
					value: interpolatedData.map(point => point.value),
					isomin: VolDataMax * (isominValue/100),
					isomax: VolDataMax * (isomaxValue/100),
					opacity: interpolatedData.map(point => point.value)/(VolDataMax),
					opacityscale: 100,
					colorscale: 'Jet',
					colorbar: {
						title: 'Iso Value'
					}
				}];*/
				
				let rawTopdata = [{
					type: 'scatter3d',
					name: '',
					x: TopSurfaceData.map(point => point.longitude),
					y: TopSurfaceData.map(point => point.latitude),
					z: TopSurfaceData.map(point => point.depth),
					showscale: false,
					showlegend: false,
					mode: 'markers+text',
					text: TopSurfaceData.map(point => point.name),
					  textposition: 'top center',
					  textfont: {
						family:  'Arial, sans-serif',
						size: 12,
						color: 'black'
					  },
					marker: {
						size: 3,
						color: 'red',
						opacity: 1
					},
				}];
				let logscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: logData.map(point => point.longitude),
					y: logData.map(point => point.latitude),
					z: logData.map(point => point.depth),
					value: logData.map(point => point.amplitude),
					showscale: false,
					showlegend: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: logData.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 0.8
					},
				}];
				let TopEndMeshdata = [{
					opacity:0.9,
					name: '',
					type: 'mesh3d',
					name: 'Topography',
					colorscale: 'Greys',
					x: interpolatedTopSurfaceData.map(point => point.x),
					y: interpolatedTopSurfaceData.map(point => point.y),
					z: interpolatedTopSurfaceData.map(point => point.z),
					intensity: interpolatedTopSurfaceData.map(point => point.z),
					showscale: true,
					colorbar: {
						x: -0.1,
						title: 'Elev'
					}
				}];
				
				if (OrthoState == 1)
				{
					OrthoString = 'orthographic';
				}
				else
				{
					OrthoString = 'auto';
				}
				
				let layout = {
					name: '',
					title: {
						text: '<b>' + dataset.SectionName + '</b>',
						font: {
							size: 16
						}
					},
					width: Math.min(window.outerWidth, window.innerWidth, 1100),
					height: Math.min(window.outerWidth - 10, window.innerWidth - 10, 1100) * 0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {
							title: 'Longitude (m)',
							autorange: true
						},
						yaxis: {
							title: 'Latitude (m)',
							autorange: true
						},
						zaxis: {
							title: 'Depth (masl)',
							autorange: true
						},
						aspectmode: 'auto',  // Maintains aspect ratio
						camera: {
							eye: {
								x: 1.5,  // Adjusted to give a better overall view
								y: 1.5,  // Adjusted to give a better overall view
								z: 1.5   // Adjusted to give a better overall view
							},
							projection: {
								type: OrthoString
							}
						}
					},
					autosize: true  // Ensures the plot resizes automatically with the window
				};
				TopEndMeshdataHold = TopEndMeshdata;
				rawTopdataHold = rawTopdata;
				logscatterdataHold = logscatterdata;
				HoldLayout = layout;
				if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [DepthSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [LatSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [DepthSlice, LatSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [LonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [DepthSlice, LonSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [LatSlice, LonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [DepthSlice, LatSlice, LonSlice];
				}
				else 
				{
					SliceCombinedData = [DepthSlice, LatSlice, LonSlice];
				}
				if ((TopographyState == 0) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(SliceCombinedData), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(rawTopdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(logscatterdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(logscatterdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData)))), layout);
				}
				else
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData)))), layout);
				}
				} catch (error) {}
			}

			function updateProfilePlot(selectedData) 
			{
				try {
				ProfileselectedDataHold = selectedData
				var VolumeLateralGridCount = 30;
				var VolumeDepthGridCount = 100;
				var SurfaceLateralGridCount = 30;
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.SectionIndex;
				var DataArray = BoxData.data;
				var ProfileOneArray = ProfileBoxData[0];
				var ProfileTwoArray = ProfileBoxData[1];
				var ProfileThreeArray = ProfileBoxData[2];
				let SliceDepthArray = new Array(VolumeDepthGridCount + 1).fill(0);
				let SliceLatArray = new Array(VolumeLateralGridCount + 1).fill(0);
				let SliceLonArray = new Array(VolumeLateralGridCount + 1).fill(0);
				var ProfileGridLateralCount = 200;
				var ProfileGridDepthCount = 200;
				
				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				function ProfileInterpolation(points, lon, lat, dep, lateralRadius, verticalRadius) {
					if (points.length === 0) {
						return null;
					}

					let sum = 0;
					let weightsSum = 0;
					const scaleFactor = 100000;  // Apply this consistently

					for (let i = 0; i < points.length; i++) {
						let point = points[i];
						let LongitudeDistance = Math.abs(lon - point.longitude) * scaleFactor;
						let LatitudeDistance = Math.abs(lat - point.latitude) * scaleFactor;
						let depthDistance = Math.abs(dep - point.depth);

						if (LongitudeDistance <= lateralRadius && LatitudeDistance <= lateralRadius && depthDistance <= verticalRadius) {
							let distance = Math.sqrt(
								Math.pow(LatitudeDistance, 2) +
								Math.pow(LongitudeDistance, 2) +
								Math.pow(depthDistance, 2)
							);

							if (distance === 0) {
								return point.amplitude;
							}

							sum += point.amplitude * (1 / Math.pow(distance, 2));
							weightsSum += 1 / Math.pow(distance, 2);
						}
					}

					if (weightsSum === 0) {
						return null;
					}

					return sum / weightsSum;
				}
				
				function isValidFloat(number) 
				{
				  return !isNaN(parseFloat(number)) && isFinite(number);
				}
				
				function DegToRad(degrees) 
				{
					return degrees * Math.PI / 180;
				}
				
				function RadToDeg(radians) 
				{
					return radians * (180 / Math.PI);
				}
				
				function fmod(x, y) 
				{
					return x - (Math.floor(x / y) * y);
				} 
				
				function LoadProfileLogData(Profile) 
				{
					let Profiledata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < Profile.length; i++) 
					{
						for (var x = 0; x < Profile[i][5]; x++) 
						{
							let thickness = Math.abs(Profile[i][6][x][1] - Profile[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let depth = Profile[i][3][10] - Profile[i][6][x][0];
							let latitude = ((FirstLat - Profile[i][1]) * 100000);
							let longitude = (FirstLon - Profile[i][2]) * 100000;
							let amplitude = Profile[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Profiledata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = Profile[i][3][10] - (Profile[i][6][x][0] + z);
								latitude = ((FirstLat - Profile[i][1]) * 100000);
								Profiledata.push({ latitude, longitude, depth, amplitude });
							}
							depth = Profile[i][3][10] - Profile[i][6][x][1];
							latitude = ((FirstLat - Profile[i][1]) * 100000);
							Profiledata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Profiledata;
				}
				
				function LoadProfileData(Profile, InterpDistance ) 
				{
					var ProfileGridData = [];
					var Profiledata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < Profile.length; i++) 
					{
						for (var x = 0; x < Profile[i][5]; x++) 
						{
							var thickness = Math.abs(Profile[i][6][x][1] - Profile[i][6][x][0]);
							var NumberofMidPoints = Math.trunc(thickness - 1);
							var depth = Profile[i][3][10] - Profile[i][6][x][0];
							var latitude = Profile[i][1];
							var longitude = Profile[i][2];
							var amplitude = Profile[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Profiledata.push({ latitude, longitude, depth, amplitude });
							
							//for (var z = 0; z < NumberofMidPoints; z++) 
							//{
							//	depth = Profile[i][3][10] - (Profile[i][6][x][0] + z);
							//	Profiledata.push({ latitude, longitude, depth, amplitude });
							//}
							
							depth = Profile[i][3][10] - (Profile[i][6][x][0] + ((Profile[i][6][x][1] - Profile[i][6][x][0])/2.0));
							Profiledata.push({ latitude, longitude, depth, amplitude });
							
							depth = Profile[i][3][10] - Profile[i][6][x][1];
							Profiledata.push({ latitude, longitude, depth, amplitude });
						}
					}

					var AllPoints = [];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							var thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							var NumberofMidPoints = Math.trunc(thickness - 1);
							var depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							var latitude = DataArray[i][1];
							var longitude = DataArray[i][2];
							var amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							AllPoints.push({ latitude, longitude, depth, amplitude });
							
							//for (var z = 0; z < NumberofMidPoints; z++) 
							//{
							//	depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
							//	AllPoints.push({ latitude, longitude, depth, amplitude });
							//}
							
							depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2.0));
							AllPoints.push({ latitude, longitude, depth, amplitude });
							
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							AllPoints.push({ latitude, longitude, depth, amplitude });
						}
					}
					
					var minDep = Math.min(...AllPoints.map(point => point.depth));
					var maxDep = Math.max(...AllPoints.map(point => point.depth)) + CorrectChart;
					var DistancetoLastMarker = 0;
					var DistanceAddOnDifference = 0;
					var TotalDistance = 0;
					for (var k = 1; k < Profile.length; k++) 
					{
						var lat1 = Profile[k-1][1]; 
						var lon1 = Profile[k-1][2];
						var lat2 = Profile[k][1];
						var lon2 = Profile[k][2];
						var theta = lon1 - lon2;
						var Distance = Math.sin(DegToRad(lat1)) * Math.sin(DegToRad(lat2)) + Math.cos(DegToRad(lat1)) * Math.cos(DegToRad(lat2)) * Math.cos(DegToRad(theta));
						Distance = Math.acos(Distance);
						Distance = RadToDeg(Distance);
						Distance = Distance * 60 * 1.1515 * 1609.344;
						TotalDistance += Distance;
					}

					var DistanceInMeters = TotalDistance / (ProfileGridLateralCount - 1);
					var TestCount = 0;
					var Flip = 0;
					for (let k = 1; k < Profile.length; k++) 
					{
						var lat1 = Profile[k-1][1]; 
						var lon1 = Profile[k-1][2];
						var elev1 = Profile[k-1][3][10];
						var lat2 = Profile[k][1];
						var lon2 = Profile[k][2];
						var elev2 = Profile[k][3][10];
						var radlat1 = DegToRad(lat1);
						var radlon1 = DegToRad(lon1);
						var radlat2 = DegToRad(lat2);
						var radlon2 = DegToRad(lon2);
						var Bearing = Math.atan2(Math.sin(radlon2 - radlon1) * Math.cos(radlat2), (Math.cos(radlat1) * Math.sin(radlat2)) - (Math.sin(radlat1) * Math.cos(radlat2) * Math.cos(radlon2 - radlon1)));
						Bearing = RadToDeg(Bearing);
						Bearing = fmod((Bearing + 360.0), 360);
						var theta = lon1 - lon2;
						var Distance = Math.sin(DegToRad(lat1)) * Math.sin(DegToRad(lat2)) + Math.cos(DegToRad(lat1)) * Math.cos(DegToRad(lat2)) * Math.cos(DegToRad(theta));
						Distance = Math.acos(Distance);
						Distance = RadToDeg(Distance);
						Distance = Distance * 60 * 1.1515 * 1609.344;

						if (Distance + DistancetoLastMarker > DistanceInMeters) 
						{
							if (k !== 1) 
							{
								DistanceAddOnDifference = DistanceInMeters - DistancetoLastMarker;
							}

							var ElevInc = 0.0; 
							var ElevDiff = 0.0;
							var ElevUp = false;
							var ElevDown = false;
							if (elev1 < elev2)
							{
								ElevUp = true;
								ElevDiff = (elev2 - elev1);
								ElevInc = (elev2 - elev1)/(Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters));
							}
							else if (elev1 > elev2)
							{
								ElevDown = true;
								ElevDiff = elev1 - elev2;
								ElevInc = (elev1 - elev2)/(Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters));
							}
							else if (elev1 == elev2)
							{
								ElevDiff = 0.0
								ElevInc = 0.0
							}
							
							for (var I = 0; I <= Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters); I++) 
							{
								if (I === Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters)) 
								{
									DistancetoLastMarker = (Distance - DistanceAddOnDifference) - (DistanceInMeters * I);
								}

								var Dist = DistanceAddOnDifference + (DistanceInMeters * I);
								var rEarth = 6371.01;
								var epsilon = 0.000001;
								var rlat1 = DegToRad(lat1);
								var rlon1 = DegToRad(lon1);
								var rbearing = DegToRad(((-1) * Bearing) + 360);
								var rdistance = (Dist / rEarth) / 1000;
								var rlat = Math.asin(Math.sin(rlat1) * Math.cos(rdistance) + Math.cos(rlat1) * Math.sin(rdistance) * Math.cos(rbearing));
								var rlon;
								if (Math.cos(rlat) === 0 || Math.abs(Math.cos(rlat)) < epsilon) {
									rlon = rlon1;
								} else {
									var a = rlon1 - Math.asin(Math.sin(rbearing) * Math.sin(rdistance) / Math.cos(rlat)) + Math.PI;
									var b = 2 * Math.PI;
									rlon = (a - b * Math.trunc(a / b)) - Math.PI;
								}
								var lat = RadToDeg(rlat);
								var lon = RadToDeg(rlon);
								
								var DCount = 0;
								
								for (var dep = maxDep; dep >= minDep; dep -= ((maxDep-minDep)/(ProfileGridDepthCount-0))) 
								{ 
									var depth = dep;
									var latitude = ((FirstLat - lat) * 100000);
									var longitude = ((FirstLon - lon) * 100000);
									
									let groundElevation = 0.0;
									let BottomElevation = 0.0;
									
									// Find the actual ground elevation at this location from Profile
									if (ElevDown)
									{
										groundElevation = Profile[k][3][10] + (ElevDiff - (ElevInc * I));
										BottomElevation = (Profile[k][3][10] - Profile[k-1][3][39]) + (ElevDiff - (ElevInc * I));
									}
									else if (ElevUp)
									{
										groundElevation = Profile[k][3][10] - (ElevDiff - (ElevInc * I));
										BottomElevation = (Profile[k][3][10] - Profile[k-1][3][39]) - (ElevDiff - (ElevInc * I));
									}
									else
									{
										groundElevation = Profile[k][3][10];
										BottomElevation = Profile[k][3][10] - Profile[k-1][3][39];
									}

									var Amplitude = ((depth > groundElevation)||(depth < BottomElevation)) ? null : ProfileInterpolation(AllPoints, lon, lat, dep, InterpDistance, 10);
									
									if ((Amplitude == null)&&(depth <= groundElevation)&&(depth >= BottomElevation))
									{
										Amplitude = 0.0;
									}
									
									
									ProfileGridData.push({ latitude, longitude, depth, Amplitude })
									DCount = DCount + 1;
									TestCount = TestCount + 1;
								}
							}
						} 
						else 
						{
							DistancetoLastMarker = Distance + DistancetoLastMarker;
						}
					}
					return ProfileGridData;
				}

				function calculateStatsDistance(Points) 
				{
					let Distance3 = 0.0;
					const RenderPointCount = Points.length;
					for (var I = 0; I < RenderPointCount; I++) 
					{
						let Distance2 = 1000000.0;
						for (var J = 0; J < RenderPointCount; J++) 
						{
							if (I != J) 
							{
								let distance = Math.sqrt(Math.pow(Math.abs(Points[I].latitude - Points[J].latitude), 2) + Math.pow(Math.abs(Points[I].longitude - Points[J].longitude), 2));
								if (distance <= Distance2) 
								{
									Distance2 = distance;
								}
							}
						}
						if (Distance2 >= Distance3) 
						{
							Distance3 = Distance2;
						}
					}
					Distance3 = Distance3 + 2.0;
					return Math.trunc(Distance3)
				}

				function adjustedInverseDistanceWeight(x, y, points, Weightpower) 
				{
					var sum = 0;
					var weightsSum = 0;
					for (var i = 0; i < points.length; i++) 
					{
						var point = points[i];
						var d = Math.sqrt(Math.pow(x - point.longitude, 2) + Math.pow(y - point.latitude, 2));
						if (d === 0) return point.depth;
						var weightFactor = 1 / Math.pow(d, Weightpower);
						sum += (point.depth * weightFactor);
						weightsSum += weightFactor;
					}
					return sum / weightsSum;
				}
				
				function DIDWInterpolation(data, gridSize, Surface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolData = [];
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, Surface, SurfaceWeightPower);
							interpolData.push({x: lon, y: lat, z: surfacevalue, value: surfacevalue});
						}
					}
					return interpolData;
				}
				
				function IDWInterpolation(data, gridSize, depthGridSize, power, TopSurface, BottomSurface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolatedData = [];
					var LatCount = 0;
					var LonCount = 0;
					var DepthCount = 0;
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						SliceLatArray[LatCount] = lat;
						LatCount = LatCount + 1;
						LonCount = 0;
						DepthCount = 0;
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							SliceLonArray[LonCount] = lon;
							LonCount = LonCount + 1;
							DepthCount = 0;
							let Topsurfacevalue = adjustedInverseDistanceWeight(lon, lat, TopSurface, SurfaceWeightPower);
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, BottomSurface, SurfaceWeightPower);
							for (let dep = minDep; dep <= maxDep; dep += ((maxDep-minDep)/depthGridSize)) 
							{
								SliceDepthArray[DepthCount] = dep;
								DepthCount = DepthCount + 1;
								let numerator = 0;
								let denominator = 0;
								for (let point of data) 
								{
									let distance = Math.sqrt(Math.pow(lat - point.latitude, 2) + Math.pow(lon - point.longitude, 2) + Math.pow(dep - point.depth, 2));
									if (distance === 0) 
									{
										if (dep > Topsurfacevalue  || dep < surfacevalue)
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: null});
										}
										else
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: point.amplitude});
										}
										break;
									}
									let weight = 1 / Math.pow(distance, power);
									numerator += weight * point.amplitude;
									denominator += weight;
								}
								if (denominator !== 0) 
								{
									let interpolatedValue = numerator / denominator;
									if (dep > Topsurfacevalue  || dep < surfacevalue)
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: null});
									}
									else
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: interpolatedValue});
									}
								}
							}
						}
					}
					return interpolatedData;
				}

				function LoadBoxData()
				{
					let Volumedata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
							let latitude = (FirstLat - DataArray[i][1])*100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = Midpoint;
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0])
							
							Volumedata.push({latitude, longitude, depth, amplitude, thickness});
						}	
					}
					return Volumedata;
				}
				
				function LoadLogData() 
				{
					let Logdata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let latitude = (FirstLat - DataArray[i][1]) * 100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Logdata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								Logdata.push({ latitude, longitude, depth, amplitude });
							}
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							Logdata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Logdata;
				}
				
				function LoadTopSurfaceData()
				{
					let Topdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10];
						let name = DataArray[i][0];
						Topdata.push({latitude, longitude, depth, name});	
					}
					return Topdata;
				}
				
				function LoadBottomSurfaceData()
				{
					let Bottomdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10] - DataArray[i][6][DataArray[i][5]-1][1];
						Bottomdata.push({latitude, longitude, depth});	
					}
					return Bottomdata;
				}
				
				function LoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = SliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = SliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = SliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				//let rawData = LoadBoxData();
				//let logData = LoadLogData();
				let TopSurfaceData = LoadTopSurfaceData();
				//let BottomSurfaceData = LoadBottomSurfaceData();
				const InterpolationDistance = calculateStatsDistance(TopSurfaceData);
				//let interpolatedData = IDWInterpolation(rawData, VolumeLateralGridCount, VolumeDepthGridCount, InterpolationDistance, TopSurfaceData, BottomSurfaceData, 2);
				//VolData = interpolatedData;
				//VolDataMax = Math.max(...interpolatedData.map(point => point.value));
				//let interpolatedTopSurfaceData = DIDWInterpolation(rawData, SurfaceLateralGridCount, TopSurfaceData, 2) 
				//let DepthSliceData = LoadDepthSliceData(DepthSliceCount, interpolatedData);
				//let LatSliceData = LoadLatSliceData(LatSliceCount , interpolatedData);
				//let lonSliceData = LoadLonSliceData(LonSliceCount , interpolatedData);
				//UpdateSliceDepthArray = SliceDepthArray;
				//UpdateSliceLatArray = SliceLatArray;
				//UpdateSliceLonArray = SliceLonArray;

				let TestOne = LoadProfileLogData(ProfileOneArray);
				let ProfileOneSurfaceData = LoadProfileData(ProfileOneArray, InterpolationDistance);
				let ProfileTwoSurfaceData = LoadProfileData(ProfileTwoArray, InterpolationDistance);
				let ProfileThreeSurfaceData = LoadProfileData(ProfileThreeArray, InterpolationDistance);
				var Colorscalemin = Math.min(...ProfileOneSurfaceData.map(point => point.Amplitude),...ProfileTwoSurfaceData.map(point => point.Amplitude),...ProfileThreeSurfaceData.map(point => point.Amplitude));
				var Colorscalemax = Math.max(...ProfileOneSurfaceData.map(point => point.Amplitude),...ProfileTwoSurfaceData.map(point => point.Amplitude),...ProfileThreeSurfaceData.map(point => point.Amplitude));
				
				function DelaunayTriangulation(LateralCount,DepthCount)
				{
					let TriangleArray = [];
					var Trii = 0;
					var Trij = 0;
					var Trik = 0;
					var CurrentIndex = 0;
					for (var l = 0; l < LateralCount - 1; l++)
					{
						for (var v = 0; v < DepthCount - 1; v++)
						{
							Trii = CurrentIndex;
							Trij = CurrentIndex + 1;
							Trik = CurrentIndex + DepthCount;
							TriangleArray.push({ Trii, Trij, Trik });
							CurrentIndex = CurrentIndex + 1;
							Trii = CurrentIndex;
							Trij = CurrentIndex + (DepthCount - 1);
							Trik = CurrentIndex + DepthCount;
							TriangleArray.push({ Trii, Trij, Trik });
						}
						CurrentIndex = CurrentIndex + 1;
					}
					return TriangleArray;
				}
				
				let Triangle = DelaunayTriangulation(ProfileGridLateralCount-1,ProfileGridDepthCount);

				if (selectedData == 'dataset1') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					// Create new indices arrays directly from the filtered triangles
					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 11 }, (_, i) => i),
							ticktext: LithType
						}
					};
				} else if (selectedData == 'dataset2') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 18 }, (_, i) => i),
							ticktext: AquiferTypeFull
						}
					};
				} else if (selectedData == 'dataset3') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 18 }, (_, i) => i),
							ticktext: FormationCondition
						}
					};
				} else if (selectedData == 'dataset4') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 2 }, (_, i) => i),
							ticktext: FormationFractureCondition
						}
					};
				} else {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit
						}
					};
				}

				// Helper function to safely process surface data
				function processSurface(surfaceData, surfaceName) {
					let i = [];
					let j = [];
					let k = [];
					let x = [];
					let y = [];
					let z = [];
					let intensity = [];

					Triangle.forEach(triangle => {
						const inBoundsTrii = triangle.Trii >= 0 && triangle.Trii < surfaceData.length;
						const inBoundsTrij = triangle.Trij >= 0 && triangle.Trij < surfaceData.length;
						const inBoundsTrik = triangle.Trik >= 0 && triangle.Trik < surfaceData.length;

						if (!inBoundsTrii || !inBoundsTrij || !inBoundsTrik) {
							console.error(`Out-of-bounds triangle detected in ${surfaceName}: ${JSON.stringify(triangle)}`);
							return;
						}

						const pointA = surfaceData[triangle.Trii];
						const pointB = surfaceData[triangle.Trij];
						const pointC = surfaceData[triangle.Trik];

						if (!pointA || !pointB || !pointC) {
							console.error(`Undefined point detected in ${surfaceName} for triangle: ${JSON.stringify(triangle)}`);
							return;
						}

						if (pointA.Amplitude !== null && pointB.Amplitude !== null && pointC.Amplitude !== null) {
							i.push(x.length);
							j.push(x.length + 1);
							k.push(x.length + 2);

							x.push(pointA.longitude, pointB.longitude, pointC.longitude);
							y.push(pointA.latitude, pointB.latitude, pointC.latitude);
							z.push(pointA.depth, pointB.depth, pointC.depth);
							intensity.push(pointA.Amplitude, pointB.Amplitude, pointC.Amplitude);
						}
					});

					return {
						opacity: 1,
						type: 'mesh3d',
						name: surfaceName,
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: false,
						x: x,
						y: y,
						z: z,
						i: i,
						j: j,
						k: k,
						intensity: intensity
					};
				}

				// Process Profile Two Surface
				var ProfileTwoSurface = processSurface(ProfileTwoSurfaceData, 'Profile Two');

				// Process Profile Three Surface
				var ProfileThreeSurface = processSurface(ProfileThreeSurfaceData, 'Profile Three');


				var Profilelogscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: TestOne.map(point => point.longitude),
					y: TestOne.map(point => point.latitude),
					z: TestOne.map(point => point.depth),
					value: TestOne.map(point => point.amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: TestOne.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 1
					},
				}];
				var Profilescatterdata = [{
					type: 'scatter3d',
					name: '',
					x: ProfileOneSurfaceData.map(point => point.longitude),
					y: ProfileOneSurfaceData.map(point => point.latitude),
					z: ProfileOneSurfaceData.map(point => point.depth),
					value: ProfileOneSurfaceData.map(point => point.Amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 4,
						color: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorscale: 'Jet',
						opacity: 1
					},
				}];
				let rawTopdata = [{
					type: 'scatter3d',
					name: '',
					x: TopSurfaceData.map(point => point.longitude),
					y: TopSurfaceData.map(point => point.latitude),
					z: TopSurfaceData.map(point => point.depth),
					showscale: false,
					mode: 'markers+text',
					text: TopSurfaceData.map(point => point.name),
					  textposition: 'top center',
					  textfont: {
						family:  'Arial, sans-serif',
						size: 12,
						color: 'black'
					  },
					marker: {
						size: 3,
						color: 'red',
						opacity: 1
					},
				}];
				/*var DepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					x: DepthSliceData.map(point => point.longitude),
					y: DepthSliceData.map(point => point.latitude),
					z: DepthSliceData.map(point => point.depth),
					intensity: DepthSliceData.map(point => point.Amplitude)
				};
				var LatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					x: LatSliceData.map(point => point.longitude),
					y: LatSliceData.map(point => point.latitude),
					z: LatSliceData.map(point => point.depth),
					intensity: LatSliceData.map(point => point.Amplitude)
				};
				var LonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					x: lonSliceData.map(point => point.longitude),
					y: lonSliceData.map(point => point.latitude),
					z: lonSliceData.map(point => point.depth),
					intensity: lonSliceData.map(point => point.Amplitude)
				};
				let data = [{
					type: 'volume',
					name: '',
					x: interpolatedData.map(point => point.x),
					y: interpolatedData.map(point => point.y),
					z: interpolatedData.map(point => point.z),
					value: interpolatedData.map(point => point.value),
					isomin: VolDataMax * (isominValue/100),
					isomax: VolDataMax * (isomaxValue/100),
					opacity: interpolatedData.map(point => point.value)/(VolDataMax),
					opacityscale: 100,
					colorscale: 'Jet',
					colorbar: {
						title: 'Iso Value'
					}
				}];
				
				let logscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: logData.map(point => point.longitude),
					y: logData.map(point => point.latitude),
					z: logData.map(point => point.depth),
					value: logData.map(point => point.amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: logData.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 0.8
					},
				}];
				let TopEndMeshdata = [{
					opacity:0.9,
					name: '',
					type: 'mesh3d',
					name: 'Topography',
					colorscale: 'Greys',
					x: interpolatedTopSurfaceData.map(point => point.x),
					y: interpolatedTopSurfaceData.map(point => point.y),
					z: interpolatedTopSurfaceData.map(point => point.z),
					intensity: interpolatedTopSurfaceData.map(point => point.z),
					showscale: true,
					colorbar: {
						x: -0.1,
						title: 'Elev'
					}
				}];*/
				let layout = {
					name: '',
					title: {
						text: '<b>' + dataset.SectionName + '</b>',
						font: {
							size: 16
						}
					},
					width: Math.min(window.outerWidth, window.innerWidth, 1100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100) * 0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {
							title: 'Longitude (m)',
							autorange: true
						},
						yaxis: {
							title: 'Latitude (m)',
							autorange: true
						},
						zaxis: {
							title: 'Depth (masl)',
							autorange: true
						},
						aspectmode: 'auto',  // Ensures the aspect ratio is maintained so that data isn't distorted.
						camera: {
							eye: {
								x: 1.5,  // Adjusted to give a better overall view
								y: 1.5,  // Adjusted to give a better overall view
								z: 1.5   // Adjusted to give a better overall view
							}
						}
					},
					autosize: true  // Ensures the plot resizes automatically with the window
				};
				
				var ProfileSurfaceGroup = [ProfileOneSurface, ProfileTwoSurface, ProfileThreeSurface]
				
				HoldProfileSurfaceGroup = ProfileSurfaceGroup;
				HoldProfilerawTopdata = rawTopdata;
				HoldProfileLayout = layout;
				
				//Plotly.newPlot('plotly-Profile1', rawTopdata.concat(Profilelogscatterdata.concat(ProfileSurfaceGroup)), layout);
				Plotly.newPlot('plotly-Profile1', rawTopdata.concat(ProfileSurfaceGroup), layout);
				} catch (error) {}
			}

			function updatePresentationPlot()
			{
				var trace1 = {
					x: [],
					y: [],
					mode: 'lines',
					name: 'Please select View'
				};

				var data = [trace1];

				var layout = {
					name: '',
					title: {
					  text: '<b>Please Select Presentation View</b>',
					  font: {
						size: 16
					  }
					},
					width: Math.min(window.outerWidth, window.innerWidth, 1100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {title: 'Longitude (m)'},
						yaxis: {title: 'Latitude (m)'}
					}
				};

				HoldPresentationLayout = layout;
				Plotly.newPlot('plotly-presentation', data, layout);
			}
			
			document.getElementById('DepthsliceSlider').addEventListener('input', updateDepthslice);
			
			function updateDepthslice() {
			  DepthSliceCount = document.getElementById('DepthsliceSlider').value;
			  RefreshVolumePlot();
			}
			document.getElementById('LatsliceSlider').addEventListener('input', updateLatslice);
		
			function updateLatslice() {
			  LatSliceCount = document.getElementById('LatsliceSlider').value;
			  RefreshVolumePlot();
			}
			
			document.getElementById('LonsliceSlider').addEventListener('input', updateLonslice);

			function updateLonslice() {
			  LonSliceCount = document.getElementById('LonsliceSlider').value;
			  RefreshVolumePlot();
			}

			function toggleDepthSlice() {
				var checkbox = document.getElementById('show-DepthSlice-checkbox');
				if (checkbox.checked) {
					DepthSliceState = 1;
				} else {
					DepthSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLatSlice() {
				var checkbox = document.getElementById('show-LatSlice-checkbox');
				if (checkbox.checked) {
					LatSliceState = 1;
				} else {
					LatSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLonSlice() {
				var checkbox = document.getElementById('show-LonSlice-checkbox');
				if (checkbox.checked) {
					LonSliceState = 1;
				} else {
					LonSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function RefreshVolumePlot() 
			{
				function UpdateLoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = UpdateSliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function UpdateLoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = UpdateSliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function UpdateLoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = UpdateSliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				let UpdateDepthSliceData = UpdateLoadDepthSliceData(DepthSliceCount, VolData);
				let UpdateLatSliceData = UpdateLoadLatSliceData(LatSliceCount , VolData);
				let UpdatelonSliceData = UpdateLoadLonSliceData(LonSliceCount , VolData);
				var UpdateDepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdateDepthSliceData.map(point => point.longitude),
					y: UpdateDepthSliceData.map(point => point.latitude),
					z: UpdateDepthSliceData.map(point => point.depth),
					intensity: UpdateDepthSliceData.map(point => point.Amplitude)
				};
				var UpdateLatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdateLatSliceData.map(point => point.longitude),
					y: UpdateLatSliceData.map(point => point.latitude),
					z: UpdateLatSliceData.map(point => point.depth),
					intensity: UpdateLatSliceData.map(point => point.Amplitude)
				};
				var UpdateLonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdatelonSliceData.map(point => point.longitude),
					y: UpdatelonSliceData.map(point => point.latitude),
					z: UpdatelonSliceData.map(point => point.depth),
					intensity: UpdatelonSliceData.map(point => point.Amplitude)
				};

				if (selectedDataHold == 'dataset1')
				{
					// compute the 10 isosurface levels
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					// build ten separate isosurfaces, first one shows the colorbar
					var Updatedata = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  Updatedata.push({
						type: 'isosurface',
						name: '',
						x:     VolData.map(pt => pt.x),
						y:     VolData.map(pt => pt.y),
						z:     VolData.map(pt => pt.z),
						value: VolData.map(pt => pt.value),

						// carve exactly one shell
						isomin:        level,
						isomax:        level,
						surface_count: 1,

						// common color domain so each shell picks a unique hue
						cmin:       isoMin,
						cmax:       isoMax,
						colorscale: 'Jet',

						// only the first isosurface shows the bar
						showscale: i === 0,
						colorbar: {
						  title:   HoldModelUnit,
						  tickvals: Array.from({ length: 11 }, (_, j) => j),
						  ticktext: LithType
						},

						// gradually increase opacity
						opacity: (i + 1) / 10,

						// hide the caps
						caps: { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}
				else if (selectedDataHold == 'dataset2')
				{
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var Updatedata = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  Updatedata.push({
						type: 'isosurface',
						name: '',
						x:     VolData.map(pt => pt.x),
						y:     VolData.map(pt => pt.y),
						z:     VolData.map(pt => pt.z),
						value: VolData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:          isoMin,
						cmax:          isoMax,
						colorscale:    'Jet',

						showscale: i === 0,
						colorbar: {
						  title:   HoldModelUnit,
						  tickvals: Array.from({ length: 18 }, (_, j) => j),
						  ticktext: AquiferTypeFull
						},

						opacity: (i + 1) / 10,
						caps:    { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}
				else if (selectedDataHold == 'dataset3')
				{
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var Updatedata = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  Updatedata.push({
						type: 'isosurface',
						name: '',
						x:     VolData.map(pt => pt.x),
						y:     VolData.map(pt => pt.y),
						z:     VolData.map(pt => pt.z),
						value: VolData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:          isoMin,
						cmax:          isoMax,
						colorscale:    'Jet',

						showscale: i === 0,
						colorbar: {
						  title:   HoldModelUnit,
						  tickvals: Array.from({ length: 18 }, (_, j) => j),
						  ticktext: FormationCondition
						},

						opacity: (i + 1) / 10,
						caps:    { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}
				else if (selectedDataHold == 'dataset4')
				{
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var Updatedata = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  Updatedata.push({
						type: 'isosurface',
						name: '',
						x:     VolData.map(pt => pt.x),
						y:     VolData.map(pt => pt.y),
						z:     VolData.map(pt => pt.z),
						value: VolData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:          isoMin,
						cmax:          isoMax,
						colorscale:    'Jet',

						showscale: i === 0,
						colorbar: {
						  title:   HoldModelUnit,
						  tickvals: Array.from({ length: 2 }, (_, j) => j),
						  ticktext: FormationFractureCondition
						},

						opacity: (i + 1) / 10,
						caps:    { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}
				else 
				{
					const isoMin   = VolDataMax * (isominValue / 100);
					const isoMax   = VolDataMax * (isomaxValue / 100);
					const isoRange = isoMax - isoMin;

					var Updatedata = [];
					for (let i = 0; i < 10; i++) {
					  const level = isoMin + isoRange * (i / 9);
					  Updatedata.push({
						type: 'isosurface',
						name: '',
						x:     VolData.map(pt => pt.x),
						y:     VolData.map(pt => pt.y),
						z:     VolData.map(pt => pt.z),
						value: VolData.map(pt => pt.value),

						isomin:        level,
						isomax:        level,
						surface_count: 1,
						cmin:          isoMin,
						cmax:          isoMax,
						colorscale:    'Jet',

						showscale: i === 0,
						colorbar: {
						  title: HoldModelUnit
						},

						opacity: (i + 1) / 10,
						caps:    { x: { show: false }, y: { show: false }, z: { show: false } }
					  });
					}
				}
				
				/*let Updatedata = [{
					type: 'volume',
					name: '',
					x: VolData.map(point => point.x),
					y: VolData.map(point => point.y),
					z: VolData.map(point => point.z),
					value: VolData.map(point => point.value),
					isomin: VolDataMax * (isominValue/100),
					isomax: VolDataMax * (isomaxValue/100),
					opacity: VolData.map(point => point.value)/(VolDataMax),
					opacityscale: 100,
					colorscale: 'Jet',
					colorbar: {
						title: 'Iso Value'
					}
				}];*/

				if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateLatSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateLonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLonSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateLatSlice, UpdateLonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice, UpdateLonSlice];
				}
				else 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice, UpdateLonSlice];
				}
				if ((TopographyState == 0) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(UpdateSliceCombinedData), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(rawTopdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(logscatterdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData)))), HoldLayout);
				}
				else
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData)))), HoldLayout);
				}
			}
			
			document.getElementById('isomin-slider').addEventListener('input', updateIsomin);
			document.getElementById('isomax-slider').addEventListener('input', updateIsomax);
		
			function updateIsomin() {
			  isominValue = document.getElementById('isomin-slider').value;
			  document.getElementById('isomin-value').innerHTML = isominValue;
			  RefreshVolumePlot();
			}

			function updateIsomax() {
			  isomaxValue = document.getElementById('isomax-slider').value;
			  document.getElementById('isomax-value').innerHTML = isomaxValue;
			  RefreshVolumePlot();
			}

			function toggleTopography() {
				var checkbox = document.getElementById('show-topography-checkbox');
				if (checkbox.checked) {
					TopographyState = 1;
				} else {
					TopographyState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleSurveyPoints() {
				var checkbox = document.getElementById('show-survey-points-checkbox');
				if (checkbox.checked) {
					PointsState = 1;
				} else {
					PointsState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLogs() {
				var checkbox = document.getElementById('show-logs-checkbox');
				if (checkbox.checked) {
					LogState = 1;
				} else {
					LogState = 0;
				}
				RefreshVolumePlot();
			}
		
			function toggleorthographic() {
				var checkbox = document.getElementById('show-orthographic-checkbox');
				if (checkbox.checked) {
					OrthoState = 1;
				} else {
					OrthoState = 0;
				}
				//RefreshVolumePlot();
			}
			
			function togglesectionLogs() {
				var checkbox = document.getElementById('show-sectionlogs-checkbox');
				if (checkbox.checked) {
					SectionLogsState = 1;
				} else {
					SectionLogsState = 0;
				}
				RefreshSectionPlot();
			}

			function togglefracturePoints() {
				var checkbox = document.getElementById('show-Fracturepoints-checkbox');
				if (checkbox.checked) {
					FracturePointState = 1;
				} else {
					FracturePointState = 0;
				}
				RefreshSectionPlot();
			}

			function toggleExternalData() {
				var checkbox = document.getElementById('show-ExternalData-checkbox');
				if (checkbox.checked) {
					ExternalDataState = 1;
				} else {
					ExternalDataState = 0;
				}
				RefreshSectionPlot();
			}
			
			function toggleVerticalLable() {
				var checkbox = document.getElementById('show-VerticalLable-checkbox');
				if (checkbox.checked) {
					VerticalLable = 1;
				} else {
					VerticalLable = 0;
				}
				RefreshSectionPlot();
				alert('Please refresh the chart');
			}
			
			function RefreshSectionPlot() {
				if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldFracscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldFracscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldFracscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldFracscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
			}

			window.addEventListener('resize', resizeCharts);
			
			function resizeCharts() 
			{
				var MapContainer = document.getElementById('plotly-contour');
				var SectionContainer = document.getElementById('plotly-Sections');
				var VolumeContainer = document.getElementById('plotly-Model1');
				var ProfileContainer = document.getElementById('plotly-Profile1');

				UpdateTraces('Traceplot-0-Lith', HolddataLith, 'Lithology Type', 'Type');
				UpdateTraces('Traceplot-1-Aqui', HolddataAqui, 'Aquifer Type', 'Type');
				UpdateTraces('Traceplot-2-Cond', HolddataCond, 'Condition Type', 'Type');
				UpdateTraces('Traceplot-3-Frac', HolddataFrac, 'Fractured Aquifer', 'Presences');
				UpdateTraces('Traceplot-4-Min', HolddataMin, 'Minimum Yield', 'l/s');
				UpdateTraces('Traceplot-5-Max', HolddataMax, 'Maximum Yield', 'l/s');
				UpdateTraces('Traceplot-6-Sus', HolddataSus, 'Sustainable Yield', 'l/s');
				UpdateTraces('Traceplot-7-PrimK', HolddataPrimK, 'PoreSpace Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-8-SecK', HolddataSecK, 'Matrix Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-9-Poro', HolddataPoro, 'Porosity', '%');
				UpdateTraces('Traceplot-10-SStor', HolddataSStor, 'Specific Storage', '1/m');
				UpdateTraces('Traceplot-11-Stor', HolddataStor, 'Storativity', 'Unitless');
				UpdateTraces('Traceplot-12-Diff', HolddataDiff, 'Porespace Diffusivity', 'm2/s');
				UpdateTraces('Traceplot-13-Clay', HolddataClay, 'Clay Content', '%');
				UpdateTraces('Traceplot-14-Dens', HolddataDens, 'Density', 'kg/m3');
				UpdateTraces('Traceplot-15-Shear', HolddataShear, 'Shear Modulus', 'Pa');
				UpdateTraces('Traceplot-16-Bulk', HolddataBulk, 'Bulk Modulus', 'Pa');
				UpdateTraces('Traceplot-17-Comp', HolddataComp, 'Compressibility', '1/Pa');
				UpdateTraces('Traceplot-18-Yong', HolddataYong, 'Youngs Modulus', 'Pa');
				UpdateTraces('Traceplot-19-WQ', HolddataWQ, 'Relative Water Quality', 'Rel %');
				UpdateTraces('Traceplot-20-AI', HolddataAI, 'Aquifer Indicator', 'Presence');
				UpdateTraces('Traceplot-21-FC', HolddataFC, 'Formation Fracturing', 'Count');
				UpdateTraces('Traceplot-22-SPTN', HolddataSPTN, 'SPTN', 'Unitless');
				UpdateTraces('Traceplot-23-SPTRQD', HolddataSPTRQD, 'SPTRQD', 'Unitless');
				UpdateTraces('Traceplot-24-SV', HolddataSV, 'Seismic P-Wave Velocity', 'm/s');
				UpdateTraces('Traceplot-25-AcouI', HolddataAcouI, 'Acoustic Impeadance', 'Pa s/m3');
				UpdateTraces('Traceplot-26-FR', HolddataFR, 'Frenzel Radius', 'm');
				UpdateTraces('Traceplot-27-TC', HolddataTC, 'Transmittion Coefficient', 'Coeff');
				UpdateTraces('Traceplot-28-CA', HolddataCA, 'Critical Angle', 'Deg');
				UpdateTraces('Traceplot-29-QP', HolddataQP, 'Seismic Attenuation Qp', 'GPa');
				UpdateTraces('Traceplot-30-QS', HolddataQS, 'Seismic Attenuation Qs', 'GPa');
				UpdateTraces('Traceplot-31-Res', HolddataRes, 'Apparent Electric Field Strength', 'V/m');
				UpdateTraces('Traceplot-32-ET', HolddataET, 'Poisson Ratio', 'Ratio');
				UpdateTraces('Traceplot-33-MT', HolddataMagT, 'Specific Volume', 'm3/kg');
				UpdateTraces('Traceplot-34-PT', HolddataPT, 'Porespace Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-35-PP', HolddataPP, 'Porespace Permeability', 'md');
				UpdateTraces('Traceplot-36-MT', HolddataMT, 'Matrix Transmisivity', 'm2/d');
				UpdateTraces('Traceplot-37-MP', HolddataMP, 'Matrix Permeability', 'md');
				UpdateTraces('Traceplot-38-PC', HolddataPC, 'Permeability Contrast', 'Ratio');
				UpdateTraces('Traceplot-39-AP', HolddataAP, 'Aquifer Probability', '%');
				UpdateTraces('Traceplot-40-Temp', HolddataTemp, 'Calculated Temperature Estimate', 'degC');
				UpdateTraces('Traceplot-41-AC', HolddataAquilude, 'Calculated Relative Aquiclude Probability Estimate', '%');
				UpdateTraces('Traceplot-42-OIL', HolddataOil, 'Calculated Hydrocarbon Potential', '%');
				UpdateTraces('Traceplot-43-SAT', HolddataSAT, 'Calculated Saturation', '%');
				MapContainer.style.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				SectionContainer.style.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				VolumeContainer.style.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				ProfileContainer.style.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldSiteMaplayout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldSiteMaplayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				Plotly.react('plotly-contour', [SiteMapcontourData, SiteMapscatterData], HoldSiteMaplayout);
				HoldSectionlayout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldSectionlayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshSectionPlot();
				HoldLayout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshVolumePlot();
				HoldProfileLayout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldProfileLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshProfilePlot();
				HoldPresentationLayout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
				HoldPresentationLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshPresentationPlot();
			
			}

			function RefreshPresentationPlot()
			{
				Plotly.react('plotly-presentation', HoldPresentationLayout);
			}
			
			function RefreshProfilePlot()
			{
				Plotly.react('plotly-Profile1', HoldProfilerawTopdata.concat(HoldProfileSurfaceGroup), HoldProfileLayout);
			}

			const collapsibleBtn = document.querySelector('.collapsible');
			const contentDiv = document.querySelector('.desccontent');
			collapsibleBtn.addEventListener('click', function() {
			contentDiv.classList.toggle('active');
				if (contentDiv.classList.contains('active')) 
				{
					contentDiv.style.display = 'block';
				} 
				else 
				{
					contentDiv.style.display = 'none';
				}
			});

			function playAudioSurveySiteMap() {
			  var audio = document.getElementById("audioPlayerSurveySiteMap");
			  audio.play();
			}
			
			function playAudioRecommendations() {
			  var audio = document.getElementById("audioPlayerRecommendations");
			  audio.play();
			}
			
			function playAudioSurveyPoints() {
			  var audio = document.getElementById("audioPlayerSurveyPoints");
			  audio.play();
			}
			
			function playAudioViewDataSetDescriptions() {
			  var audio = document.getElementById("audioPlayerViewDataSetDescriptions");
			  audio.play();
			}
			
			function playAudioAquiferClassification() {
			  var audio = document.getElementById("audioPlayerAquiferClassification");
			  audio.play();
			}
			
			function playAudioWaterSheds() {
			  var audio = document.getElementById("audioPlayerWaterSheds");
			  audio.play();
			}
			
			function playAudioLithology() {
			  var audio = document.getElementById("audioPlayerLithology");
			  audio.play();
			}
			
			function playAudioGroundwaterLevel() {
			  var audio = document.getElementById("audioPlayerGroundwaterLevel");
			  audio.play();
			}
			
			function playAudioFaulting() {
			  var audio = document.getElementById("audioPlayerFaulting");
			  audio.play();
			}
			
			function playAudioSalineAquifers() {
			  var audio = document.getElementById("audioPlayerSalineAquifers");
			  audio.play();
			}
			
			function playAudioGeothermal() {
			  var audio = document.getElementById("audioPlayerGeothermal");
			  audio.play();
			}
			
			function playAudioSiteParameterMaps() {
			  var audio = document.getElementById("audioPlayerSiteParameterMaps");
			  audio.play();
			}
			
			function playAudioSiteSectionLine() {
			  var audio = document.getElementById("audioPlayerSiteSectionLine");
			  audio.play();
			}
			
			function playAudioSectionSettings() {
			  var audio = document.getElementById("audioPlayerSectionSettings");
			  audio.play();
			}
			
			function playAudioSelectSectionPoints() {
			  var audio = document.getElementById("audioPlayerSelectSectionPoints");
			  audio.play();
			}
			
			function playAudioSiteModels() {
			  var audio = document.getElementById("audioPlayerSiteModels");
			  audio.play();
			}
			
			function playAudioModelSettings() {
			  var audio = document.getElementById("audioPlayerModelSettings");
			  audio.play();
			}
			
			function playAudioSliceSettings() {
			  var audio = document.getElementById("audioPlayerSliceSettings");
			  audio.play();
			}
			
			function playAudioPointDataTraces() {
			  var audio = document.getElementById("audioPlayerPointDataTraces");
			  audio.play();
			}
			
			function playAudioPointVirtualLogs() {
			  var audio = document.getElementById("audioPlayerPointVirtualLogs");
			  audio.play();
			}

			function playAudioSelectModelPoints() {
			  var audio = document.getElementById("audioPlayerSelectModelPoints");
			  audio.play();
			}

			function playSiteMapSettings() {
			  var audio = document.getElementById("audioPlayerSiteMapSettings");
			  audio.play();
			}
						
			function playReportDataElevationSettings() {
			  var audio = document.getElementById("audioPlayerReportDataElevationSettings");
			  audio.play();
			}
						
			function playViewGISDataMaps() {
			  var audio = document.getElementById("audioPlayerViewGISDataMaps");
			  audio.play();
			}
						
			function playCreateSiteParameterMapViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteParameterMapViews");
			  audio.play();
			}
						
			function playCreatePresentationViews() {
			  var audio = document.getElementById("audioPlayerCreatePresentationViews");
			  audio.play();
			}
						
			function playCreateSiteSectionLineViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteSectionLineViews");
			  audio.play();
			}
						
			function playSectionAmplitudeSettings() {
			  var audio = document.getElementById("audioPlayerSectionAmplitudeSettings");
			  audio.play();
			}
						
			function playCreateSiteProfileViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteProfileViews");
			  audio.play();
			}
						
			function playCreateSiteModelViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteModelViews");
			  audio.play();
			}
						
			function playViewControls() {
			  var audio = document.getElementById("audioPlayerViewControls");
			  audio.play();
			}
						
			function playPresentationViews() {
			  var audio = document.getElementById("audioPlayerPresentationViews");
			  audio.play();
			}

			function toggleProfileOneForm() {
				var form = document.getElementById("profileFormOne");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleProfileTwoForm() {
				var form = document.getElementById("profileFormTwo");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleProfileThreeForm() {
				var form = document.getElementById("profileFormThree");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}

			function toggleModelForm() {
				var form = document.getElementById("ModelcheckboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleSectionForm() {
				var form = document.getElementById("checkboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleContourForm() {
				var form = document.getElementById("ContourcheckboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function startAnimation() {
				animationInterval = setInterval(function() {
					rotate('scene', Math.PI / 180);
				}, 50);
			}

			function stopAnimation() {
				clearInterval(animationInterval);
			}

			function rotate(id, angle) {
				var eye0 = gd.layout[id].camera.eye;
				var rtz = xyz2rtz(eye0);
				rtz.t += angle;
	  
				var eye1 = rtz2xyz(rtz);
				Plotly.relayout(gd, id + '.camera.eye', eye1);
			}

			function xyz2rtz(xyz) {
				return {
					r: Math.sqrt(xyz.x * xyz.x + xyz.y * xyz.y),
					t: Math.atan2(xyz.y, xyz.x),
					z: xyz.z
				};
			}

			function rtz2xyz(rtz) {
				return {
					x: rtz.r * Math.cos(rtz.t),
					y: rtz.r * Math.sin(rtz.t),
					z: rtz.z
				};
			}

			animationButton.addEventListener('click', function() {
				if (!isAnimating) {
					startAnimation();
					animationButton.textContent = 'Stop Model Rotation';
				} else {
					stopAnimation();
					animationButton.textContent = 'Start Model Rotation';
				}
				isAnimating = !isAnimating;
			});
			
			function ProfstartAnimation() {
				ProfanimationInterval = setInterval(function() {
					Profrotate('scene', Math.PI / 180);
				}, 50);
			}

			function ProfstopAnimation() {
				clearInterval(ProfanimationInterval);
			}

			function Profrotate(id, angle) {
				var eye0 = Profgd.layout[id].camera.eye;
				var rtz = Profxyz2rtz(eye0);
				rtz.t += angle;
	  
				var eye1 = Profrtz2xyz(rtz);
				Plotly.relayout(Profgd, id + '.camera.eye', eye1);
			}

			function Profxyz2rtz(xyz) {
				return {
					r: Math.sqrt(xyz.x * xyz.x + xyz.y * xyz.y),
					t: Math.atan2(xyz.y, xyz.x),
					z: xyz.z
				};
			}

			function Profrtz2xyz(rtz) {
				return {
					x: rtz.r * Math.cos(rtz.t),
					y: rtz.r * Math.sin(rtz.t),
					z: rtz.z
				};
			}

			ProfanimationButton.addEventListener('click', function() {
				if (!ProfisAnimating) {
					ProfstartAnimation();
					ProfanimationButton.textContent = 'Stop Profile Rotation';
				} else {
					ProfstopAnimation();
					ProfanimationButton.textContent = 'Start Profile Rotation';
				}
				ProfisAnimating = !ProfisAnimating;
			});
			
			function toggleSiteMapRecPoints() {
				var checkBox = document.getElementById("RecPoints-checkbox");
				if (checkBox.checked) {
					SiteMapShowRecPointsOnly = true;
					SiteMapShowRecPointsOnlychanged = true;
					refreshSiteMap('dataset1');
					
				} else {
					SiteMapShowRecPointsOnly = false;
					SiteMapShowRecPointsOnlychanged = true;
					refreshSiteMap('dataset1');
					
				}
			}

			document.getElementById('Sectionmax-value').textContent = document.getElementById('range-slider').value;

			function updateMaxValue() {
			  var maxValue = parseInt(document.getElementById('range-slider').value);
			  UserSetmaxValue = maxValue;
			  updateSectionPlot(HoldselectedData);
			  document.getElementById('Sectionmax-value').textContent = maxValue;
			}

			document.getElementById('range-slider').addEventListener('input', updateMaxValue);

			function downloadStaticMap1() {
				leafletImage(map1, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Site map.png';
					link.click();
				});
			}

			function downloadStaticMap2() {
				leafletImage(map2, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Aquifer map.png';
					link.click();
				});
			}
			
			function downloadStaticMap3() {
				leafletImage(map3, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Groundwater level map.png';
					link.click();
				});
			}
			
			function downloadStaticMap4() {
				leafletImage(map4, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Faulting map.png';
					link.click();
				});
			}
			
			function downloadStaticMap5() {
				leafletImage(map5, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Lithology map.png';
					link.click();
				});
			}
			
			function downloadStaticMap6() {
				leafletImage(map6, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Water shed map.png';
					link.click();
				});
			}
			
			function downloadStaticMap7() {
				leafletImage(map7, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Saline aquifer map.png';
					link.click();
				});
			}
			
			function downloadStaticMap8() {
				leafletImage(map8, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString })
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Geothermal map.png';
					link.click();
				});
			}

			document.getElementById('download-btn1').addEventListener('click', downloadStaticMap1);
			document.getElementById('download-btn2').addEventListener('click', downloadStaticMap2);
			document.getElementById('download-btn3').addEventListener('click', downloadStaticMap3);
			document.getElementById('download-btn4').addEventListener('click', downloadStaticMap4);
			document.getElementById('download-btn5').addEventListener('click', downloadStaticMap5);
			document.getElementById('download-btn6').addEventListener('click', downloadStaticMap6);
			document.getElementById('download-btn7').addEventListener('click', downloadStaticMap7);
			document.getElementById('download-btn8').addEventListener('click', downloadStaticMap8);

			function savePlot1() {
				const plotDiv = document.getElementById('plotly-contour');
				const selectedIndex = document.getElementById('viewSelector1').value;
				const description = document.getElementById('description1').value;
				plotDataStorage1[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot1() {
				const selectedIndex = document.getElementById('viewSelector1').value;
				const plotData = plotDataStorage1[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-contour', plotData.data, plotData.layout);
					document.getElementById('description1').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile1() {
				const blob = new Blob([JSON.stringify(plotDataStorage1)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteParameterMapViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile1(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage1.splice(0, plotDataStorage1.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription1() {
				const selectedIndex = document.getElementById('viewSelector1').value;
				const plotData = plotDataStorage1[selectedIndex];
				document.getElementById('description1').value = plotData.description;
			}

			function prevView1() {
				const viewSelector = document.getElementById('viewSelector1');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription1();
					loadPlot1();
				}
			}

			function nextView1() {
				const viewSelector = document.getElementById('viewSelector1');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription1();
					loadPlot1();
				}
			}

			function savePlot2() {
				const plotDiv = document.getElementById('plotly-Sections');
				const selectedIndex = document.getElementById('viewSelector2').value;
				const description = document.getElementById('description2').value;
				plotDataStorage2[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot2() {
				const selectedIndex = document.getElementById('viewSelector2').value;
				const plotData = plotDataStorage2[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Sections', plotData.data, plotData.layout);
					document.getElementById('description2').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile2() {
				const blob = new Blob([JSON.stringify(plotDataStorage2)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteSectionLineViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile2(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage2.splice(0, plotDataStorage2.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription2();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription2() {
				const selectedIndex = document.getElementById('viewSelector2').value;
				const plotData = plotDataStorage2[selectedIndex];
				document.getElementById('description2').value = plotData.description;
			}

			function prevView2() {
				const viewSelector = document.getElementById('viewSelector2');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription2();
					loadPlot2();
				}
			}

			function nextView2() {
				const viewSelector = document.getElementById('viewSelector2');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription2();
					loadPlot2();
				}
			}

			function savePlot3() {
				const plotDiv = document.getElementById('plotly-Profile1');
				const selectedIndex = document.getElementById('viewSelector3').value;
				const description = document.getElementById('description3').value;
				plotDataStorage3[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot3() {
				const selectedIndex = document.getElementById('viewSelector3').value;
				const plotData = plotDataStorage3[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Profile1', plotData.data, plotData.layout);
					document.getElementById('description3').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile3() {
				const blob = new Blob([JSON.stringify(plotDataStorage3)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteProfileViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile3(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage3.splice(0, plotDataStorage3.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription3();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription3() {
				const selectedIndex = document.getElementById('viewSelector3').value;
				const plotData = plotDataStorage3[selectedIndex];
				document.getElementById('description3').value = plotData.description;
			}

			function prevView3() {
				const viewSelector = document.getElementById('viewSelector3');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription3();
					loadPlot3();
				}
			}

			function nextView3() {
				const viewSelector = document.getElementById('viewSelector3');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription3();
					loadPlot3();
				}
			}

			function savePlot4() {
				const plotDiv = document.getElementById('plotly-Model1');
				const selectedIndex = document.getElementById('viewSelector4').value;
				const description = document.getElementById('description4').value;
				plotDataStorage4[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot4() {
				const selectedIndex = document.getElementById('viewSelector4').value;
				const plotData = plotDataStorage4[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					
					Plotly.react('plotly-Model1', plotData.data, plotData.layout);
					document.getElementById('description4').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile4() {
				const blob = new Blob([JSON.stringify(plotDataStorage4)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteModelViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile4(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage4.splice(0, plotDataStorage4.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription4();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription4() {
				const selectedIndex = document.getElementById('viewSelector4').value;
				const plotData = plotDataStorage4[selectedIndex];
				document.getElementById('description4').value = plotData.description;
			}

			function prevView4() {
				const viewSelector = document.getElementById('viewSelector4');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription4();
					loadPlot4();
				}
			}

			function nextView4() {
				const viewSelector = document.getElementById('viewSelector4');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription4();
					loadPlot4();
				}
			}

			function savePlot5() {
				const plotDiv = document.getElementById('plotly-contour');
				const selectedIndex = document.getElementById('viewSelector5').value;
				const description = document.getElementById('description5').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot5() {
				const selectedIndex = document.getElementById('viewSelector5').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-contour', plotData.data, plotData.layout);
					document.getElementById('description5').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile5() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile5(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription5();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription5() {
				const selectedIndex = document.getElementById('viewSelector5').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description5').value = plotData.description;
			}

			function prevView5() {
				const viewSelector = document.getElementById('viewSelector5');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription5();
					loadPlot5();
				}
			}

			function nextView5() {
				const viewSelector = document.getElementById('viewSelector5');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription5();
					loadPlot5();
				}
			}

			function savePlot6() {
				const plotDiv = document.getElementById('plotly-Sections');
				const selectedIndex = document.getElementById('viewSelector6').value;
				const description = document.getElementById('description6').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot6() {
				const selectedIndex = document.getElementById('viewSelector6').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Sections', plotData.data, plotData.layout);
					document.getElementById('description6').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile6() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile6(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription6();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription6() {
				const selectedIndex = document.getElementById('viewSelector6').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description6').value = plotData.description;
			}

			function prevView6() {
				const viewSelector = document.getElementById('viewSelector6');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription6();
					loadPlot6();
				}
			}

			function nextView6() {
				const viewSelector = document.getElementById('viewSelector6');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription6();
					loadPlot6();
				}
			}

			function savePlot7() {
				const plotDiv = document.getElementById('plotly-Profile1');
				const selectedIndex = document.getElementById('viewSelector7').value;
				const description = document.getElementById('description7').value;
				
				const snapshotLayout = JSON.parse(JSON.stringify(plotDiv.layout));
				
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: snapshotLayout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot7() {
				const selectedIndex = document.getElementById('viewSelector7').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					
					Plotly.react('plotly-Profile1', plotData.data, plotData.layout);
					document.getElementById('description7').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile7() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile7(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription7();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription7() {
				const selectedIndex = document.getElementById('viewSelector7').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description7').value = plotData.description;
			}

			function prevView7() {
				const viewSelector = document.getElementById('viewSelector7');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription7();
					loadPlot7();
				}
			}

			function nextView7() {
				const viewSelector = document.getElementById('viewSelector7');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription7();
					loadPlot7();
				}
			}

			function savePlot8() {
			  const plotDiv = document.getElementById('plotly-Model1');
			  const selectedIndex = document.getElementById('viewSelector8').value;
			  const description = document.getElementById('description8').value;

			  const snapshotLayout = JSON.parse(JSON.stringify(plotDiv.layout));

			  plotDataStorage5[selectedIndex] = {
				data:        plotDiv.data,
				layout:      snapshotLayout,
				description: description
			  };

			  alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot8() {
				const selectedIndex = document.getElementById('viewSelector8').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth, window.innerWidth, 1100);
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Model1', plotData.data, plotData.layout);
					document.getElementById('description8').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile8() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile8(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription8();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription8() {
				const selectedIndex = document.getElementById('viewSelector8').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description8').value = plotData.description;
			}

			function prevView8() {
				const viewSelector = document.getElementById('viewSelector8');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription8();
					loadPlot8();
				}
			}

			function nextView8() {
				const viewSelector = document.getElementById('viewSelector8');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription8();
					loadPlot8();
				}
			}

			function savePlot9() {
				const plotDiv = document.getElementById('plotly-presentation');
				const selectedIndex = document.getElementById('viewSelector9').value;
				const description = document.getElementById('description9').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot9() {
			  const selectedIndex = document.getElementById('viewSelector9').value;
			  const plotData = plotDataStorage5[selectedIndex];

			  if (plotData && plotData.data && plotData.layout) {
				plotData.layout.width  = Math.min(window.outerWidth, window.innerWidth, 1100);
				plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100) * 0.7;

				Plotly.react(
				  'plotly-presentation',
				  plotData.data,
				  plotData.layout
				);

				document.getElementById('description9').value = plotData.description;
			  }
			  else {
				alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
			  }
			}

			function saveAllPlotsToFile9() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile9(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription9();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription9() {
				const selectedIndex = document.getElementById('viewSelector9').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description9').value = plotData.description;
			}

			function prevView9() {
				const viewSelector = document.getElementById('viewSelector9');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription9();
					loadPlot9();
				}
			}

			function nextView9() {
				const viewSelector = document.getElementById('viewSelector9');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription9();
					loadPlot9();
				}
			}

			function combineArrays() {
				return [
					plotDataStorage1,
					plotDataStorage2,
					plotDataStorage3,
					plotDataStorage4,
					plotDataStorage5
				];
			}

			function saveAllDataToFile() {
				const combinedData = combineArrays();
				const blob = new Blob([JSON.stringify(combinedData)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'GeoVueViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadAllDataFromFile(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						if (loadedData.length === 5) {
							plotDataStorage1.splice(0, plotDataStorage1.length, ...loadedData[0]);
							plotDataStorage2.splice(0, plotDataStorage2.length, ...loadedData[1]);
							plotDataStorage3.splice(0, plotDataStorage3.length, ...loadedData[2]);
							plotDataStorage4.splice(0, plotDataStorage4.length, ...loadedData[3]);
							plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData[4]);
							alert('Data successfully loaded from file');
						} else {
							alert('Invalid data format in file');
						}
					};
					reader.readAsText(file);
				}
			}

			function exportTableToExcel(tableID, filename = ''){
				var table = document.getElementById(tableID);
				var worksheet = XLSX.utils.table_to_sheet(table);
				var workbook = XLSX.utils.book_new();
				XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
				XLSX.writeFile(workbook, filename ? filename + '.xlsx' : 'exported_data.xlsx');
			}

			function toggleZero()
			{
				var checkBox = document.getElementById("ZeroElevation-checkbox");
				var checkBox2 = document.getElementById("SRTMElevation-checkbox");

				if (checkBox2.checked)
				{
					checkBox2.checked = false;
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxData.data[i][3][10] = BoxElevationArray[i];
					}
				}
								
				if (checkBox.checked) 
				{
					BoxElevationArray = [];
					let elevationList = "Zero Elevations Applied:\n";
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxElevationArray.push(BoxData.data[i][3][10]);
						BoxData.data[i][3][10] = 0;
						elevationList += `Location ${i + 1}: ${0} meters\n`;
					}
					elevationList += "Please Refresh the Report Charts";
					alert(elevationList);
				} 
				else 
				{
					let elevationList = "GPS Elevations Restored:\n";
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxData.data[i][3][10] = BoxElevationArray[i];
						elevationList += `Location ${i + 1}: ${BoxElevationArray[i]} meters\n`;
					}
					elevationList += "Please Refresh the Report Charts";
					alert(elevationList);
				}
				refreshRecTable();
				refreshdataTable();
			}
			
			async function toggleSRTM() {
				const checkBox = document.getElementById("SRTMElevation-checkbox");
				const checkBox2 = document.getElementById("ZeroElevation-checkbox");
				const locations = [];

				// Function to load Google Maps API dynamically
				function loadGoogleMapsApi(callback) {
					if (typeof google !== 'undefined' && google.maps) {
						// Google Maps API is already loaded
						callback();
					} else {
						// Create a script element to load Google Maps API
						const script = document.createElement('script');
						script.src = `https://maps.googleapis.com/maps/api/js?key=${AAC}`;
						script.async = true;
						script.defer = true;
						script.onload = callback; // Execute the callback after the script is loaded
						document.head.appendChild(script);
					}
				}

				// Function to handle elevation data once Google Maps API is loaded
				function handleElevation() {
					if (checkBox2.checked) {
						checkBox2.checked = false;
						for (let i = 0; i < BoxData.data.length; i++) {
							BoxData.data[i][3][10] = BoxElevationArray[i];
						}
					}

					if (checkBox.checked) {
						if (SRTMLoaded == 0) {
							for (let i = 0; i < BoxData.data.length; i++) {
								locations.push(new google.maps.LatLng(BoxData.data[i][1], BoxData.data[i][2]));
								BoxElevationArray.push(BoxData.data[i][3][10]);
							}

							const elevator = new google.maps.ElevationService();
							const positionalRequest = {
								locations: locations
							};

							elevator.getElevationForLocations(positionalRequest, function(results, status) {
								if (status === 'OK') {
									if (results.length === BoxData.data.length) {
										SRTMelevations = results.map(result => result.elevation);

										let elevationList = "SRTM Elevations Applied:\n";
										for (let i = 0; i < SRTMelevations.length; i++) {
											BoxData.data[i][3][10] = SRTMelevations[i];
											elevationList += `Location ${i + 1}: ${SRTMelevations[i]} meters\n`;
										}
										SRTMLoaded = 1;
										elevationList += "Please Refresh the Report Charts";
										alert(elevationList);
									} else {
										alert('There was an error collecting the elevation data 2');
									}
								} else {
									alert('Elevation service failed due to: ' + status);
								}
							});
						} else {
							let elevationList = "SRTM Elevations Applied:\n";
							for (let i = 0; i < SRTMelevations.length; i++) {
								BoxData.data[i][3][10] = SRTMelevations[i];
								elevationList += `Location ${i + 1}: ${SRTMelevations[i]} meters\n`;
							}
							elevationList += "Please Refresh the Report Charts";
							alert(elevationList);
						}
					} else {
						let elevationList = "GPS Elevations Restored:\n";
						for (let i = 0; i < BoxData.data.length; i++) {
							BoxData.data[i][3][10] = BoxElevationArray[i];
							elevationList += `Location ${i + 1}: ${BoxElevationArray[i]} meters\n`;
						}
						elevationList += "Please Refresh the Report Charts";
						alert(elevationList);
					}
				}

				// Load Google Maps API and then handle elevation
				loadGoogleMapsApi(handleElevation);
				refreshRecTable();
				refreshdataTable();
			}
						
			const collapsibleBtn2 = document.querySelector('.GIScollapsible');
			const contentDiv2 = document.querySelector('.GIScontent');
			collapsibleBtn2.addEventListener('click', function() {
			contentDiv2.classList.toggle('active');
				if (contentDiv2.classList.contains('active')) 
				{
					contentDiv2.style.display = 'block';
				} 
				else 
				{
					contentDiv2.style.display = 'none';
				}
			});
			
			function updateTemperature() {
				const input = document.getElementById('temperatureInput').value;
				const temp = parseFloat(input);

				if (isNaN(temp)) {
					alert('Please enter a valid number');
					document.getElementById('temperatureInput').value = GlobalTemperature;
					return;
				}

				GlobalTemperature = temp;
			}
			
			function AutoCalibrateTemperature() {
				var DataArray = BoxData.data;
				var MaxDepth = 0.0;
				var Gradient = 0.025;
				var ThermalMax = 0.0;
				for (var i = 0; i < DataArray.length; i++) 
				{
					if (DataArray[i][3][39] > MaxDepth)
					{
						MaxDepth = DataArray[i][3][39];
					}
				}				
				ThermalMax = MaxDepth * Gradient;
				document.getElementById('temperatureInput').value = ThermalMax;
				GlobalTemperature = ThermalMax;
			}
			
			// Add event listener to the checkbox
			document.getElementById('correct-chart-checkbox').addEventListener('change', handleCorrectCheckboxChange);
			// Function to handle checkbox change
			function handleCorrectCheckboxChange(event) {
				if (event.target.checked) 
				{
					CorrectChart = 3;  // Update the global variable to 3 when checked
				} 
				else 
				{
					CorrectChart = 0;  // Reset to 0 when unchecked
				}
				updateProfilePlot(ProfileselectedDataHold);
			}
			
			const LimitscollapsibleBtn2 = document.querySelector('.Limitscollapsible');
			const LimitscontentDiv2 = document.querySelector('.Limitscontent');
			LimitscollapsibleBtn2.addEventListener('click', function() {
			LimitscontentDiv2.classList.toggle('active');
				if (LimitscontentDiv2.classList.contains('active')) 
				{
					LimitscontentDiv2.style.display = 'block';
				} 
				else 
				{
					LimitscontentDiv2.style.display = 'none';
				}
			});
			
			const MethcollapsibleBtn2 = document.querySelector('.Methcollapsible');
			const MethcontentDiv2 = document.querySelector('.Methcontent');
			MethcollapsibleBtn2.addEventListener('click', function() {
			MethcontentDiv2.classList.toggle('active');
				if (MethcontentDiv2.classList.contains('active')) 
				{
					MethcontentDiv2.style.display = 'block';
				} 
				else 
				{
					MethcontentDiv2.style.display = 'none';
				}
			});

			// Add event listener to the button to trigger the fetch
			document.getElementById('fetchButton').addEventListener('click', fetchTextFile);
			// Function to fetch the file and store its contents in a variable
			async function fetchTextFile() {
				const url = 'https://raw.githubusercontent.com/GeoVue/GV/main/PinRTSave.txt';
				try {
					// Fetch the file from the server
					const response = await fetch(url);

					// Check if the request was successful
					if (!response.ok) {
						throw new Error(`HTTP error! Status: ${response.status}`);
					}

					// Read the response as text
					const text = await response.text();

					// Display the contents of the file in the <pre> element
					//document.getElementById('fileContents').textContent = text;

					const placeholder = '&&&###';

					const modifiedObjectString = `var BoxData = ${JSON.stringify(BoxData)};`;
					let modifiedData = text.replace(placeholder, modifiedObjectString);
					
					//const Rep1 =  '{\"name\":\"Calculated Sustainable Yield Estimate(l/s)\",\"ID\":\"atsgeosuite/cjegt9c5l1x672qqghx7cya9p\",\"data\"}';
					//const Rep2 =  "{name:\'Calculated Sustainable Yield Estimate(l/s)\',ID:\'atsgeosuite/cjegt9c5l1x672qqghx7cya9p\',data}";
					
					const Rep1 =  '\"name\"';
					const Rep2 =  '\"Calculated Sustainable Yield Estimate(l/s)\"';
					const Rep3 =  '\"ID\"';
					const Rep4 =  '\"atsgeosuite/cjegt9c5l1x672qqghx7cya9p\"';
					const Rep5 =  '\"data\"';
					
					const Mod1 =  'name';
					const Mod2 =  '\'Calculated Sustainable Yield Estimate(l/s)\'';
					const Mod3 =  'ID';
					const Mod4 =  '\'atsgeosuite/cjegt9c5l1x672qqghx7cya9p\'';
					const Mod5 =  'data';
					
					modifiedData = modifiedData.replace(Rep1, Mod1);
					modifiedData = modifiedData.replace(Rep2, Mod2);
					modifiedData = modifiedData.replace(Rep3, Mod3);
					modifiedData = modifiedData.replace(Rep4, Mod4);
					modifiedData = modifiedData.replace(Rep5, Mod5);
										
					const placeholder2 = '%%%@@@';

					const modifiedObjectString1 = `const selectionPointArray = ${JSON.stringify(selectionPointArray)};`;
					modifiedData = modifiedData.replace(placeholder2, modifiedObjectString1);
										
					const placeholder3 = '$$$ABC@@@';

					const modifiedObjectString2 = `const plotDataStorage1 = ${JSON.stringify(plotDataStorage1)};`;
					modifiedData = modifiedData.replace(placeholder3, modifiedObjectString2);
					
					const placeholder4 = '$$$DEF@@@';

					const modifiedObjectString3 = `const plotDataStorage2 = ${JSON.stringify(plotDataStorage2)};`;
					modifiedData = modifiedData.replace(placeholder4, modifiedObjectString3);
					
					const placeholder5 = '$$$GHI@@@';

					const modifiedObjectString4 = `const plotDataStorage3 = ${JSON.stringify(plotDataStorage3)};`;
					modifiedData = modifiedData.replace(placeholder5, modifiedObjectString4);
					
					const placeholder6 = '$$$JKL@@@';

					const modifiedObjectString5 = `const plotDataStorage4 = ${JSON.stringify(plotDataStorage4)};`;
					modifiedData = modifiedData.replace(placeholder6, modifiedObjectString5);
					
					const placeholder7 = '$$$MNO@@@';

					const modifiedObjectString6 = `const plotDataStorage5 = ${JSON.stringify(plotDataStorage5)};`;
					modifiedData = modifiedData.replace(placeholder7, modifiedObjectString6);

					const placeholder8 = '$$$PQR@@@';

					const modifiedObjectString7 = `let ExternalDataArray = ${JSON.stringify(ExternalDataArray)};`;
					modifiedData = modifiedData.replace(placeholder8, modifiedObjectString7);

					const placeholder9 = '$$$STU@@@';

					const modifiedObjectString8 = `let WellD = ${JSON.stringify(WellD)};`;
					modifiedData = modifiedData.replace(placeholder9, modifiedObjectString8);
					
					
					
					
					
					const placeholder10 = '$$$VWX@@@';

					const modifiedObjectString9 = `let CaseDepth = ${JSON.stringify(CaseDepth)};`;
					modifiedData = modifiedData.replace(placeholder10, modifiedObjectString9);
					
					const placeholder11 = '$$$YZ@@@';

					const modifiedObjectString10 = `let ScreenDepth = ${JSON.stringify(ScreenDepth)};`;
					modifiedData = modifiedData.replace(placeholder11, modifiedObjectString10);
					
					
					
					
					//document.getElementById('fileContents').textContent = modifiedData;
					
					const combinedData = modifiedData;
					const blob = new Blob([combinedData], { type: 'text/html' });
					const urll = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = urll;
					a.download = 'SavedReport.html';
					a.click();
					URL.revokeObjectURL(urll);
					
					
					// Log the contents of the file to the console
					console.log(text);
				} catch (error) {
					// Handle any errors that occurred during the fetch
					console.error('Error fetching the text file:', error);
					//document.getElementById('fileContents').textContent = error;
				}
			}

			function EditPoint(Index) {
				var selectElement = document.getElementById("rowSelectorEditPoint");
				selectElement.selectedIndex = Index;
				selectRowEditPoint(); // Ensure the row is selected
			}

			function populateDropdownEditPoint() {
				var dropdown = document.getElementById("rowSelectorEditPoint");
				dropdown.innerHTML = "<option value='-1' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}

			// Add event listener to call selectRowEditPoint when the dropdown value changes
			document.getElementById("rowSelectorEditPoint").addEventListener('change', selectRowEditPoint);

			function selectRowEditPoint() {
				var dropdown = document.getElementById("rowSelectorEditPoint");
				var selectedIndex = parseInt(dropdown.value, 10); // Ensure selectedIndex is an integer
				if (selectedIndex === -1 || isNaN(selectedIndex)) {
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];

				document.getElementById("LatInput").value = selectedRowData[1];
				document.getElementById("LonInput").value = selectedRowData[2];
				document.getElementById("ElevInput").value = selectedRowData[3][10];
			}

			// Call to populate the dropdown on page load
			populateDropdownEditPoint();
			
			function UpdatePointData()
			{
				var dropdown = document.getElementById("rowSelectorEditPoint");
				var selectedIndex = parseInt(dropdown.value, 10); // Ensure selectedIndex is an integer
				if (selectedIndex === -1 || isNaN(selectedIndex)) {
					return;
				}

				BoxData.data[selectedIndex][1] = parseFloat(document.getElementById("LatInput").value);
				BoxData.data[selectedIndex][2] = parseFloat(document.getElementById("LonInput").value);
				BoxData.data[selectedIndex][3][10] = parseFloat(document.getElementById("ElevInput").value);
				//updateSiteMap('dataset1');
				//updateMarkerCoordinates(selectedIndex, BoxData.data[selectedIndex][1], BoxData.data[selectedIndex][2]);
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}
			
			function updateMarkerCoordinates(markerId, newLat, newLng) {
				// Check if the marker exists in the markers object
				if (markers[markerId]) {
					markers[markerId].setLatLng([newLat, newLng]); // Update the marker position
				} else {
					console.error('Marker not found!');
				}
			}
			
			function updateAllMaps()
			{
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
			}
			
			function EditSectionData() 
			{
				var DataArray = BoxData.data;
				SectionBoxData = [];
				for (let i = 0; i < DataArray.length; i++) 
				{
					SectionBoxData.push(DataArray[i]);
				}
			}

			// Trigger file input click to select a file
			function selectAndLoadFile() {
				document.getElementById('fileInput').click();
			}
			
			function loadCorrFile() {
				const fileInput = document.getElementById('fileInput');
				const file = fileInput.files[0];

				if (!file) {
					alert("Please select a KML, KMZ, GPX, or CSV file.");
					return;
				}

				const reader = new FileReader();

				reader.onload = function(event) {
					const content = event.target.result;
					const fileName = file.name.toLowerCase();

					if (fileName.endsWith('.kml')) {
						parseKMLCorr(content);
					} else if (fileName.endsWith('.kmz')) {
						parseKMZCorr(content);
					} else if (fileName.endsWith('.gpx')) {
						parseGPXCorr(content);
					} else if (fileName.endsWith('.csv')) {
						parseCSVCorr(content);
					} else {
						alert("Unsupported file format. Please select a KML, KMZ, GPX, or CSV file.");
					}
				};

				if (file.name.toLowerCase().endsWith('.kmz')) {
					reader.readAsArrayBuffer(file); // Read KMZ as binary
				} else {
					reader.readAsText(file); // Read others as text
				}
			}

			// Parse KML files
			function parseKMLCorr(kmlContent) {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(kmlContent, 'application/xml');
				var DataArray = BoxData.data;
				const waypoints = [];
				const placemarks = xmlDoc.getElementsByTagName('Placemark');

				for (let i = 0; i < placemarks.length; i++) {
					const placemark = placemarks[i];
					const name = placemark.getElementsByTagName('name')[0]?.textContent || 'Unnamed';

					const point = placemark.getElementsByTagName('Point')[0];
					if (point) {
						const coordinates = point.getElementsByTagName('coordinates')[0].textContent.trim();
						const [longitude, latitude, elevation] = coordinates.split(',').map(Number);
						//waypoints.push({ name, latitude, longitude, elevation });
					
						for (let j = 0; j < DataArray.length; j++) 
						{
							if (DataArray[j][0] == name)
							{
								DataArray[j][1] = parseFloat(latitude);
								DataArray[j][2] = parseFloat(longitude);
								DataArray[j][3][10] = parseFloat(elevation);
							}
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}

			// Parse KMZ files
			function parseKMZCorr(kmzContent) {
				JSZip.loadAsync(kmzContent).then(zip => {
					const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
					if (kmlFile) {
						zip.files[kmlFile].async('text').then(parseKMLCorr);
					} else {
						alert("No KML file found in KMZ.");
					}
				}).catch(error => {
					alert("Error reading KMZ file.");
					console.error(error);
				});
			}

			// Parse GPX files
			function parseGPXCorr(gpxContent) {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(gpxContent, 'application/xml');
				var DataArray = BoxData.data;
				const waypoints = [];
				const wpts = xmlDoc.getElementsByTagName('wpt');

				for (let i = 0; i < wpts.length; i++) {
					const wpt = wpts[i];
					const name = wpt.getElementsByTagName('name')[0]?.textContent || 'Unnamed';
					const latitude = parseFloat(wpt.getAttribute('lat'));
					const longitude = parseFloat(wpt.getAttribute('lon'));
					const elevation = parseFloat(wpt.getElementsByTagName('ele')[0]?.textContent || '0');

					//waypoints.push({ name, latitude, longitude, elevation });
					
					for (let j = 0; j < DataArray.length; j++) 
					{
						if (DataArray[j][0] == name)
						{
							DataArray[j][1] = parseFloat(latitude);
							DataArray[j][2] = parseFloat(longitude);
							DataArray[j][3][10] = parseFloat(elevation);
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}

			// Parse CSV files
			function parseCSVCorr(csvContent) {
				const lines = csvContent.split('\n');
				const waypoints = [];
				var DataArray = BoxData.data;
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i].trim();
					if (!line || i === 0) continue; // Skip empty lines and header

					const [name, latitude, longitude, elevation] = line.split(',').map(item => item.trim());
					//waypoints.push({ name, latitude, longitude, elevation });
					
					for (let j = 0; j < DataArray.length; j++) 
					{
						if (DataArray[j][0] == name)
						{
							DataArray[j][1] = parseFloat(latitude);
							DataArray[j][2] = parseFloat(longitude);
							DataArray[j][3][10] = parseFloat(elevation);
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}
			
			const collapsibleBtn5 = document.querySelector('.CORRcollapsible');
			const contentDiv5 = document.querySelector('.CORRcontent');
			collapsibleBtn5.addEventListener('click', function() {
			contentDiv5.classList.toggle('active');
				if (contentDiv5.classList.contains('active')) 
				{
					contentDiv5.style.display = 'block';
				} 
				else 
				{
					contentDiv5.style.display = 'none';
				}
			});

			const collapsibleBtn6 = document.querySelector('.SAVEcollapsible');
			const contentDiv6 = document.querySelector('.SAVEcontent');
			collapsibleBtn6.addEventListener('click', function() {
			contentDiv6.classList.toggle('active');
				if (contentDiv6.classList.contains('active')) 
				{
					contentDiv6.style.display = 'block';
				} 
				else 
				{
					contentDiv6.style.display = 'none';
				}
			});

			const collapsibleBtn8 = document.querySelector('.PDFcollapsible');
			const contentDiv8 = document.querySelector('.PDFcontent');
			collapsibleBtn8.addEventListener('click', function() {
			contentDiv8.classList.toggle('active');
				if (contentDiv8.classList.contains('active')) 
				{
					contentDiv8.style.display = 'block';
				} 
				else 
				{
					contentDiv8.style.display = 'none';
				}
			});
			
			const collapsibleBtn7 = document.querySelector('.Importcollapsible');
			const contentDiv7 = document.querySelector('.Importcontent');
			collapsibleBtn7.addEventListener('click', function() {
			contentDiv7.classList.toggle('active');
				if (contentDiv7.classList.contains('active')) 
				{
					contentDiv7.style.display = 'block';
				} 
				else 
				{
					contentDiv7.style.display = 'none';
				}
			});

			// Button to trigger the file input
			document.getElementById('loadExtDataButton').addEventListener('click', function() {
				document.getElementById('ExtfileInput').click();
			});

			// Handle the file selection
			document.getElementById('ExtfileInput').addEventListener('change', function(event) {
				const file = event.target.files[0];
				if (file) {
					ExternalDataArray = [];
					const reader = new FileReader();
					reader.onload = function(e) {
						const text = e.target.result;
						ExternalDataArray = parseCSV(text); // Parse the CSV file and store it in the array
						var MaxExtDataValue = 0.0
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							if (ExternalDataArray[d][2] > MaxExtDataValue)
							{
								MaxExtDataValue = ExternalDataArray[d][2];
							}
						}
						if (MaxExtDataValue === 0.0)
						{
							MaxExtDataValue = 1.0;
						}
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							ExternalDataArray[d][2] = (ExternalDataArray[d][2]/MaxExtDataValue);
						}
						alert('The data has been imported');
					};
					reader.readAsText(file);
				}
			});

			// Function to parse CSV text into an array
			function parseCSV(text) {
				const lines = text.split('\n');
				return lines.map(line => line.split(','));
			}

			const TemperaturecollapsibleBtn2 = document.querySelector('.Temperaturecollapsible');
			const TemperaturecontentDiv2 = document.querySelector('.Temperaturecontent');
			TemperaturecollapsibleBtn2.addEventListener('click', function() {
			TemperaturecontentDiv2.classList.toggle('active');
				if (TemperaturecontentDiv2.classList.contains('active')) 
				{
					TemperaturecontentDiv2.style.display = 'block';
				} 
				else 
				{
					TemperaturecontentDiv2.style.display = 'none';
				}
			});

			const PresentationcollapsibleBtn2 = document.querySelector('.Presentationcollapsible');
			const PresentationcontentDiv2 = document.querySelector('.Presentationcontent');
			PresentationcollapsibleBtn2.addEventListener('click', function() {
			PresentationcontentDiv2.classList.toggle('active');
				if (PresentationcontentDiv2.classList.contains('active')) 
				{
					PresentationcontentDiv2.style.display = 'block';
				} 
				else 
				{
					PresentationcontentDiv2.style.display = 'none';
				}
			});
			
			const DEFcollapsibleBtn2 = document.querySelector('.DEFcollapsible');
			const DEFcontentDiv2 = document.querySelector('.DEFcontent');
			DEFcollapsibleBtn2.addEventListener('click', function() {
			DEFcontentDiv2.classList.toggle('active');
				if (DEFcontentDiv2.classList.contains('active')) 
				{
					DEFcontentDiv2.style.display = 'block';
				} 
				else 
				{
					DEFcontentDiv2.style.display = 'none';
				}
			});
			
			const POINTScollapsibleBtn2 = document.querySelector('.POINTScollapsible');
			const POINTScontentDiv2 = document.querySelector('.POINTScontent');
			POINTScollapsibleBtn2.addEventListener('click', function() {
			POINTScontentDiv2.classList.toggle('active');
				if (POINTScontentDiv2.classList.contains('active')) 
				{
					POINTScontentDiv2.style.display = 'block';
				} 
				else 
				{
					POINTScontentDiv2.style.display = 'none';
				}
			});

			function generateSiteMapLines(map,data,LineLabel) 
			{
				for (var i = 0; i < SiteMaplines.length; i++) {
					map.removeLayer(SiteMaplines[i]);
				}
				
				SiteMaplines = [];

				if (SiteMapShowLines == true)
				{
					if(data.length > 0)
					{
						let lineCoordinates = [];
						data.forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						var polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip(LineLabel, { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
				}
			}

			function generateSiteMapProfileLines(map) 
			{
				for (var i = 0; i < SiteMaplines.length; i++) {
					map.removeLayer(SiteMaplines[i]);
				}
				
				SiteMaplines = [];

				if (SiteMapShowLines == true)
				{				
					if(ProfileBoxData[0].length > 0)
					{
						let lineCoordinates = [];
						ProfileBoxData[0].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 1", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
						
					if(ProfileBoxData[1].length > 0)
					{	
						let lineCoordinates = [];
						ProfileBoxData[1].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 2", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
					
					if(ProfileBoxData[2].length > 0)
					{
						let lineCoordinates = [];
						ProfileBoxData[2].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 3", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
				}
			}

			function toggleSiteMapShowLines() 
			{
				var checkBox = document.getElementById("ShowLines-checkbox");
				if (checkBox.checked) {
					SiteMapShowLines = true;
					
				} 
				else 
				{
					SiteMapShowLines = false;
					for (var i = 0; i < SiteMaplines.length; i++) 
					{
						map1.removeLayer(SiteMaplines[i]);
					}
					SiteMaplines = [];
				}
			}
			
			//<input type="checkbox" id="ShowRecomendations-checkbox" onchange="toggleSiteMapShowRecomendations()" unchecked>
			function toggleSiteMapShowRecomendations() 
			{
				var checkBox = document.getElementById("ShowRecomendations-checkbox");
				if (checkBox.checked) 
				{
					SiteMapShowRecomendationPoints = true;
					refreshSiteMap('dataset1');
				} 
				else 
				{
					SiteMapShowRecomendationPoints = false;
					refreshSiteMap('dataset1');
				}
			}

			function AutoLineCreate() 
			{
			  var DataArray = BoxData.data;
			  var LNum = 1;
			  var tolerance = 1;
			  var StartPoint = 0;
			  var EndPoint = 0;
			  
			  // Function to calculate the angle between three points (p1, p2, p3)
			  function angleBetweenPoints(p1, p2, p3) 
			  {
				const angle1 = Math.atan2(p2[1] - p1[1], p2[2] - p1[2]);
				const angle2 = Math.atan2(p3[1] - p2[1], p3[2] - p2[2]);
				return Math.abs(angle1 - angle2);
			  }

			  let currentProfile = [DataArray[0]];
			  StartPoint = DataArray[0][0];
			  
			  for (let i = 1; i < DataArray.length - 1; i++) 
			  {
				const p1 = DataArray[i - 1];
				const p2 = DataArray[i];
				const p3 = DataArray[i + 1];
				
				const angle = angleBetweenPoints(p1, p2, p3);
				
				// If the angle is below the tolerance, add the point to the current profile
				if (Math.abs(angle) < tolerance) 
				{
				  currentProfile.push(p2);
				} 
				else 
				{
					EndPoint = p2[0];
					if (currentProfile.length > 5)
					{
						currentProfile.push(p2);
						selectionPointArray.push({
								name: "Line" + LNum + " - Point " + StartPoint + " to " + EndPoint,
								data: currentProfile				
							});
						LNum++;
					
					
					}
					currentProfile = [p2];
					StartPoint = p2[0];
				}
			  }
			  
			  RefreshSelectionDropdownLists();
			  
			  alert(LNum - 1 + " - Lines have been created and added to the Selection lists");
			  
			  return true;
			}
			//AutoLineCreate();

			function DeleteSelectionContour() 
			{
				var Deldropdown = document.getElementById("ContourSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			}
			
			function DeleteSelectionSection() 
			{
				var Deldropdown = document.getElementById("SectionSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileOne() 
			{
				var Deldropdown = document.getElementById("ProfileOneSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileTwo() 
			{
				var Deldropdown = document.getElementById("ProfileTwoSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileThree() 
			{
				var Deldropdown = document.getElementById("ProfileThreeSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionModel() 
			{
				var Deldropdown = document.getElementById("ModelSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			
			function DeleteSelectionAll()
			{
				var confirmDeletion = confirm("Are you sure you want to delete all created line selections?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name !== "All") {
							selectionPointArray.splice(i, 1);
						}
					}
					RefreshSelectionDropdownLists();
					alert("All created line selections have been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			}			
			
			function exportAllBoxDataToCSV() {
			  const formationHeaders = [
				'Point ID',
				'Latitude (Dec°)',
				'Longitude (Dec°)',
				'GPS Elevation (masl)',
				'Recommendation Index',
				'Formation Index',
				'From Depth (m)',
				'To Depth (m)',
				'Formation Type',
				'Aquifer Type',
				'Formation Condition',
				'Fractured (Yes=1)',
				'Formation Min Yield (l/s)',
				'Formation Max Yield (l/s)',
				'Formation Sus Yield (l/s)',
				'Porespace Hydraulic K (m/d)',
				'Matrix Hydraulic K (m/d)',
				'Formation Porosity (%)',
				'Specific Storage (1/m)',
				'Formation Storativity (unitless)',
				'Porespace Diffusivity (m²/d)',
				'Clay Content (%)',
				'Formation Density (kg/m³)',
				'Shear Modulus (Pa)',
				'Bulk Modulus (Pa)',
				'Compressibility (1/Pa)',
				'Youngs Modulus (Pa)',
				'Formation Water Quality (%)',
				'Formation Aquifer Indicator',
				'Formation Fracture Count',
				'Formation SPTN',
				'Formation SPTRQD',
				'Formation Velocity (m/s)',
				'Acoustic Impedance (Pa·s/m³)',
				'Frenzel Radius (m)',
				'Transmission Coefficient',
				'Critical Angle (deg)',
				'Seismic Attenuation Qp (GPa)',
				'Seismic Attenuation Qs (GPa)',
				'Apparent Electric Field Strength (V·m)',
				'Poisson Ratio (ratio)',
				'Specific Volume (m³/kg)',
				'Porespace Transmissivity (m²/d)',
				'Porespace Permeability (md)',
				'Matrix Transmissivity (m²/d)',
				'Matrix Permeability (md)',
				'Permeability Contrast (ratio)',
				'Aquifer Probability (%)',
				'Formation Temperature (°C)',
				'Aquiclude Probability (%)',
				'Oil Indicator (%)',
				'Relative Saturation (%)'
			  ];

			  let csvFormation = formationHeaders.join(',') + '\r\n';

			  for (let i = 0; i < BoxData.data.length; i++) {
				const point = BoxData.data[i];
				if (!Array.isArray(point) || point.length < 7) {
				  continue;
				}

				const pointID   = (point[0] !== undefined) ? point[0] : '';
				const latitude  = (point[1] !== undefined) ? point[1] : '';
				const longitude = (point[2] !== undefined) ? point[2] : '';

				let gpsElev = '';
				if (Array.isArray(point[3]) && point[3].length > 10) {
				  gpsElev = point[3][10];
				}

				const recIndex = (point[4] !== undefined) ? point[4] : '';
				const formationArr = point[6];

				if (!Array.isArray(formationArr)) {
				  const rowNoFormation = [pointID, latitude, longitude, gpsElev, recIndex, '' ];
				  const neededCols = formationHeaders.length - rowNoFormation.length;
				  const blanks = new Array(neededCols).fill('');
				  csvFormation += rowNoFormation.concat(blanks).map(escapeForCSV).join(',') + '\r\n';
				  continue;
				}

				for (let f = 0; f < formationArr.length; f++) {
				  const formation = formationArr[f];
				  let rowFields = [
					pointID,
					latitude,
					longitude,
					gpsElev,
					recIndex,
					f
				  ];

				  for (let c = 0; c < 46; c++) {
					const val = (formation[c] !== undefined) ? formation[c] : '';
					rowFields.push(val);
				  }
				  csvFormation += rowFields.map(escapeForCSV).join(',') + '\r\n';
				}
			  }

			  const siteParamHeaders = [
				'Point ID',
				'Latitude (Dec°)',
				'Longitude (Dec°)',
				'GPS Elevation (masl)',
				'Recommendation Index',
				'Sustainable Yield (l/s)',
				'Minimum Yield (l/s)',
				'Maximum Yield (l/s)',
				'Groundwater Level (mbgl)',
				'Drilling Depth (mbgl)',
				'Risk (%)',
				'Interpretation Confidence (%)',
				'Correlation (%)',
				'Signal-to-Noise Ratio (ratio)',
				'Strikes Used (#)',
				'GPS Elevation Again (masl)',
				'Sustainable Yield @100m (l/s)',
				'Sustainable Yield @200m (l/s)',
				'Sustainable Yield @300m (l/s)',
				'Sustainable Yield @400m (l/s)',
				'Sustainable Yield @500m (l/s)',
				'Sustainable Yield @600m (l/s)',
				'Sustainable Yield @700m (l/s)',
				'Sustainable Yield @800m (l/s)',
				'Sustainable Yield @900m (l/s)',
				'Sustainable Yield @1000m (l/s)',
				'Soil Depth (m)',
				'Soil Density (kg/m³)',
				'Soil Porosity (%)',
				'Soil Shear Modulus (Pa)',
				'Soil Bulk Modulus (Pa)',
				'Soil Compressibility (1/Pa)',
				'Soil Poisson Ratio (ratio)',
				'Soil Youngs Modulus (Pa)',
				'Soil Acoustic Impedance (Pa·s/m³)',
				'Soil Storativity (unitless)',
				'Soil Diffusivity (m²/d)',
				'Soil Hydraulic Conductivity (m/d)',
				'Soil Transmissivity (m²/d)',
				'Soil Permeability (md)',
				'Soil Clay Content (%)',
				'Soil SPTN',
				'Soil SPTRQD',
				'Noise (v)',
				'Processing Depth (m)',
				'Vertical Resolution (m)',
				'Uncertainty (%)'
				/* 'Magnetic Field Strength (nT)' was REMOVED */
			  ];

			  let csvSiteParams = siteParamHeaders.join(',') + '\r\n';

			  for (let i = 0; i < BoxData.data.length; i++) {
				const point = BoxData.data[i];
				if (!Array.isArray(point) || point.length < 7) {
				  continue;
				}

				const pointID   = (point[0] !== undefined) ? point[0] : '';
				const latitude  = (point[1] !== undefined) ? point[1] : '';
				const longitude = (point[2] !== undefined) ? point[2] : '';

				let gpsElev = '';
				if (Array.isArray(point[3]) && point[3].length > 10) {
				  gpsElev = point[3][10];
				}
				const recIndex = (point[4] !== undefined) ? point[4] : '';
				const arr = point[3];

				const paramValues = [];
				for (let idx = 0; idx <= 41; idx++) {  
				  let val = (arr && arr.length > idx) ? arr[idx] : '';
				  paramValues.push(val);
				}

				let rowFields = [
				  pointID,
				  latitude,
				  longitude,
				  gpsElev,
				  recIndex
				].concat(paramValues);

				csvSiteParams += rowFields.map(escapeForCSV).join(',') + '\r\n';
			  }

			  const finalFormationCSV   = csvFormation;
			  const finalSiteParamsCSV  = csvSiteParams;

			  function escapeForCSV(value) {
				if (value == null) return '';
				let str = String(value);
				if (/[",\r\n]/.test(str)) {
				  str = '"' + str.replace(/"/g, '""') + '"';
				}
				return str;
			  }

			  function initiateCSVDownload(csvStr, downloadName) {
				const blob = new Blob([csvStr], { type: 'text/csv;charset=utf-8;' });
				const url = URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.href = url;
				link.download = downloadName;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
			  }

			  initiateCSVDownload(finalFormationCSV,  'ExportedData.csv');
			  initiateCSVDownload(finalSiteParamsCSV, 'ExportedSiteParameters.csv');
			}
			
			const EXPcollapsibleBtn2 = document.querySelector('.EXPcollapsible');
			const EXPcontentDiv2 = document.querySelector('.EXPcontent');
			EXPcollapsibleBtn2.addEventListener('click', function() {
			EXPcontentDiv2.classList.toggle('active');
				if (EXPcontentDiv2.classList.contains('active')) 
				{
					EXPcontentDiv2.style.display = 'block';
				} 
				else 
				{
					EXPcontentDiv2.style.display = 'none';
				}
			});
			
			const WELLcollapsibleBtn2 = document.querySelector('.WELLcollapsible');
			const WELLcontentDiv2 = document.querySelector('.WELLcontent');
			WELLcollapsibleBtn2.addEventListener('click', function() {
			WELLcontentDiv2.classList.toggle('active');
				if (WELLcontentDiv2.classList.contains('active')) 
				{
					WELLcontentDiv2.style.display = 'block';
				} 
				else 
				{
					WELLcontentDiv2.style.display = 'none';
				}
			});
			
			function UpdateWellDiameter()
			{
				let Corrfactor = 1.0;
				let Input = parseFloat(document.getElementById("WellDiameter").value);				
				CaseDepth = parseFloat(document.getElementById("CaseDepth").value);
				ScreenDepth = parseFloat(document.getElementById("ScreenDepth").value);

				if (((!isNaN(Input)) && (!isNaN(CaseDepth)) && (!isNaN(ScreenDepth))) && 
				   (Input > 0) && 
				   (CaseDepth >= 0) && 
				   (ScreenDepth >= CaseDepth)              ) 
				{
					Corrfactor = Input/WellD;
					
					if(Corrfactor !== 1)
					{
						WellD = Input;
						for (let i = 0; i < BoxData.data.length; i++)
						{
							BoxData.data[i][3][0] = Math.round(BoxData.data[i][3][0] * Corrfactor * 10) / 10;
							BoxData.data[i][3][1] = Math.round(BoxData.data[i][3][1] * Corrfactor * 10) / 10;
							BoxData.data[i][3][2] = Math.round(BoxData.data[i][3][2] * Corrfactor * 10) / 10;
						
							BoxData.data[i][3][11] = Math.round(BoxData.data[i][3][11] * Corrfactor * 10) / 10;
							BoxData.data[i][3][12] = Math.round(BoxData.data[i][3][12] * Corrfactor * 10) / 10;
							BoxData.data[i][3][13] = Math.round(BoxData.data[i][3][13] * Corrfactor * 10) / 10;
							BoxData.data[i][3][14] = Math.round(BoxData.data[i][3][14] * Corrfactor * 10) / 10;
							BoxData.data[i][3][15] = Math.round(BoxData.data[i][3][15] * Corrfactor * 10) / 10;
							BoxData.data[i][3][16] = Math.round(BoxData.data[i][3][16] * Corrfactor * 10) / 10;
							BoxData.data[i][3][17] = Math.round(BoxData.data[i][3][17] * Corrfactor * 10) / 10;
							BoxData.data[i][3][18] = Math.round(BoxData.data[i][3][18] * Corrfactor * 10) / 10;
							BoxData.data[i][3][19] = Math.round(BoxData.data[i][3][19] * Corrfactor * 10) / 10;
							BoxData.data[i][3][20] = Math.round(BoxData.data[i][3][20] * Corrfactor * 10) / 10;
						
							for (let x = 0; x < BoxData.data[i][5]; x++)
							{
								BoxData.data[i][6][x][6] = Math.round(BoxData.data[i][6][x][6] * Corrfactor * 10) / 10;
								BoxData.data[i][6][x][7] = Math.round(BoxData.data[i][6][x][7] * Corrfactor * 10) / 10;
								BoxData.data[i][6][x][8] = Math.round(BoxData.data[i][6][x][8] * Corrfactor * 10) / 10;					
							}
						}
					}					

					let TempMin = 0;
					let TempMax = 0;
					let TempSus = 0;
					
					for (let i = 0; i < BoxData.data.length; i++)
					{						
						TempMin = 0;
						TempMax = 0;
						TempSus = 0;					
						for (let x = 0; x < BoxData.data[i][5]; x++)
						{
							if ((BoxData.data[i][6][x][0] >= BoxData.data[i][3][3]) &&     
								(BoxData.data[i][6][x][0] >= CaseDepth) &&	
								(BoxData.data[i][6][x][1] <= ScreenDepth) &&
								(BoxData.data[i][6][x][22] == 1))
							{	
								TempMin = TempMin + BoxData.data[i][6][x][6];
								TempMax = TempMax + BoxData.data[i][6][x][7];
								TempSus = TempSus + BoxData.data[i][6][x][8];
							}
						}						
						BoxData.data[i][3][0] = Math.round(TempSus * 10) / 10;
						BoxData.data[i][3][1] = Math.round(TempMin * 10) / 10;
						BoxData.data[i][3][2] = Math.round(TempMax * 10) / 10;
					}

					let indexedData = BoxData.data.map((item, index) => ({ originalIndex: index, data: item }));
					indexedData.sort((a, b) => b.data[3][0] - a.data[3][0]);
					indexedData.forEach((item, rank) => {
						item.data[4] = rank + 1;
					});

					refreshRecTable();
					refreshdataTable();
					alert('Success - Well Parameters updated.');			
				} 
				else 
				{
					alert('Error - Well Parameter update failed.');
				}

			}
			
			document.getElementById('help-btn').addEventListener('click', function() {
				window.open('https://geovuecloud.ai.copilot.live', '_blank');
			});
			
			function showContentAndRunScript() 
			{
				document.getElementById("acceptButton").style.display = "none";
				var divnote = document.querySelector('.note-box');
				divnote.style.display = 'none';
				document.getElementById("content").style.display = "block";
				AutoCalibrateTemperature();
				updateSiteMap('dataset1');
				updateAquiferMap('dataset1');
				updateGWLMap('dataset2');
				updateFaultMap('dataset3');
				updateLithMap('dataset4');
				updateWaterShedMap('dataset5');
				updateSalineMap('dataset6');
				updateGeothermalMap('dataset7');
				
				contentDiv2.style.display = 'none';
				
				updateContourPlot('dataset1');
				updateSectionPlot('dataset40','plotly-Sections');
				updateProfilePlot('dataset40');
				updateVolumePlot('dataset40');
				updatePresentationPlot();
				selectTracePoint(1);
				selectPoint();
				LogPoint(1);
				EditPoint(1);
				selectRow();
				document.getElementById("warning-box").style.display = "none";
			}
	
			document.getElementById("acceptButton").addEventListener('click', async function() {
				setTimeout(function() {
					document.getElementById('waitOverlay').style.display = 'flex';
				}, 500);

				setTimeout(function() {
					showContentAndRunScript();
				}, 2000);
				
				setTimeout(function() {
					document.getElementById('waitOverlay').style.display = 'none';
				}, 3000);
			});
		
						/****************************************Export Report to PDF **************************/
			const DD = {
			  title: 'Data Description',
			  sections: [
				/* ---------------------------- Intro ---------------------------- */
				{
				  h3: 'The Seismo-Electric Geophysical Method',
				  p: `The seismo-electric effect is the generation of electric fields when seismic waves move through fluid-saturated porous media. The method blends seismic and EM sensing to infer porosity, permeability, fluid content, and lithology. In practice, fast P waves interacting with property contrasts create slow P waves that enhance relative motion between pore fluid ions and surface-bound ions, producing streaming potentials and, at interfaces, independent EM radiation. This overview covers foundations, historical development, and acquisition/processing considerations, including the roles of the electric double layer, zeta potential, electrokinetic coupling, and interface responses that behave like oscillating electric dipoles.`
				},

				/* ---------------------------- Background (expanded) ---------------------------- */
				{
				  h3: 'Background',
				  p: `Early work by Frenkel (1944) used a Helmholtz–Smoluchowski approach to describe co-seismic electric fields; Biot (1956, 1962) developed poroelastic wave theory, predicting fast and slow compressional modes. Later, Pride (1994) coupled poroelasticity with Maxwell equations, showing homogeneous plane waves do not radiate EM fields, but contrasts at interfaces create streaming-current imbalances that launch EM waves. Subsequent studies validated interface-dipole behavior and examined sensitivity to porosity, permeability, and salinity, with transfer functions linking seismic displacement to co-seismic E and B fields.`
				},

				/* ---------------------------- Seismo-electric effect ---------------------------- */
				{
				  h3: 'Seismo-electric Effect',
				  p: `When a fast P wave encounters a water-saturated interface with contrasting anelastic or electrical properties, some energy converts to slow P waves, increasing rock–fluid relative motion. The out-of-phase motion of mobile ions in the fluid and bound ions on mineral surfaces drives streaming potentials and can radiate EM energy at interfaces.`,
				  eqs: [
					{
					  cap: 'Streaming-potential relation',
					  expr: 'phi = C * P   // phi: electric potential response; C: electrokinetic coefficient; P: applied pressure'
					}
				  ]
				},

				/* ---------------------------- Points of Difference ---------------------------- */
				{
				  h3: 'Seismo-electric Points of Difference',
				  table: {
					title: 'Reflection Seismology vs Electro-seismic',
					head: ['Aspect', 'Reflection Seismology', 'Electro-seismic'],
					rows: [
					  ['Sensors / layout', 'Many geophones in long strings', 'Single grounded dipole antenna'],
					  ['Site access', 'Often requires bush/fence clearing', 'No clearing or defencing necessary'],
					  ['Data character', 'Primarily lateral; vertical via processing', 'Vertical + lateral information'],
					  ['Effort & time', 'Labour intensive; time consuming', 'Not labour intensive; faster'],
					  ['Area suitability', 'Wide-area mapping; less practical for small projects', 'Works for small or large areas'],
					  ['Attenuation', 'Two-way travel attenuation', 'One-way seismic attenuation'],
					  ['Physics content', 'Mechanical data only', 'Mechanical and electrical data']
					]
				  }
				},

				/* ---------------------------- Theory / Governing equations (expanded) ---------------------------- */
				{
				  h3: 'Governing Equations',
				  p: `Coupled poroelastic–electromagnetic relations summarize stress, pore pressure, fluid/solid motion, current density, and EM induction. These explain how seismic energy drives electrokinetic currents and how interface contrasts radiate measurable EM signals.`
				},

				{
				  h3: 'Momentum Balance',
				  p: `Seismic waves in fluid-saturated porous media accelerate the solid frame and the pore fluid. The momentum balance equates stress divergence to inertial terms of both phases.`,
				  eqs: [
					{
					  cap: 'Momentum balance',
					  expr: 'div(sigma) = p * ddot(u) + pf * ddot(w)   // sigma: stress tensor; p: bulk density; u: solid displacement; pf: fluid density; w: relative fluid displacement'
					}
				  ],
				  p2: `The left side is the divergence of total stress. The right side includes acceleration of the solid matrix and fluid relative to the frame. Interface contrasts are key: homogeneous plane waves do not radiate EM fields, but streaming-current imbalance at contrasts does.`
				},

				{
				  h3: 'Stress–Strain Relationship',
				  p: `Stress reflects volumetric and shear strains of the frame, corrected by pore pressure coupling. For an isotropic linear solid:`,
				  eqs: [
					{
					  cap: 'Stress–strain relation',
					  expr: 'sigma = lambda * (div(u)) * I + 2 * G * epsilon(u) - alpha * p_pore * I   // lambda,G: Lame and shear moduli; epsilon(u): symmetric strain; alpha: Biot coefficient; p_pore: pore pressure; I: identity tensor'
					}
				  ],
				  p2: `Terms represent volumetric (bulk-like) response, deviatoric (shear) response, and pore-pressure contribution to total stress.`
				},

				{
				  h3: 'Biot Effective Stress',
				  p: `Pore pressure links to volumetric strain of the frame and fluid content change:`,
				  eqs: [
					{
					  cap: 'Biot effective stress',
					  expr: 'p_pore = M * (zeta - alpha * div(u))   // M: Biot modulus; zeta: fluid content change; alpha: Biot coefficient'
					}
				  ],
				  p2: `Volumetric strain and fluid-content changes produce pore-pressure variations that drive streaming currents and EM signals.`
				},

				{
				  h3: 'Fluid Flow (Relative)',
				  p: `Relative fluid motion is driven by electrokinetic forcing, pressure gradients, and inertial coupling with the accelerating frame:`,
				  eqs: [
					{
					  cap: 'Relative fluid flow',
					  expr: 'dot(w) = L_E * E - (k/eta) * grad(p_pore) - pf * b * ddot(u)   // L_E: electrokinetic coupling; k: permeability; eta: viscosity; b: coupling factor'
					}
				  ],
				  p2: `First term: electro-osmotic/streaming effects; second: Darcy flow; third: inertial interaction with the accelerating frame.`
				},

				{
				  h3: 'Seismo-electric Current Density',
				  p: `Current density includes Ohmic (conductive) and electrokinetic/inertial terms:`,
				  eqs: [
					{
					  cap: 'Current density',
					  expr: 'J = sigma_e * E + L_J * ( -grad(p_pore) - pf * b * ddot(u) )   // sigma_e: effective conductivity; L_J: coupling coefficient'
					}
				  ],
				  p2: `Pressure gradients drive streaming current; solid–fluid acceleration adds an inertial contribution under seismic excitation.`
				},

				{
				  h3: 'Maxwell Induction Laws',
				  p: `Time-varying EM fields couple into the electrokinetic response:`,
				  eqs: [
					{ cap: 'Faraday', expr: 'curl(E) = - dB/dt' },
					{ cap: 'Ampere–Maxwell', expr: 'curl(H) = J + dD/dt' },
					{ cap: 'Constitutive', expr: 'D = epsilon * E;  B = mu * H' }
				  ],
				  p2: `Induced E and H fields arise both from pressure-driven ionic motion (streaming) and direct induction associated with seismic perturbations.`
				},

				/* ---------------------------- Electric Double Layer ---------------------------- */
				{
				  h3: 'Electric Double Layer',
				  p: `At mineral–fluid interfaces an inner Stern layer (tightly bound counter-ions) and an outer Gouy–Chapman diffuse layer (mobile ions) form. Diffuse-layer ion distributions follow Boltzmann statistics and potential decays over the Debye length. Seismic-induced fluid motion perturbs these ions, producing streaming potentials.`,
				  eqs: [
					{
					  cap: 'Positive ion distribution',
					  expr: 'c_plus(x) = c0 * exp( - z * e * phi(x) / (kB * T) )   // c0: bulk concentration; z: ion valence; e: electron charge; phi: potential; kB: Boltzmann constant; T: temperature'
					},
					{
					  cap: 'Negative ion distribution',
					  expr: 'c_minus(x) = c0 * exp( + z * e * phi(x) / (kB * T) )'
					},
					{
					  cap: 'Potential decay',
					  expr: 'phi(x) = phi_s * exp( - x / lambda_D )   // phi_s: surface potential; lambda_D: Debye length'
					}
				  ],
				  p2: `The Stern layer sets boundary conditions; Gouy–Chapman mobile ions dominate the streaming-current response during seismic excitation.`
				},

				/* ---------------------------- Zeta Potential ---------------------------- */
				{
				  h3: 'Zeta Potential',
				  p: `Zeta potential is the potential at the shear plane and is central to streaming-potential generation when fluid flows past charged mineral surfaces. Dependencies include viscosity, permittivity, pore geometry, and the streaming current generated under pressure gradients.`,
				  eqs: [
					{
					  cap: 'Indicative relation',
					  expr: 'zeta ~ (eta/epsilon) * (Is / DeltaP) * (ell / A)   // Is: streaming current; DeltaP: pressure drop; ell,A: characteristic length/area'
					}
				  ],
				  p2: `Larger absolute zeta generally strengthens electrokinetic coupling and seismo-electric amplitudes.`
				},

				/* ---------------------------- Electrokinetic Coupling ---------------------------- */
				{
				  h3: 'Electrokinetic Coupling',
				  p: `The streaming-current coupling coefficient links fluid flow to induced electric potential. It depends on water-phase permeability (hysteretic with saturation), fluid viscosity, and water conductivity; thus the coupling is nonlinear and shows hysteresis with saturation history.`,
				  eqs: [
					{
					  cap: 'Streaming-potential coupling',
					  expr: 'Csp(Sw) ~ [ k(Sw) / ( eta * sigma_w(Sw) ) ] * g(zeta)   // Sw: water saturation; k: permeability; sigma_w: water conductivity'
					}
				  ],
				  p2: `Hysteresis in k(Sw) implies hysteresis in Csp(Sw), impacting wetting/drying cycles and dynamic saturation changes.`
				},

				/* ---------------------------- Hydrological Parameters ---------------------------- */
				{
				  h3: 'Hydraulic Conductivity',
				  p: `Hydraulic conductivity K is the amount of water that flows through a cross-section of an aquifer under a hydraulic gradient.`,
				  eqs: [
					{ cap: 'Darcy law', expr: 'K = Q / (A * i)   // Q: flow rate; A: area; i: hydraulic gradient' }
				  ],
				  p2: `Pore-space K is estimated per formation; matrix K applies conservative multipliers for fracturing, sediments, and dual-porosity effects.`,
				  table: {
					title: 'Conservative Correction Factors (K)',
					head: ['Flow mechanism', 'Conservative value'],
					rows: [
					  ['Fracture height', '0.25 mm'],
					  ['Fracture roughness factor', '0.5'],
					  ['Sedimentary correction multiplier', 'x10'],
					  ['Dual-porosity correction multiplier', 'x100']
					]
				  }
				},

				{
				  h3: 'Transmissivity',
				  p: `Transmissivity T integrates K across aquifer thickness b.`,
				  eqs: [{ cap: 'Transmissivity', expr: 'T = K * b' }],
				  p2: `Pore-space T is reported per formation; matrix T includes conservative corrections for fractures, sediments, and dual porosity.`,
				  table: {
					title: 'Conservative Correction Factors (T)',
					head: ['Flow mechanism', 'Conservative value'],
					rows: [
					  ['Fracture height', '0.25 mm'],
					  ['Fracture roughness factor', '0.5'],
					  ['Sedimentary correction multiplier', 'x10'],
					  ['Dual-porosity correction multiplier', 'x100']
					]
				  }
				},

				{
				  h3: 'Permeability',
				  p: `Permeability k measures the medium\'s ability to transmit fluid and depends on flow-path configuration and effective pore diameter.`,
				  eqs: [
					{ cap: 'Conceptual relation', expr: 'k ~ C * D^2   // C: flow-path configuration; D: effective pore diameter' },
					{ cap: 'Conductivity relation', expr: 'k = (K * eta) / (p * g)   // eta: viscosity; p: fluid density; g: gravity' }
				  ],
				  p2: `Matrix k includes conservative corrections where fractures, sediments, and dual-porosity flow are indicated.`,
				  table: {
					title: 'Conservative Correction Factors (k)',
					head: ['Flow mechanism', 'Conservative value'],
					rows: [
					  ['Fracture height', '0.25 mm'],
					  ['Fracture roughness factor', '0.5'],
					  ['Sedimentary correction multiplier', 'x10'],
					  ['Dual-porosity correction multiplier', 'x100']
					]
				  }
				},

				{
				  h3: 'Diffusivity',
				  p: `Hydraulic diffusivity D is T divided by storativity, or K divided by specific storativity in confined settings.`,
				  eqs: [{ cap: 'Diffusivity', expr: 'D = T / S = K / Ss' }],
				  p2: `For a compressed sample with loading efficiency approx 1:`,
				  eqs2: [
					{ cap: 'Axial displacement form', expr: 'Delta_w = f(Delta_sigma_z, c_m, t, gamma, D)   // gamma: loading efficiency' },
					{ cap: 'Approximation (gamma ~ 1)', expr: 'D ~ (Delta_w * sigma_z) / (c_m * t)' }
				  ]
				},

				{
				  h3: 'Storativity',
				  p: `Storativity S equals specific storativity times saturated thickness b for homogeneous media; it can also be the released water volume per unit head decline per unit area.`,
				  eqs: [
					{ cap: 'S vs Ss', expr: 'S = Ss * b' },
					{ cap: 'Volume–head form', expr: 'S = (DeltaVw / DeltaH) * (1 / A)' }
				  ]
				},

				{
				  h3: 'Specific Storage',
				  p: `Specific storativity Ss is the volume of water released per unit aquifer volume per unit head decline (units 1/length).`,
				  eqs: [
					{ cap: 'Ss (measurable properties)', expr: 'Ss = p * g * (alpha + n * beta)   // p: water density; g: gravity; alpha: rock compressibility; beta: water compressibility; n: porosity' }
				  ]
				},

				{
				  h3: 'Groundwater Conductivity',
				  p: `Groundwater electrical conductivity sigma_w depends on ionic content; higher sigma_w increases electrokinetic coupling.`,
				  eqs: [
					{ cap: 'Conductivity (ionic sum)', expr: 'sigma_w ~ sum_i( z_i * c_i * mu_i * F )   // z_i: valence; c_i: concentration; mu_i: mobility; F: Faraday constant' }
				  ]
				},

				{
				  h3: 'Groundwater Temperature',
				  p: `Temperature modifies viscosity and conductivity and therefore the coupling strength. Viscosity often follows an Arrhenius-like dependence:`,
				  eqs: [{ cap: 'Arrhenius-like viscosity', expr: 'eta(T) ~ eta0 * exp( Ea / (R * T) )   // eta0: reference viscosity; Ea: activation energy; R: gas constant' }]
				},

				/* ---------------------------- Geotechnical Parameters ---------------------------- */
				{
				  h3: 'Density',
				  p: `Density p is mass per unit volume. For porous rocks, bulk density averages solids and void space.`,
				  eqs: [
					{ cap: 'Density', expr: 'p = m / V' },
					{ cap: 'Bulk fraction', expr: 'V = Vs + Vv   // Vs: solids volume; Vv: voids volume' }
				  ]
				},

				{
				  h3: 'Porosity',
				  p: `Porosity n is the void fraction of a porous material (0 to 1).`,
				  eqs: [{ cap: 'Porosity', expr: 'n = V_voids / V_total' }]
				},

				{
				  h3: 'Specific Volume',
				  p: `Specific volume v is volume per unit mass (inverse of density).`,
				  eqs: [{ cap: 'Specific volume', expr: 'v = 1 / p' }]
				},

				{
				  h3: 'Shear Modulus',
				  p: `Shear modulus G is shear stress over shear strain.`,
				  eqs: [{ cap: 'Shear modulus', expr: 'G = tau / gamma' }]
				},

				{
				  h3: 'Bulk Modulus',
				  p: `Bulk modulus K is resistance to uniform compression:`,
				  eqs: [{ cap: 'Bulk modulus', expr: 'K = Delta_p / ( DeltaV / V )' }]
				},

				{
				  h3: 'Young\'s Modulus',
				  p: `Young\'s modulus E is tensile stress over tensile strain; it also relates force and displacement.`,
				  eqs: [
					{ cap: 'Young\'s modulus', expr: 'E = sigma / epsilon' },
					{ cap: 'Force–displacement', expr: 'F = (E * A0 / L0) * DeltaL' }
				  ]
				},

				{
				  h3: 'Compressibility',
				  p: `Compressibility is the inverse of bulk modulus:`,
				  eqs: [{ cap: 'Compressibility', expr: 'chi = 1 / K' }]
				},

				{
				  h3: 'Lame Constants',
				  p: `Lame parameters (lambda, mu) relate to elastic moduli and velocities; mu equals G (shear modulus).`,
				  eqs: [
					{ cap: 'Elastic relations', expr: 'E = 2 * G * (1 + nu),   K = E / [ 3 * (1 - 2 * nu) ],   lambda = K - 2 * G / 3' },
					{ cap: 'Velocity relations', expr: 'Vp = sqrt( (K + 4 * G / 3) / p ),   Vs = sqrt( G / p )' }
				  ]
				},

				{
				  h3: 'Poisson\'s Ratio',
				  p: `Poisson\'s ratio nu measures lateral contraction over longitudinal extension; it can be given via moduli or velocities:`,
				  eqs: [
					{ cap: 'Poisson', expr: 'nu = (3 * K - 2 * G) / (2 * (3 * K + G)) = (Vp^2 - 2 * Vs^2) / ( 2 * (Vp^2 - Vs^2) )' }
				  ]
				},

				{
				  h3: 'Acoustic Impedance',
				  p: `Acoustic impedance is density times compressional velocity and controls reflection/transmission.`,
				  eqs: [
					{ cap: 'Impedance', expr: 'Z = p * Vp' },
					{ cap: 'Transmission loss (concept)', expr: 'L_T ~ 20 * log10( (2 * Z1) / (Z1 + Z2) )' },
					{ cap: 'Reflection loss (concept)', expr: 'L_R ~ 20 * log10( (Z2 - Z1) / (Z1 + Z2) )' }
				  ]
				},

				{
				  h3: 'Clay Content',
				  p: `Clay content influences electrical properties via cation exchange capacity (CEC), often enhancing electrokinetic coupling in clay-rich formations.`,
				  eqs: [{ cap: 'CEC indicator', expr: 'CEC ~ f(clay_percent)   // higher clay% -> higher CEC' }]
				},

				{
				  h3: 'Frenzel Radius',
				  p: `Frenzel radius rF is a conceptual radius concentrating seismic energy around a source and scales with wavelength.`,
				  eqs: [{ cap: 'Frenzel radius', expr: 'rF ~ O(lambda)' }]
				},

				{
				  h3: 'Standard Penetration Test Number (SPTN)',
				  p: `SPTN is the number of blows to drive a sampler 30 cm; corrected SPT (N60) accounts for energy, borehole diameter, rod length, and sampler corrections.`,
				  eqs: [{ cap: 'Corrected SPT', expr: 'N60 = N * CE * CB * CR * CS' }],
				  table: {
					title: 'SPTN – Soil Packing / Relative Density',
					head: ['SPTN', 'Soil Packing', 'Relative Density (%)'],
					rows: [
					  ['< 4', 'Very Loose', '< 20'],
					  ['4 - 10', 'Loose', '20 - 40'],
					  ['10 - 30', 'Compact', '40 - 60'],
					  ['30 - 50', 'Dense', '60 - 80'],
					  ['> 50', 'Very Dense', '> 80']
					]
				  }
				},

				{
				  h3: 'Rock Quality Designation (RQD)',
				  p: `RQD is the percent of intact core pieces >= 10 cm over total core run, indicating rock mass quality.`,
				  eqs: [{ cap: 'RQD', expr: 'RQD_percent = 100 * ( sum(lengths >= 10 cm) / core_run_length )' }],
				  table: {
					title: 'RQD – Rock Mass Quality',
					head: ['RQD (%)', 'Rock mass quality'],
					rows: [
					  ['< 25%', 'Very poor'],
					  ['25 - 50%', 'Poor'],
					  ['50 - 75%', 'Fair'],
					  ['75 - 90%', 'Good'],
					  ['90 - 100%', 'Excellent']
					]
				  }
				},

				{
				  h3: 'Micro Fracturing',
				  p: `Micro-fractures reduce acoustic velocities at low pressure; they close progressively with confining pressure.`,
				  eqs: [
					{ cap: 'Velocity–pressure trend (schematic)', expr: 'Vp(P) ~ V0 - Vdif + Kv * (P - P0)   // non-linear at low P until micro-fractures close' }
				  ]
				},

				{
				  h3: 'Fracture Flow',
				  p: `Flow through fractures is often approximated by the cubic law:`,
				  eqs: [
					{ cap: 'Cubic law', expr: 'Q = ( b^3 / (12 * eta) ) * ( DeltaP / L ) * W   // b: aperture; W: width; L: length; eta: viscosity' }
				  ]
				},

				{
				  h3: 'Compressional Velocity',
				  p: `Kinematic definition and elastic relation:`,
				  eqs: [
					{ cap: 'Kinematics', expr: 'Vc = Delta_x / Delta_t' },
					{ cap: 'Elastic relation', expr: 'Vp = sqrt( (K + 4 * G / 3) / p )' }
				  ]
				},

				{
				  h3: 'Shear Velocity',
				  p: `Kinematic definition and elastic relation:`,
				  eqs: [
					{ cap: 'Kinematics', expr: 'Vs = Delta_x / Delta_t' },
					{ cap: 'Elastic relation', expr: 'Vs = sqrt( G / p )' }
				  ]
				},

				/* ---------------------------- Interpretations ---------------------------- */
				{
				  h3: 'Interpretations (AI-Assisted)',
				  p: `AI methods interpret geohydrological and geotechnical indicators to estimate lithology and aquifer type or condition.`
				},

				{
				  h3: 'Interpreted Lithology (Formation Type)',
				  p: `Lithology is interpreted from estimated geotechnical properties and compared against averaged rock-property databases.`,
				  table: {
					title: 'Lithology Descriptors',
					head: ['Lithology', 'Descriptor'],
					rows: [
					  ['Soil', 'SL'],
					  ['Unconsolidated Sediment', 'US'],
					  ['Volcanics', 'VO'],
					  ['Conglomerates', 'CO'],
					  ['Consolidated Sediments', 'CS'],
					  ['Igneous', 'IG'],
					  ['Salt', 'ST'],
					  ['Mafic', 'MA'],
					  ['Metamorphic', 'ME'],
					  ['Ultra Mafic', 'UM']
					]
				  }
				},

				{
				  h3: 'Condition',
				  p: `Formation condition classes inferred from geotechnical indicators and literature references:`,
				  table: {
					title: 'Condition Descriptors',
					head: ['Condition', 'Descriptor(s)'],
					rows: [
					  ['Soil', '1'],
					  ['Fine grained', '2'],
					  ['Coarse grained', '3'],
					  ['Fractured', '4-6-8-10-12-14'],
					  ['Porous', '5'],
					  ['Weathered', '5-7-9-11-13-15'],
					  ['Unaltered', '16']
					]
				  }
				},

				{
				  h3: 'Interpreted Aquifer Classification (Aquifer Type)',
				  p: `Aquifer types are interpreted from combined geohydrological and lithological properties at the sounding location.`,
				  table: {
					title: 'Aquifer Classification Descriptors',
					head: ['Aquifer Class', 'Descriptor'],
					rows: [
					  ['Ultra-Mafic Rock Aquifer', 'UM'],
					  ['Fractured Ultra Mafic Rock Aquifer', 'FU'],
					  ['Metamorphic Rock Aquifer', 'MP'],
					  ['Fractured Metamorphic Rock Aquifer', 'FP'],
					  ['Weathered Mafic Rock Aquifer', 'WM'],
					  ['Fractured Mafic Rock Aquifer', 'FM'],
					  ['Weathered Igneous Rock Aquifer', 'WI'],
					  ['Fractured Igneous Rock Aquifer', 'FI'],
					  ['Conglomerate Aquifer', 'CA'],
					  ['Fractured Conglomerate Aquifer', 'FC'],
					  ['Volcanic Rock Aquifer', 'VA'],
					  ['Fractured Volcanic Rock Aquifer', 'FV'],
					  ['Sedimentary Rock Aquifer', 'SR'],
					  ['Fractured Sedimentary Rock Aquifer', 'FS'],
					  ['Unconsolidated Dual Porosity Sedimentary Aquifer', 'DP'],
					  ['Unconsolidated Sedimentary Aquifer', 'SA'],
					  ['Saturated Soil Aquifer', 'SS']
					]
				  }
				},

				{
				  h3: 'Aquifer Types',
				  p: `Unconfined, confined, perched, and artesian aquifers produce distinct seismo-electric responses based on pressure distribution and connectivity.`,
				  bullets: [
					'Unconfined: water table open to atmosphere; signals reflect porosity/permeability and delineate the water table.',
					'Confined: bounded by aquitards with water under pressure; typically stronger signals (higher pressure gradients).',
					'Perched: localized saturation above the main water table; produces localized anomalies.',
					'Artesian: elevated head in confined settings; often high-amplitude, rapid-rise responses.'
				  ]
				},

				/* ---------------------------- Electric Parameter ---------------------------- */
				{
				  h3: 'Apparent Resistivity',
				  p: `Electrical resistivity characterizes resistance to current (ohm meter).`,
				  eqs: [
					{ cap: 'Apparent resistivity', expr: 'rho_e = R * (A / L)   // R: resistance; A: area; L: length' }
				  ]
				},

				/* ---------------------------- GIS Parameters (added) ---------------------------- */
				{
				  h3: 'GIS Parameters',
				  p: `Global GIS data sets provide generalized context around an investigation site. They are not used in quantitative evaluation or interpretation of the seismo-electric, geohydrological, geological, or geotechnical data; instead they give regional context for findings and recommendations.`
				},
				{
				  h3: 'Satellite Imagery',
				  p: `Used to assess survey locations relative to infrastructure, dams, rivers, coastlines, mountains, and similar features. The map shows survey points with labels and recommended drilling locations ranked by index. A control can show only recommended points. Map and survey-point data can be downloaded. Mouse-hover coordinates (WGS84 decimal degrees) appear at top right; a scale bar appears at bottom right. When a survey point is selected, a popup shows point number, recommendation index, latitude and longitude, elevation (masl), sustainable, maximum, and minimum yield estimates (L/s) for the user-defined depth range, static groundwater level (mbgl), recommended maximum drilling depth (mbgl), overall risk percentage, confidence, correlation, and signal-to-noise ratio.`
				},
				{
				  h3: 'Lithology (GIS Layer)',
				  p: `Shows surface lithology around the survey area to indicate the basic lithology at survey points. Points and recommended drilling indices are labeled; a scale bar is shown.`
				},
				{
				  h3: 'Faulting',
				  p: `Shows survey locations relative to regional fault structures beneath the area. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				},
				{
				  h3: 'Water Shed',
				  p: `Shows watershed boundaries around the survey area to indicate natural groundwater flow directions. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				},
				{
				  h3: 'Regional Aquifer Classification (GIS)',
				  p: `Shows survey locations relative to known aquifers surrounding the area to provide a qualitative indication of possible aquifer quality. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				},
				{
				  h3: 'Static Groundwater Level (GIS)',
				  p: `Shows survey locations relative to static groundwater levels around the area to give context on potential water table depths. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				},
				{
				  h3: 'Saline Aquifers (GIS)',
				  p: `Gives insight into the possibility of saline aquifers in the area around the survey site. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				},
				{
				  h3: 'Geothermal Resources (GIS)',
				  p: `Provides insight into geothermal resources beneath and around the survey site and whether the area has potential for geothermal formations or overlaps known geothermal fields. Recommended drilling locations are labeled and ranked; a scale bar is shown.`
				}
			  ]
			};

			function makeTypesetHelpers(pdf){
			  const M = 12;
			  const PAGE_W = pdf.internal.pageSize.getWidth();
			  const PAGE_H = pdf.internal.pageSize.getHeight();

			  // Single font family everywhere: helvetica
			  const S = {
				h2: { font:'helvetica', style:'bold',   size:12, gap:4 },
				h3: { font:'helvetica', style:'bold',   size:10, gap:3 },
				p:  { font:'helvetica', style:'normal', size:8,  lh:3.6, gap:2 },
				// Eq helper (kept Helvetica + centered)
				eq: { font:'helvetica', style:'italic', size:8,  lh:3.4, padV:2.6, padH:3 }
			  };

			  // --- sanitize helpers ---
			  const CTRL_RE = /[\u0000-\u001F\u007F]/g;
			  const ZW_RE   = /[\u200B-\u200D\u2060\uFEFF]/g;
			  const NBSP_RE = /\u00A0/g;
			  const MULTI_SPACE_RE = /[ \t]{2,}/g;

			  // SIMPLIFIED sanitize function - preserve all characters as-is
			  function sanitize(text){
				let s = String(text ?? '');
				// Only remove control characters and excessive whitespace
				s = s.replace(CTRL_RE, '')
					 .replace(ZW_RE, '')
					 .replace(NBSP_RE, ' ')
					 .replace(MULTI_SPACE_RE, ' ')
					 .trim();
				return s;
			  }

			  // Always zero out char & word spacing before any text draw
			  function zeroSpacing(){
				if (typeof pdf.setCharSpace === 'function') pdf.setCharSpace(0);
				if (typeof pdf.setWordSpacing === 'function') pdf.setWordSpacing(0);
			  }

			  function ensure(y, need){
				if (y + need > PAGE_H - M){ pdf.addPage(); return M; }
				return y;
			  }
			  function setFont({font,style,size}){ pdf.setFont(font, style); pdf.setFontSize(size); zeroSpacing(); }
			  function textWidth(t){ zeroSpacing(); return pdf.getTextWidth(String(t||'')); }
			  function wrap(text, maxW){ 
				// Use the raw text without excessive sanitization
				const cleanText = String(text ?? '').replace(CTRL_RE, '').replace(ZW_RE, '').trim();
				return pdf.splitTextToSize(cleanText, maxW); 
			  }

			  function H2(label, y){
				// Left-justified heading
				setFont(S.h2);
				y = ensure(y, S.h2.size + S.h2.gap + 2);
				pdf.setTextColor(20);
				const clean = sanitize(label);
				zeroSpacing(); 
				pdf.text(clean, M, y);
				// underline
				pdf.setDrawColor(220); pdf.setLineWidth(0.3);
				const w = Math.min(textWidth(clean), PAGE_W - 2*M);
				pdf.line(M, y + 1.8, M + w, y + 1.8);
				return y + S.h2.gap + 2.4;
			  }
			  function H3(label, y){
				// Left-justified subheading
				setFont(S.h3);
				y = ensure(y, S.h3.size + S.h3.gap);
				pdf.setTextColor(40);
				zeroSpacing(); 
				pdf.text(sanitize(label), M, y);
				return y + S.h3.gap + 1;
			  }
			  function P(text, y){
				// Left-justified body text at 8pt
				setFont(S.p);
				pdf.setTextColor(30);
				const maxW = PAGE_W - 2*M;
				const lines = wrap(text, maxW);
				const need = lines.length * S.p.lh + S.p.gap;
				y = ensure(y, need);
				lines.forEach((ln,i)=> { 
				  zeroSpacing(); 
				  pdf.text(ln, M, y + i*S.p.lh); 
				});
				return y + lines.length * S.p.lh + S.p.gap;
			  }
			  function Bullet(items, y){
				// Left-justified bullets at 8pt
				setFont(S.p);
				pdf.setTextColor(30);
				const maxW = PAGE_W - 2*M - 4;
				for (const itRaw of items){
				  const it = sanitize(itRaw);
				  const lines = wrap(it, maxW);
				  y = ensure(y, lines.length * S.p.lh + 1.2);
				  pdf.circle(M + 1.2, y - 1.1, 0.6, 'F');
				  lines.forEach((ln,i)=> { 
					zeroSpacing(); 
					pdf.text(ln, M + 4, y + i*S.p.lh); 
				  });
				  y += lines.length * S.p.lh + 1.2;
				}
				return y + 0.8;
			  }
			  function Eq(label, expr, y){
				// Caption (left), equation centered, helvetica only
				if (label){
				  pdf.setFont('helvetica','italic'); pdf.setFontSize(8); zeroSpacing();
				  pdf.setTextColor(90);
				  y = ensure(y, 6);
				  pdf.text(sanitize(label), M, y);
				  y += 2.2;
				}
				pdf.setFont(S.eq.font, S.eq.style); pdf.setFontSize(S.eq.size); zeroSpacing();
				pdf.setTextColor(15);
				const maxW = PAGE_W - 2*M - 2*S.eq.padH;
				const lines = wrap(expr, maxW);
				const need = lines.length * S.eq.lh + 2;
				y = ensure(y, need);
				// Manual centering per line (no align option → no injected spacing)
				lines.forEach((ln, i) => {
				  const lw = pdf.getTextWidth(ln);
				  const x = M + Math.max(0, (PAGE_W - 2*M - lw) / 2);
				  zeroSpacing(); 
				  pdf.text(ln, x, y + i*S.eq.lh);
				});
				return y + lines.length * S.eq.lh + 1.5;
			  }
			  function Rule(y){ pdf.setDrawColor(230); pdf.setLineWidth(0.3); pdf.line(M, y, PAGE_W - M, y); return y + 2; }

			  function Table({title, head, rows}, y){
				if (title){
				  pdf.setFont('helvetica','bold'); pdf.setFontSize(10); zeroSpacing();
				  pdf.setTextColor(40);
				  y = ensure(y, 10); pdf.text(sanitize(title), M, y); y += 3;
				}
				const cleanHead = (head||[]).map(h => sanitize(h));
				const cleanRows = (rows||[]).map(r => r.map(c => sanitize(c)));
				pdf.autoTable({
				  startY: y,
				  margin: { left: M, right: M, top: 0, bottom: 0 },
				  head: [cleanHead],
				  body: cleanRows,
				  styles: { font: 'helvetica', fontSize: 8, cellPadding: 1.4, lineColor:[220,225,235], lineWidth:0.2, valign:'middle' },
				  headStyles: { fillColor:[47,111,237], textColor:255, fontStyle:'bold' },
				  alternateRowStyles: { fillColor:[248,250,253] },
				  theme: 'grid',
				  tableWidth: 'auto',
				  pageBreak: 'avoid',
				  rowPageBreak: 'avoid'
				});
				return (pdf.lastAutoTable?.finalY ?? y) + 4;
			  }

			  return { M, PAGE_W, PAGE_H, H2, H3, P, Bullet, Eq, Table, Rule, ensure, sanitize };
			}


			/* ================== Professional Data Description Renderer (single font, centered equations) ================== */
			function renderDataDescriptionSection(pdf, yStart) {
			  // Always start on a new page
			  pdf.addPage();
			  const M = 12;
			  const PAGE_W = pdf.internal.pageSize.getWidth();
			  const PAGE_H = pdf.internal.pageSize.getHeight();
			  let y = M;

			  // Typography (headings can be larger; all other text—including captions & "Where:"—is 8pt)
			  const H2_SIZE = 12;  // left-justified
			  const H3_SIZE = 10;  // left-justified
			  const BODY_SIZE = 8; // all non-heading text
			  const EQ_SIZE = 8;   // equations at 8pt
			  const CAP_SIZE = 8;  // captions & "Where:" labels at 8pt
			  const LINE_H = 3.6;
			  const GAP_S = 3;
			  const GAP_M = 5;
			  const GAP_L = 8;

			  // Minimal sanitizer - preserve all characters as-is
			  const CTRL_RE = /[\u0000-\u001F\u007F]/g;
			  const ZW_RE   = /[\u200B-\u200D\u2060\uFEFF]/g;

			  function sanitize(text){
				let s = String(text ?? '');
				// Only remove control characters and zero-width spaces
				s = s.replace(CTRL_RE, '')
					 .replace(ZW_RE, '')
					 .trim();
				return s;
			  }

			  function zeroSpacing(){
				if (typeof pdf.setCharSpace === 'function') pdf.setCharSpace(0);
				if (typeof pdf.setWordSpacing === 'function') pdf.setWordSpacing(0);
			  }

			  function ensure(need) {
				if (y + need > PAGE_H - M) { pdf.addPage(); y = M; }
			  }
			  
			  function textWrap(str, maxW) {
				// Use minimal sanitization to preserve mathematical symbols
				const cleanStr = sanitize(String(str || ''));
				const lines = pdf.splitTextToSize(cleanStr, maxW);
				return Array.isArray(lines) ? lines : [cleanStr];
			  }
			  
			  function drawPara(str) {
				if (!str) return;
				pdf.setFont('helvetica','normal'); 
				pdf.setFontSize(BODY_SIZE); 
				zeroSpacing();
				pdf.setTextColor(30);
				const lines = textWrap(str, PAGE_W - 2*M);
				ensure(lines.length * LINE_H + GAP_S);
				lines.forEach(line => { 
				  zeroSpacing(); 
				  pdf.text(line, M, y); 
				  y += LINE_H; 
				});
				y += GAP_S;
			  }
			  
			  function drawH2(title) {
				pdf.setFont('helvetica','bold'); 
				pdf.setFontSize(H2_SIZE); 
				zeroSpacing();
				pdf.setTextColor(20);
				ensure(GAP_M + 6);
				const clean = sanitize(title);
				zeroSpacing(); 
				pdf.text(clean, M, y);
				pdf.setDrawColor(210); 
				pdf.setLineWidth(0.4);
				const w = Math.min(pdf.getTextWidth(clean), PAGE_W - 2*M);
				pdf.line(M, y + 1.6, M + w, y + 1.6);
				y += GAP_L;
			  }
			  
			  function drawH3(sub) {
				pdf.setFont('helvetica','bold'); 
				pdf.setFontSize(H3_SIZE); 
				zeroSpacing();
				pdf.setTextColor(40);
				ensure(GAP_M + 4);
				zeroSpacing(); 
				pdf.text(sanitize(sub), M, y);
				y += GAP_S;
				pdf.setDrawColor(210); 
				pdf.setLineWidth(0.4);
				pdf.line(M, y, PAGE_W - M, y);
				y += GAP_M;
			  }

			  // --- "Where:" table (8pt, single font, left-justified) ---
			  function drawWhereTable(vars) {
				if (!vars || !vars.length) return;

				pdf.setFont('helvetica','bold'); 
				pdf.setFontSize(CAP_SIZE); 
				zeroSpacing();
				pdf.setTextColor(30);
				ensure(LINE_H);
				zeroSpacing(); 
				pdf.text('Where:', M, y);
				y += LINE_H;

				const rows = vars.map(v => [sanitize(v.sym || ''), sanitize(v.desc || '')]);
				const startY = y;

				pdf.autoTable({
				  startY,
				  margin: { left: M, right: M, top: M, bottom: M },
				  theme: 'plain',
				  head: [['Symbol', 'Description']],
				  body: rows,
				  styles: {
					font: 'helvetica',
					fontSize: 8,
					cellPadding: 2.0,
					overflow: 'linebreak',
					valign: 'top',
					textColor: [30,30,30],
					lineColor: [225, 228, 235],
					lineWidth: 0.2
				  },
				  headStyles: {
					fontStyle: 'bold',
					fillColor: [250, 250, 250],
					textColor: [60, 60, 60],
					lineWidth: 0.2,
					lineColor: [210, 210, 210]
				  },
				  bodyStyles: {
					lineWidth: 0.2,
					lineColor: [225, 228, 235]
				  },
				  columnStyles: {
					0: { cellWidth: 28, halign: 'left' },
					1: { cellWidth: 'auto', halign: 'left' }
				  },
				  pageBreak: 'avoid',
				  rowPageBreak: 'avoid',
				  tableWidth: 'wrap'
				});

				y = (pdf.lastAutoTable?.finalY ?? pdf.autoTable.previous.finalY) + GAP_M;
			  }

			  // --- Simple equation parser ---
			  function parseEquation(clean) {
				const ix = clean.indexOf('//');
				const eq = ix >= 0 ? clean.slice(0, ix).trim() : clean.trim();
				const defs = ix >= 0 ? clean.slice(ix + 2).trim() : '';
				const vars = [];
				
				if (defs) {
				  const parts = defs.split(';').flatMap(p => p.split(','));
				  parts.forEach(p => {
					const seg = sanitize(p);
					if (!seg) return;
					const cix = seg.indexOf(':');
					if (cix > 0) {
					  const sym = seg.slice(0, cix).trim();
					  const desc = seg.slice(cix + 1).trim();
					  if (sym) vars.push({ sym, desc });
					} else {
					  const m = seg.match(/^([^\s]+)\s+(.*)$/);
					  if (m) vars.push({ sym: m[1], desc: m[2] });
					  else vars.push({ sym: seg, desc: '' });
					}
				  });
				}
				return { eq, vars };
			  }

			  // --- Equations: manual centering with preserved symbols ---
			  function drawEquationBlock(item) {
				const capRaw = item?.cap;
				const exprRaw = item?.expr;
				if (!exprRaw) return;

				// Use minimal sanitization to preserve mathematical symbols
				const s = sanitize(exprRaw);
				const cap = capRaw ? sanitize(capRaw) : '';

				const { eq, vars } = parseEquation(s);

				// Caption (left, 8pt)
				if (cap) {
				  pdf.setFont('helvetica','bold'); 
				  pdf.setFontSize(BODY_SIZE); 
				  zeroSpacing();
				  pdf.setTextColor(30);
				  const capLines = textWrap(cap, PAGE_W - 2*M);
				  ensure(capLines.length * (LINE_H) + 1);
				  capLines.forEach(line => { 
					zeroSpacing(); 
					pdf.text(line, M, y); 
					y += LINE_H; 
				  });
				  y += 1;
				}

				// Equation, centered manually; Helvetica italic 8pt; zero spacing
				pdf.setFont('helvetica','italic'); 
				pdf.setFontSize(EQ_SIZE); 
				zeroSpacing();
				pdf.setTextColor(15);
				const eqLines = textWrap(eq, PAGE_W - 2*M);
				ensure(eqLines.length * LINE_H + GAP_S);
				eqLines.forEach((ln, i) => {
				  const lw = pdf.getTextWidth(ln);
				  const x = M + Math.max(0, (PAGE_W - 2*M - lw) / 2);
				  zeroSpacing(); 
				  pdf.text(ln, x, y + i*LINE_H);
				});
				y += eqLines.length * LINE_H;

				// Where table beneath
				if (vars.length) {
				  drawWhereTable(vars);
				} else {
				  y += GAP_M;
				}
			  }

			  // --- Tables for this section (8pt) ---
			  function drawTable(tbl) {
				if (!tbl || !Array.isArray(tbl.rows) || !tbl.rows.length) return;
				const title = tbl.title || 'Table';

				pdf.setFont('helvetica','bold'); 
				pdf.setFontSize(H3_SIZE); 
				zeroSpacing();
				pdf.setTextColor(40);
				const tLines = textWrap(sanitize(title), PAGE_W - 2*M);
				ensure(tLines.length * LINE_H + GAP_S);
				tLines.forEach(line => { 
				  zeroSpacing(); 
				  pdf.text(line, M, y); 
				  y += LINE_H; 
				});
				y += 1.5;

				const cleanRows = tbl.rows.map(r => r.map(c => sanitize(c)));
				const cleanHead = (tbl.head || []).map(h => sanitize(h));

				const startY = y;
				pdf.autoTable({
				  startY,
				  margin: { left: M, right: M, top: M, bottom: M },
				  theme: 'grid',
				  head: [cleanHead],
				  body: cleanRows,
				  styles: { 
					font: 'helvetica', 
					fontSize: 8, 
					cellPadding: 2.0, 
					overflow: 'linebreak', 
					minCellHeight: 6, 
					lineColor: [220,225,235], 
					lineWidth: 0.2, 
					textColor:[30,30,30] 
				  },
				  headStyles: { 
					fillColor: [47,111,237], 
					textColor: 255, 
					halign: 'center', 
					valign: 'middle', 
					fontStyle: 'bold' 
				  },
				  bodyStyles: { valign: 'top' },
				  alternateRowStyles: { fillColor: [248,250,253] },
				  tableWidth: 'wrap',
				  pageBreak: 'avoid',
				  rowPageBreak: 'avoid'
				});
				y = (pdf.lastAutoTable?.finalY ?? pdf.autoTable.previous.finalY) + GAP_M;
			  }

			  // --- bullets (8pt, left-justified) ---
			  function drawBullets(arr) {
				if (!Array.isArray(arr) || !arr.length) return;
				pdf.setFont('helvetica','normal'); 
				pdf.setFontSize(BODY_SIZE); 
				zeroSpacing();
				pdf.setTextColor(30);
				const maxW = PAGE_W - 2*M - 6;
				arr.forEach(text => {
				  const lines = textWrap(text, maxW);
				  ensure(lines.length * LINE_H);
				  zeroSpacing(); 
				  pdf.text('•', M, y);
				  lines.forEach((ln, i) => {
					zeroSpacing(); 
					pdf.text(ln, M + 6, y);
					y += LINE_H;
				  });
				  y += 1;
				});
				y += GAP_S;
			  }

			  // --- main runner ---
			  drawH2('Data Description');

			  if (!window.DD && typeof DD === 'undefined') {
				pdf.setFont('helvetica','italic'); 
				pdf.setFontSize(BODY_SIZE); 
				zeroSpacing();
				pdf.setTextColor(30);
				pdf.text('Data Description content (DD) not found.', M, y);
				return y + GAP_L;
			  }
			  const content = window.DD || DD;

			  (content.sections || []).forEach(sec => {
				if (sec.h3) drawH3(sec.h3);

				// paragraphs p / p2 / p3...
				['p','p2','p3'].forEach(k => { if (sec[k]) drawPara(sec[k]); });

				// equations groups (centered, manual)
				(sec.eqs || []).forEach(drawEquationBlock);
				(sec.eqs2 || []).forEach(drawEquationBlock);

				// bullets
				if (sec.bullets) drawBullets(sec.bullets);

				// tables
				if (sec.table) drawTable(sec.table);
			  });

			  return y;
			}
	
			document.addEventListener('DOMContentLoaded', function () {
			  const header =
				document.querySelector('.header, #header, #pageHeader, .topbar, #topbar') ||
				document.querySelector('header') ||
				document.body;

			  if (!header || document.getElementById('createPdfBtn')) return;

			  const btn = document.createElement('button');
			  btn.id = 'createPdfBtn';
			  btn.type = 'button';
			  btn.textContent = 'Create PDF & Word';
			  btn.style.cssText =
				'margin-left:12px;padding:10px 18px;border-radius:8px;border:none;cursor:pointer;background:#2f6fed;color:#fff;font-size:14px;box-shadow:0 2px 5px rgba(0,0,0,.2)';
			  btn.addEventListener('click', () =>
				(typeof window.generateReports === 'function'
				  ? window.generateReports()
				  : alert('The report generator is not loaded yet.'))
			  );

			  const wrapper = document.createElement('div');
			  wrapper.style.marginLeft = 'auto';
			  wrapper.appendChild(btn);
			  const isFlex = window.getComputedStyle(header).display.includes('flex');
			  header.appendChild(isFlex ? wrapper : btn);
			});

			/* ---------------- Wait overlay ---------------- */
			function ensureWaitOverlay() {
			  let el = document.getElementById('waitOverlay');
			  if (!el) {
				el = document.createElement('div');
				el.id = 'waitOverlay';
				el.innerHTML = `
				  <div class="wait-card" role="alert" aria-live="polite" aria-busy="true">
					<div class="spinner" role="progressbar" aria-label="Generating report"></div>
					<div class="wait-msg" id="waitMsg">Generating report…</div>
					<div class="progress"><i></i></div>
				  </div>
				  <style>
					#waitOverlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(255,255,255,.92);backdrop-filter:blur(2px);z-index:2147483647}
					.wait-card{background:#fff;padding:22px 26px;border-radius:12px;box-shadow:0 12px 40px rgba(0,0,0,.18);display:flex;flex-direction:column;align-items:center;gap:10px;min-width:240px;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
					.spinner{width:48px;height:48px;border-radius:50%;border:4px solid #e6e9ef;border-top-color:#2f6fed;animation:spin 1s linear infinite}
					@keyframes spin{to{transform:rotate(360deg)}}
					.progress{width:180px;height:4px;background:#eef2ff;border-radius:999px;overflow:hidden}
					.progress i{display:block;width:35%;height:100%;background:#2f6fed;animation:prog 1.6s ease-in-out infinite}
					@keyframes prog{0%{transform:translateX(-120%)}50%{transform:translateX(60%)}100%{transform:translateX(240%)}}
				  </style>
				`;
				document.body.appendChild(el);
			  }
			  return el;
			}
			function setWaitMessage(msg){ const m = document.getElementById('waitMsg'); if (m && msg) m.textContent = msg; }
			function showWait(msg){ const el = ensureWaitOverlay(); setWaitMessage(msg || 'Working…'); el.style.display = 'flex'; document.body.style.cursor = 'progress'; }
			function hideWait(){ const el = document.getElementById('waitOverlay'); if (el) el.style.display = 'none'; document.body.style.cursor = ''; }

			/* ---------------- Utilities ---------------- */
			async function loadScriptOnce(src) {
			  return new Promise((resolve, reject) => {
				if ([...document.scripts].some(s => s.src === src)) return resolve();
				const el = document.createElement('script');
				el.src = src;
				el.onload = resolve;
				el.onerror = reject;
				document.head.appendChild(el);
			  });
			}
			function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

			/* ------- Canvas + image helpers (size-safe) ------- */
			function downscaleCanvasIfNeeded(canvas, maxPixels = 2_000_000) {
			  if (!canvas || canvas.width <= 0 || canvas.height <= 0) return canvas;
			  const px = canvas.width * canvas.height;
			  if (px <= maxPixels) return canvas;
			  const scale = Math.sqrt(maxPixels / px) || 1;
			  const w = Math.max(1, Math.floor(canvas.width * scale));
			  const h = Math.max(1, Math.floor(canvas.height * scale));
			  const off = document.createElement('canvas');
			  off.width = w; off.height = h;
			  const ctx = off.getContext('2d');
			  ctx.imageSmoothingEnabled = true;
			  ctx.imageSmoothingQuality = 'high';
			  ctx.drawImage(canvas, 0, 0, w, h);
			  return off;
			}
			function canvasToDataUrlSafe(canvas, type = 'image/jpeg', quality = 0.85, maxPixels = 2_000_000, maxLen = 20_000_000) {
			  const scaled = downscaleCanvasIfNeeded(canvas, maxPixels);
			  if (!scaled) return null;
			  let url = scaled.toDataURL(type, quality);
			  if (url && url.length > maxLen && quality > 0.5) {
				url = scaled.toDataURL(type, 0.6);
			  }
			  return url;
			}

			/* html2canvas snapshot → CANVAS */
			async function snap(el, {scale=1.5, bg='#ffffff'}={}) {
			  if (!el) return null;
			  const canvas = await html2canvas(el, { useCORS:true, allowTaint:false, scale, backgroundColor:bg });
			  return (canvas && canvas.width > 0 && canvas.height > 0) ? canvas : null;
			}

			/* Try to find a legend near a map (→ CANVAS) */
			async function snapLegendAfter(mapId) {
			  const mapEl = document.getElementById(mapId);
			  if (!mapEl) return null;
			  let sib = mapEl.nextElementSibling;
			  while (sib && sib.tagName !== 'FIGURE') sib = sib.nextElementSibling;
			  if (sib) return await snap(sib, { scale: 1.5 });
			  const legend = mapEl.parentElement?.querySelector('.legend, .legend-container, .map-legend, figcaption, .leaflet-control .legend');
			  return legend ? await snap(legend, { scale: 1.5 }) : null;
			}

			/* Plotly → dataURL (bounded) */
			async function snapPlotly(divId, opts={w:1200,h:800}) {
			  const el = document.getElementById(divId);
			  if (!el) return null;
			  try {
				const url = await Plotly.toImage(el, {format:'png', width:opts.w, height:opts.h});
				return url || null;
			  } catch {
				const c = await snap(el, {scale:1.25});
				return c ? canvasToDataUrlSafe(c, 'image/jpeg', 0.85) : null;
			  }
			}

			/* Leaflet map → CANVAS when possible */
			async function snapLeafletMap(divId, {forceHtml=false}={}) {
			  const el = document.getElementById(divId);
			  if (!el) return null;
			  if (!forceHtml && window.leafletImage) {
				try {
				  const mapObj =
					(window[divId] && window[divId]._container?.id === divId) ? window[divId] :
					(() => {
					  const guesses = ['map1','map2','map3','map4','map5','map6','map7','map8','map9','map10','map11','map12'];
					  for (const g of guesses) if (window[g]?._container?.id === divId) return window[g];
					  return null;
					})();
				  if (mapObj) {
					const canvas = await new Promise((res, rej) => {
					  leafletImage(mapObj, (err, c) => err ? rej(err) : res(c));
					});
					return (canvas && canvas.width > 0 && canvas.height > 0) ? canvas : null;
				  }
				} catch {}
			  }
			  return await snap(el, {scale:1.25});
			}

			/* ---------- Safe addImage wrappers ---------- */
			function makeAddImageToPdf(pdfInstance){
			  const MARGIN = 12;
			  function isFinitePos(n){ return Number.isFinite(n) && n > 0; }

			  function getIntrinsicSize(source){
				if (!source) return null;
				if (source instanceof HTMLCanvasElement) return { w: source.width, h: source.height };
				if (typeof source === 'string') {
				  try {
					const p = pdfInstance.getImageProperties(source);
					if (isFinitePos(p.width) && isFinitePos(p.height)) return { w: p.width, h: p.height };
				  } catch {}
				  return { w: 1600, h: 900 }; // fallback guess
				}
				if (source instanceof HTMLImageElement) {
				  const w = source.naturalWidth || source.width;
				  const h = source.naturalHeight || source.height;
				  if (isFinitePos(w) && isFinitePos(h)) return { w, h };
				}
				return null;
			  }

			  function toDataUrlIfNeeded(source){
				if (!source) return null;
				if (typeof source === 'string') return source; // already dataURL
				if (source instanceof HTMLCanvasElement) return canvasToDataUrlSafe(source, 'image/jpeg', 0.85);
				if (source instanceof HTMLImageElement) {
				  const c = document.createElement('canvas');
				  c.width = source.naturalWidth || source.width;
				  c.height = source.naturalHeight || source.height;
				  const ctx = c.getContext('2d');
				  ctx.drawImage(source, 0, 0);
				  return canvasToDataUrlSafe(c, 'image/jpeg', 0.85);
				}
				return null;
			  }

			  function addImageToPdfFit(source, x, y, maxW, maxH, label='image'){
				try{
				  if (!source) return 0;
				  const PAGE_W = pdfInstance.internal.pageSize.getWidth();
				  const usableW = Number.isFinite(maxW) ? maxW : (PAGE_W - 2*MARGIN);
				  let { w:iw, h:ih } = getIntrinsicSize(source) || {};
				  if (!(isFinitePos(iw) && isFinitePos(ih))) { console.warn('[PDF] bad intrinsic size for', label); return 0; }
				  const r = ih / iw;
				  let w = usableW;
				  let h = w * r;
				  if (Number.isFinite(maxH) && h > maxH) { h = maxH; w = h / r; }
				  if (!isFinitePos(w) || !isFinitePos(h)) return 0;
				  const dataUrl = toDataUrlIfNeeded(source);
				  if (!dataUrl) return 0;
				  pdfInstance.addImage(dataUrl, 'JPEG', x, y, w, h);
				  return h;
				}catch(e){
				  console.warn(`[PDF] addImageToPdfFit failed for ${label}`, e);
				  return 0;
				}
			  }

			  function addImageToPdf(source, x=MARGIN, y, maxW=null, label='image') {
				const PAGE_W = pdfInstance.internal.pageSize.getWidth();
				const usableW = (maxW == null) ? (PAGE_W - 2*MARGIN) : maxW;
				return addImageToPdfFit(source, x, y, usableW, null, label);
			  }

			  return { addImageToPdf, addImageToPdfFit, MARGIN };
			}

			/* ---------- Heading helpers ---------- */
			function makeLayoutHelpers(pdf){
			  const M = 12;
			  const PAGE_H = pdf.internal.pageSize.getHeight();
			  const PAGE_W = pdf.internal.pageSize.getWidth();
			  const HEADING_SIZE = 12;
			  const HEADING_GAP = 8;
			  function ensureSpace(y, needed){ if (y + needed > PAGE_H - M) { pdf.addPage(); return M; } return y; }
			  function heading(text, y){ y = ensureSpace(y, HEADING_SIZE + HEADING_GAP + 4); pdf.setFont('helvetica','bold'); pdf.setFontSize(HEADING_SIZE); pdf.text(text, M, y); return y + HEADING_GAP; }
			  function coverTitle(text, subtitle){
				pdf.setFont('helvetica','bold'); pdf.setFontSize(22);
				const cx = PAGE_W/2; let y = M + 20; const width = pdf.getTextWidth(text || '');
				pdf.text(text || '', cx - width/2, y);
				if (subtitle){ pdf.setFont('helvetica','normal'); pdf.setFontSize(12); y += 8; const sw = pdf.getTextWidth(subtitle || ''); pdf.text(subtitle || '', cx - sw/2, y); y += 6; }
				pdf.setDrawColor(200); pdf.setLineWidth(0.4); pdf.line(M, y, PAGE_W - M, y);
				return y + 6;
			  }
			  return { M, PAGE_H, PAGE_W, HEADING_GAP, heading, ensureSpace, coverTitle };
			}

			/* ---------------- Virtual Log helpers ---------------- */
			function getVirtualLogContainer(){ return document.querySelector('#virtualLogTables, .virtual-logs, .virtual-log, #selectedRowData, #selectedRow, .selected-row, .point-details'); }
			function getVirtualLogTablesForCurrentPoint(){
			  const container = getVirtualLogContainer(); if (!container) return [];
			  const list = container.matches('table') ? [container] : [...container.querySelectorAll('table')];
			  return list.filter(t => {
				if (t.closest('#RecdataTable')) return false;
				const looksTrace = t.matches('.trace-1d, .oned-trace, .plotly-1d, .trace, .sparkline') || /\btrace\b/i.test(t.className||'') || /\btrace\b/i.test(t.id||'');
				const cols = (t.querySelectorAll('tr:first-child th, tr:first-child td')||[]).length;
				return !looksTrace && cols >= 2;
			  });
			}
			const VLOG_COLS = [
			  { header:'From (mbgl)', key:'from', width:12 }, { header:'To (mbgl)', key:'to', width:12 },
			  { header:'Lithology', key:'lith', width:28 }, { header:'Aquifer Condition', key:'aq_cond', width:20 },
			  { header:'Min Yield (l/s)', key:'min_y', width:14 }, { header:'Max Yield (l/s)', key:'max_y', width:14 },
			  { header:'Sus Yield (l/s)', key:'sus_y', width:14 }, { header:'Matrix Hydraulic Conductivity (m/d)', key:'k', width:20 },
			  { header:'Density (kg/m3)', key:'rho', width:14 }, { header:'Water Quality (%)', key:'wq', width:14 },
			  { header:'Formation Aquifer Indicator', key:'aq_ind', width:20 }, { header:'Formation Fracturing', key:'fract', width:16 },
			  { header:'SPTN', key:'sptn', width:12 }, { header:'Aquifer Probability (%)', key:'aq_prob', width:16 },
			  { header:'Formation Temperature (degC)', key:'temp', width:16 }, { header:'Aquiclude Probability (%)', key:'aqc_prob', width:16 },
			  { header:'Saturation (%)', key:'sat', width:16 }
			];
			function norm(s){ return String(s||'').toLowerCase().replace(/\(.*?\)/g,'').replace(/[^a-z0-9]+/g,'').trim(); }
			const HEADER_MAP = new Map([
			  ['from','from'],['frommbgl','from'],['startdepth','from'],['fromdepth','from'],
			  ['to','to'],['tombgl','to'],['enddepth','to'],['todepth','to'],
			  ['lithology','lith'],['lith','lith'],['geology','lith'],
			  ['aquifercondition','aq_cond'],['condition','aq_cond'],
			  ['minyield','min_y'],['minyields','min_y'],['minflow','min_y'],['minq','min_y'],
			  ['maxyield','max_y'],['maxyields','max_y'],['maxflow','max_y'],['maxq','max_y'],
			  ['susyield','sus_y'],['sustainableyield','sus_y'],['sustyield','sus_y'],
			  ['matrixhydraulicconductivity','k'],['hydraulicconductivity','k'],['k','k'],['kh','k'],
			  ['density','rho'],['densitykgm3','rho'],['waterquality','wq'],['quality','wq'],['tq','wq'],
			  ['formationaquiferindicator','aq_ind'],['aquiferindicator','aq_ind'],['indicator','aq_ind'],
			  ['formationfracturing','fract'],['fracturing','fract'],['fracture','fract'],
			  ['sptn','sptn'],['spt','sptn'],['nvalue','sptn'],
			  ['aquiferprobability','aq_prob'],['aqprobability','aq_prob'],['aquiferprob','aq_prob'],
			  ['formationtemperature','temp'],['temperature','temp'],['temp','temp'],
			  ['aquicludeprobability','aqc_prob'],['aquicludeprob','aqc_prob'],
			  ['saturation','sat'],['sat','sat']
			]);
			function parseTableToRows(table){
			  const rows = []; if (!table) return rows;
			  const trs = [...table.querySelectorAll('tr')]; if (!trs.length) return rows;
			  let headerCells = [...(trs[0].querySelectorAll('th'))]; let dataStartIdx = 1;
			  if (!headerCells.length) { headerCells = [...(trs[0].querySelectorAll('td'))]; dataStartIdx = 1; }
			  if (!headerCells.length && trs.length > 1){ headerCells = [...(trs[1].querySelectorAll('th,td'))]; dataStartIdx = 2; }
			  if (!headerCells.length) return rows;
			  const colMap = headerCells.map(cell => HEADER_MAP.get(norm(cell.textContent)) || null);
			  for (let r = dataStartIdx; r < trs.length; r++){
				const cells = [...trs[r].querySelectorAll('td,th')];
				if (!cells.length) continue;
				const obj = Object.fromEntries(VLOG_COLS.map(c => [c.key, '']));
				for (let c = 0; c < Math.min(cells.length, colMap.length); c++){
				  const key = colMap[c];
				  if (key) obj[key] = (cells[c].textContent || '').trim();
				}
				if (obj.from || obj.to || obj.lith) rows.push(obj);
			  }
			  return rows;
			}
			function getVirtualLogRows(){
			  const tables = getVirtualLogTablesForCurrentPoint();
			  if (!tables.length) return [];
			  let best = null, scoreBest = -1;
			  for (const t of tables){
				const r = parseTableToRows(t);
				const score = r.length + (r.some(x => x.from || x.to) ? 10 : 0);
				if (score > scoreBest && r.length){ best = r; scoreBest = score; }
			  }
			  if (best) return best;
			  const merged = []; for (const t of tables) merged.push(...parseTableToRows(t));
			  return merged;
			}
			function renderVirtualLogDataLandscape(pdf, pointLabel, rows){
			  if (!rows || !rows.length) return;
			  pdf.addPage({ format: 'a4', orientation: 'landscape' });
			  const M = 10;
			  const pageW = pdf.internal.pageSize.getWidth();
			  const usable = pageW - 2 * M;
			  const columns = VLOG_COLS.map(c => ({ header: c.header, dataKey: c.key }));
			  const totalW = VLOG_COLS.reduce((s, c) => s + c.width, 0);
			  const scale = Math.min(1, usable / totalW);
			  const columnStyles = {};
			  VLOG_COLS.forEach(c => { columnStyles[c.key] = { cellWidth: Math.max(6, +(c.width * scale).toFixed(1)) }; });
			  pdf.setFont('helvetica','bold'); pdf.setFontSize(10); pdf.text(`Virtual Log — ${pointLabel}`, M, M + 2);
			  const numericKeys = new Set(['from','to','min_y','max_y','sus_y','k','rho','wq','sptn','aq_prob','temp','aqc_prob','sat']);
			  pdf.autoTable({
				columns, body: rows, startY: M + 8,
				margin: { top: M, right: M, bottom: M, left: M }, tableWidth: 'wrap', theme: 'grid',
				headStyles: { fontSize: 3, fillColor: [47,111,237], textColor: 255, fontStyle: 'bold', halign: 'center', valign: 'middle' },
				bodyStyles: { fontSize: 2.5, cellPadding: 0.8, lineColor: [220,225,235], lineWidth: 0.2, valign: 'top' },
				alternateRowStyles: { fillColor: [248,250,253] }, styles: { overflow: 'linebreak', minCellHeight: 3.5 },
				columnStyles, pageBreak: 'auto', rowPageBreak: 'auto',
				didParseCell: function (data) { const key = data.column?.dataKey; if (numericKeys.has(key)) data.cell.styles.halign = 'center'; }
			  });
			}

			/* -------------------- MAIN -------------------- */
			async function generateReports() {
			  showWait('Preparing libraries…');
			  try {
				await loadScriptOnce('https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js');
				await loadScriptOnce('https://cdn.jsdelivr.net/npm/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js');
				await loadScriptOnce('https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js');

				const { jsPDF } = window.jspdf;
				const pdf = new jsPDF({ unit:'mm', format:'a4', orientation:'portrait' });
				const { addImageToPdf, addImageToPdfFit } = makeAddImageToPdf(pdf);
				const L = makeLayoutHelpers(pdf);

				const M = 12;
				const PAGE_W = pdf.internal.pageSize.getWidth();
				const PAGE_H = pdf.internal.pageSize.getHeight();
				const gap = 6;
				const ensureRoom = (y, needed) => (y + needed > PAGE_H - M ? (pdf.addPage(), M) : y);

				/* -------- inline definitions -------- */
				function drawDefinitionsBlock(yStart){
				  const usable = PAGE_W - 2*M; let y = yStart;
				  pdf.setFont('helvetica','bold'); pdf.setFontSize(8);
				  if (y > PAGE_H - M - 12) { pdf.addPage(); y = M; }
				  pdf.text('Definitions', M, y); y += 3.5;
				  function drawInlineDef(term, body){
					const label = `${term} – `;
					pdf.setFont('helvetica','bold'); pdf.setFontSize(8);
					const labelW = pdf.getTextWidth(label);
					pdf.setFont('helvetica','normal'); pdf.setFontSize(8);
					const spaceW = pdf.getTextWidth(' ');
					const words = String(body||'').split(/\s+/).filter(Boolean);
					const lines = []; let current = ''; let currentW = 0;
					function pushLine(){ lines.push(current); current=''; currentW=0; }
					for (let i=0;i<words.length;i++){
					  const w = words[i]; const wW = pdf.getTextWidth(w);
					  const limit = (lines.length === 0) ? (usable - labelW) : usable;
					  const extra = current ? (spaceW + wW) : wW;
					  if (currentW + extra <= limit){ current += (current ? ' ' : '') + w; currentW += extra; }
					  else { if (current) pushLine(); current = w; currentW = wW; }
					}
					if (current) pushLine();
					const lineH = 3.5; const needed = lineH * Math.max(1, lines.length);
					if (y + needed > PAGE_H - M) { pdf.addPage(); y = M; }
					pdf.setFont('helvetica','bold'); pdf.setFontSize(8); pdf.text(label, M, y);
					pdf.setFont('helvetica','normal'); pdf.setFontSize(8);
					if (lines.length){ pdf.text(lines[0] || '', M + labelW, y); }
					for (let i=1;i<lines.length;i++){ y += lineH; pdf.text(lines[i], M, y); }
					y += lineH + 1.5;
				  }
				  drawInlineDef('Risk', 'The calculated total risk of attaining the specified point yield parameters indicated in the recommendations table. Risk is defined by the site noise content, data correlation, data signal to noise ratios and number of strikes used in processing.');
				  drawInlineDef('Confidence', 'The calculated measure of confidence in attaining the point specified yield parameters indicated in the recommendations table. Confidence is defined by the area, volume, min and max yield, correlating points and composition of the aquifers detected under the point.');
				  drawInlineDef('Min Yield', 'The estimated minimum yield, in litres per second, the point will produce if drilled to the specified depth. This estimated value is calculated by assuming no fractures or dual porosity formations are intersected under the point and thus represents the lowest calculated yield for the point. All aquifers above the specified static water level or user defined casing depth is excluded from the yield estimation.');
				  drawInlineDef('Max Yield', 'The estimated maximum yield, in litres per second, the point will produce if drilled to the specified depth. This estimated value is calculated by assuming large, extensive, well connected and well developed fractures or dual porosity formations are intersected under the point and thus represents the highest calculated yield for the point. All aquifers above the specified static water level or user defined casing depth is excluded from the yield estimation.');
				  drawInlineDef('Sustainable Yield', 'The estimated sustainable yield, in litres per second, the point should produce if drilled to the specified depth. All aquifers above the specified static water level or user defined casing depth is excluded from the yield estimation. This value is calculated by applying the area, volume, composition, min and max yield, risk and confidence parameters for the aquifers indicated to be intersected by the point, to estimate what the sustainable yield of the points will be. This value includes both the local and wide area aquifers sustainable yield estimates, within the specified yield influence radius, to provide the most realistic estimate for sustainable yield at any given point location. The sustainable yield value specified in the recommendations table, is a calculated estimate for sustainable yield a point will produce. As such, the estimated sustainable yield, specified on the recommendations table, is subject to variation from the true sustainable yield encountered at the point. The true sustainable yield encountered at the point can and may vary between the specified estimated minimum and maximum yield values for the point.');
				  drawInlineDef('Rec Drill Depth', 'The maximum depth to which a recommended point should be drilled.');
				  drawInlineDef('Vert. Res', 'The maximum calculated vertical resolution of interpreted geological interface depths.');
				  drawInlineDef('Uncertainty', 'The maximum calculated uncertainty of the interpreted geological interface depths.');
				  return y;
				}

				/* ---------------- 1) COVER ---------------- */
				setWaitMessage('Capturing cover…');
				let y = M;
				const headerEl = document.querySelector('.header');
				const headerShot = headerEl ? await snap(headerEl) : null;
				//if (headerShot) { y += addImageToPdf(headerShot, M, y, PAGE_W-2*M, 'header') + gap; }

				pdf.setFont('helvetica','bold'); pdf.setFontSize(20);
				pdf.text('GeoVue Report', M, y); y += 10;

				const execEl = document.querySelector('#executiveSummary, .exec-summary, .summary, .desccontent');
				if (execEl) {
				  const shot = await snap(execEl);
				  if (shot) { y = ensureRoom(y, 60); y += addImageToPdf(shot, M, y, PAGE_W-2*M, 'executive summary') + gap; }
				}
				const termsEl = document.querySelector('.disclaimer-box');
				if (termsEl) {
				  const shot = await snap(termsEl);
				  if (shot) { y = ensureRoom(y, 50); y += addImageToPdf(shot, M, y, PAGE_W-2*M, 'terms') + gap; }
				}

				/* ---------------- 2) SITE MAP + SURVEY POINTS + RECOMMENDATIONS ---------------- */
			setWaitMessage('Capturing site map & survey points…');
			pdf.addPage(); y = M;
			pdf.setFont('helvetica','bold'); pdf.setFontSize(12); pdf.text('Survey Site Map', M, y); y += 6;

			const siteMapCanvas = await snapLeafletMap('map1', { forceHtml:true });
			if (siteMapCanvas) {
			  y += addImageToPdf(siteMapCanvas, M, y, PAGE_W-2*M, 'site map') + gap;
			}

			/* --- NEW: Survey Points table directly under the map --- */
			const surveyHost = document.getElementById('dataTable');
			const surveyTable = surveyHost ? surveyHost.querySelector('table') : null;

			if (surveyTable) {
			  pdf.setFont('helvetica','bold'); pdf.setFontSize(12); pdf.text('Survey Points', M, y); y += 6;
			  pdf.autoTable({
				html: surveyTable,
				startY: y,
				margin: { left: M, right: M },
				styles: { fontSize: 6, cellPadding: 1 },
				pageBreak: 'auto',
				rowPageBreak: 'auto',
				headStyles: { fillColor:[47,111,237], textColor:255, fontStyle:'bold' }
			  });
			  y = (pdf.lastAutoTable?.finalY ?? pdf.autoTable.previous.finalY) + gap;
			} else if (surveyHost) {
			  // Fallback snapshot if the table hasn't rendered as an HTML <table> yet
			  const snapSurvey = await snap(surveyHost, { scale: 1.25 });
			  if (snapSurvey) { y = ensureRoom(y, 40); y += addImageToPdf(snapSurvey, M, y, PAGE_W-2*M, 'survey points') + gap; }
			}

			/* --- Force page break before Recommended Points table --- */
			pdf.addPage(); y = M;

			/* --- Recommended Points table (unchanged style) --- */
			const recHost = document.getElementById('RecdataTable');
			const recTable = recHost ? recHost.querySelector('table') : null;

			if (recTable) {
			  pdf.setFont('helvetica','bold'); pdf.setFontSize(12); pdf.text('Recommended Points Table', M, y); y += 6;
			  pdf.autoTable({
				html: recTable,
				startY: y,
				margin: { left: M, right: M },
				styles: { fontSize: 6, cellPadding: 1 },
				pageBreak: 'auto',
				rowPageBreak: 'auto',
				headStyles: { fillColor:[47,111,237], textColor:255, fontStyle:'bold' }
			  });
			  y = (pdf.lastAutoTable?.finalY ?? pdf.autoTable.previous.finalY) + gap;
			  y = drawDefinitionsBlock(y);

			  // If you still want Data Description right after this section, keep this call:
			   y = await renderDataDescriptionSection(pdf, M);
			} else if (recHost) {
			  const snapRec = await snap(recHost, { scale:1.25 });
			  if (snapRec) { y = ensureRoom(y, 40); y += addImageToPdf(snapRec, M, y, PAGE_W-2*M, 'recommendations') + gap; }
			  y = drawDefinitionsBlock(y);

			  // If you still want Data Description right after this section, keep this call:
			   y = await renderDataDescriptionSection(pdf, M);
			}


				/* ---------------- 3) GIS MAPS (fixed titles, 2 per page) ---------------- */
				setWaitMessage('Capturing GIS Maps…');

				// Exact ID->Title mapping & order
				const ORDERED_MAPS = [
				  { id: 'map2', title: 'Aquifer Classification' },
				  { id: 'map6', title: 'Water Sheds' },
				  { id: 'map5', title: 'Lithology' },
				  { id: 'map3', title: 'Groundwater Level' },
				  { id: 'map4', title: 'Faulting' },
				  { id: 'map7', title: 'Saline Aquifers' },
				  { id: 'map8', title: 'Geothermal Maps' }
				];

				function startGisPage(isFirst){
				  pdf.addPage();
				  let y0 = M;
				  if (isFirst){
					pdf.setFont('helvetica','bold'); pdf.setFontSize(14);
					pdf.text('GIS Maps', M, y0);
					y0 += 8;
				  }
				  return y0;
				}

				// First GIS page (with section heading)
				let isFirstGis = true;
				y = startGisPage(true);
				let mapsOnPage = 0;

				const MAP_IMG_MAX_H = 110; // mm per map image
				const LEGEND_MAX_H = 30;   // mm per legend

				for (const pair of ORDERED_MAPS) {
				  if (!document.getElementById(pair.id)) continue;

				  if (mapsOnPage >= 2) {
					y = startGisPage(false); // no "(cont.)" on subsequent pages
					mapsOnPage = 0;
				  }

				  const mapCanvas = await snapLeafletMap(pair.id);
				  if (!mapCanvas) continue;
				  const legendCanvas = await snapLegendAfter(pair.id);

				  pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
				  pdf.text(pair.title, M, y); y += 6;

				  y += addImageToPdfFit(mapCanvas, M, y, PAGE_W - 2*M, MAP_IMG_MAX_H, `${pair.id} image`) + 2;
				  if (legendCanvas) {
					y += addImageToPdfFit(legendCanvas, M, y, PAGE_W - 2*M, LEGEND_MAX_H, `${pair.id} legend`) + gap;
				  } else {
					y += gap;
				  }
				  mapsOnPage++;
				  isFirstGis = false;
				}

				/* ---------------- 4) SITE PARAMETER MAPS (ALL) ---------------- */
				setWaitMessage('Capturing Site Parameter Maps…');
				pdf.addPage(); y = M;
				pdf.setFont('helvetica','bold'); pdf.setFontSize(14); pdf.text('Site Parameter Maps', M, y); y += 8;

				const contourRoot = document.querySelector('#plotly-contour');
				const contourSelect =
				  contourRoot?.nextElementSibling?.querySelector('select') ||
				  contourRoot?.parentElement?.querySelector('select') ||
				  document.querySelector('[data-contour-select], .contour-select, select#contourSelect');

				async function renderContour(value) {
				  if (typeof window.updateContourPlot === 'function') { try { window.updateContourPlot(value); } catch {} }
				  if (contourSelect) {
					const opt = [...contourSelect.options].find(o => o.value === value);
					if (opt) contourSelect.value = value;
					try { contourSelect.dispatchEvent(new Event('change', { bubbles: true })); } catch {}
				  }
				  await sleep(300);
				  return await snapPlotly('plotly-contour', { w: 1200, h: 800 });
				}

				if (contourSelect && contourSelect.options?.length) {
				  const options = [...contourSelect.options].filter(o => o.value && !o.disabled);
				  for (const opt of options) {
					setWaitMessage(`Site Parameter Maps… (${opt.text || opt.value})`);
					const shotUrl = await renderContour(opt.value);
					if (!shotUrl) continue;
					pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
					y = L.ensureSpace(y, 12); pdf.text(opt.text?.trim() || opt.value, M, y); y += 6;
					y += addImageToPdfFit(shotUrl, M, y, PAGE_W-2*M, 125, `contour ${opt.value}`) + gap;
				  }
				} else {
				  const fallbackVals = ['dataset1','dataset2','dataset3','dataset4','dataset5','dataset6','dataset7','dataset8'];
				  for (const val of fallbackVals) {
					const shotUrl = await renderContour(val);
					if (!shotUrl) continue;
					pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
					y = L.ensureSpace(y, 12); pdf.text(val, M, y); y += 6;
					y += addImageToPdfFit(shotUrl, M, y, PAGE_W-2*M, 125, `contour ${val}`) + gap;
				  }
				}

				/* ---------------- 5) SITE SECTION LINES ---------------- */
				setWaitMessage('Rendering Site Section Lines…');
				const sectionsSelect = document.querySelector('#plotly-Sections')?.parentElement?.querySelector('select');
				async function renderSection(value) {
				  if (typeof window.updateSectionPlot === 'function') { try { window.updateSectionPlot(value); } catch {} }
				  if (sectionsSelect) {
					const opt = [...sectionsSelect.options].find(o => o.value === value);
					if (opt) sectionsSelect.value = value;
					try { sectionsSelect.dispatchEvent(new Event('change', { bubbles:true })); } catch {}
				  }
				  await sleep(350);
				  return await snapPlotly('plotly-Sections', { w:1200, h:700 });
				}
				if (sectionsSelect) {
				  const opts = [...sectionsSelect.options].filter(o => o.value && !o.disabled);
				  for (let i = 0; i < opts.length; i += 2) {
					pdf.addPage(); y = M;
					if (i === 0) { pdf.setFont('helvetica','bold'); pdf.setFontSize(14); pdf.text('Site Section Lines', M, y); y += 8; }
					const pair = opts.slice(i, i+2);
					for (const opt of pair) {
					  const shotUrl = await renderSection(opt.value);
					  if (!shotUrl) continue;
					  pdf.setFont('helvetica','bold'); pdf.setFontSize(12);
					  y = L.ensureSpace(y, 12); pdf.text(opt.text?.trim() || opt.value, M, y); y += 6;
					  y += addImageToPdfFit(shotUrl, M, y, PAGE_W-2*M, 125, 'section figure') + gap;
					}
				  }
				}

				/* ---------------- 6) VIRTUAL LOG TABLES ---------------- */
				setWaitMessage('Capturing Virtual Log tables…');
				(function ensureVirtualLogTabActive(){
				  const tabs = [...document.querySelectorAll('button, a, [role="tab"]')];
				  const tab = tabs.find(t => /virtual\s*logs?/i.test((t.textContent||'').trim()));
				  if (tab) { try { tab.click(); } catch {} }
				})();

				function getTopRecPointsFromTable(limit=9){
				  const host = document.getElementById('RecdataTable'); const table = host ? host.querySelector('table') : null;
				  if (!table) return [];
				  const rows = [...table.querySelectorAll('tr')].slice(1);
				  const parsed = rows.map(r => {
					const cells = [...r.querySelectorAll('td,th')].map(td => (td.textContent||'').trim());
					const point = parseInt(cells[0], 10); const recNo = parseInt(cells[1], 10);
					return {point, recNo};
				  }).filter(x => Number.isFinite(x.point) && Number.isFinite(x.recNo));
				  parsed.sort((a,b) => a.recNo - b.recNo);
				  const uniq = [], seen = new Set();
				  for (const p of parsed) { if (!seen.has(p.point)) { uniq.push(p.point); seen.add(p.point); } if (uniq.length >= limit) break; }
				  return uniq;
				}
				const rowSelector = document.getElementById('rowSelector');
				function findOptionIndexForPointN(select, pointN){
				  if (!select) return -1; const target = String(pointN);
				  for (let i=0;i<select.options.length;i++){
					const txt = (select.options[i].text || '').toLowerCase();
					if (txt.replace(/\s+/g,'').includes(`point${target}`)) return i;
					if ((select.options[i].value||'').trim() === target) return i;
				  }
				  return -1;
				}
				const topPoints = getTopRecPointsFromTable(9);
				for (let i = 0; i < topPoints.length; i++) {
				  const pN = topPoints[i];
				  setWaitMessage(`Virtual Logs… (${i+1}/${topPoints.length})`);
				  if (typeof window.LogPoint === 'function') { try { window.LogPoint(pN); } catch(e) { console.warn('LogPoint error for point', pN, e); } }
				  else if (rowSelector) {
					const idx = findOptionIndexForPointN(rowSelector, pN);
					if (idx >= 0) {
					  rowSelector.selectedIndex = idx;
					  try { if (typeof window.selectRow === 'function') window.selectRow(); } catch(e) {}
					  try { rowSelector.dispatchEvent(new Event('change', { bubbles:true })); } catch(e) {}
					}
				  }
				  await sleep(700);
				  const rows = getVirtualLogRows();
				  if (rows.length) { renderVirtualLogDataLandscape(pdf, `Point ${pN}`, rows); }
				}

				/* ---------------- SAVE ---------------- */
				setWaitMessage('Building PDF…');
				pdf.save('GeoVue_Executive_Summary_Report.pdf');
			  } catch (err) {
				console.error('Report generation error:', err);
				alert(err);
			  } finally {
				hideWait();
			  }
			}
			/************************************End Export Report to PDF **************************/
		
		</script>
	</body>
</html>
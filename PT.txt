<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>GeoVue Interactive Presentation</title>
		<link rel="icon" href="https://www.atsps2.net/LogoLargeTransparent48x48.ico" type="image/x-icon">
		<link rel="shortcut icon" href="https://www.atsps2.net/LogoLargeTransparent48x48.ico" type="image/x-icon">
		<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
		<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
		<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
		<script src="https://unpkg.com/leaflet-image/leaflet-image.js"></script>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.0/xlsx.full.min.js"></script>		
		<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
		<style>
			.wait-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background-color: rgba(0, 0, 0, 0.5);
				display: none;
				justify-content: center;
				align-items: center;
			}
			.wait-message {
				color: white;
				font-size: 24px;
				 margin-bottom: 10px;
			}
			.spinner {
				width: 40px;
				height: 40px;
				border-radius: 50%;
				border: 4px solid rgba(255, 255, 255, 0.3);
				border-top-color: #fff;
				animation: spin 1s linear infinite;
			}
			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}
			body {
				font-family: Arial, sans-serif;
				margin: 0;
				padding: 0;
			}
			.header {
				//display: flex;
				align-items: left;
				padding: 10px 20px;
			}
			.header img {
				width: 50px;
				height: 50px;
				margin-right: 10px;
			}
			.header h1 {
				margin: 0;
				color: #555;
			}
			.tabs {
				list-style-type: none;
				padding: 0;
				margin: 20px 50px;
				display: flex;
				background-color: #f2f2f2;
				border-bottom: 2px solid #ccc;
				border-top-left-radius: 10px;
				border-top-right-radius: 10px;
				border-bottom-left-radius: 10px;
				border-bottom-right-radius: 10px;
			}
			.tabs li {
				flex: 1;
			}
			.tabs li a {
				display: block;
				padding: 15px 20px;
				text-decoration: none;
				text-align: center;
				color: #555;
				border-right: 1px solid #ccc;
				transition: background-color 0.3s;
			}
			.tabs li a:hover {
				background-color: #ddd;
			}
			.tabs li a.active {
				background-color: #ddd;
				font-weight: bold;
			}
			.slides {
				display: none;
				padding: 20px;
				border: 1px solid #ccc;
				margin: 0 5px 5px 5px;
				height: calc(100vh - 150px);
				overflow-y: auto;
			}
			.slides.active {
				display: block;
			}
			.Introheading-container {
				display: flex;
				align-items: center;
			}
			.audio-button {
				padding: 10px 110px;
				font-size: 16px;
				color: #fff;
				background-color: #555;
				border: none;
				border-radius: 5px;
				cursor: pointer;
				transition: background-color 0.3s;
				margin-left: 0px;
				margin-bottom: 20px;
			}
			.audio-button:hover {
				background-color: #0056b3;
			}
			.heading-container {
				display: flex;
				align-items: center;
			}
			.play-symbol {
				font-size: 16px;
				margin-left: 5px;
			}
			.collapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: none;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.collapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.desccontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}

			.GIScollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.GIScollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.GISccontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.GISiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
			}
			.GISiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.CORRcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.CORRcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.CORRcontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.CORRiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
			}
			.CORRiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.SAVEcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.SAVEcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.SAVEcontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.SAVEiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
			}
			.SAVEiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.Importcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.Importcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Importcontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.Importiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
			}
			.Importiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.iframe-container {
				position: relative;
				padding-bottom: 140%;
				height: 0;
				overflow: hidden;
			}
			.iframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			h2{
				text-decoration: underline;
			}
			#content
			{
				display: none;
			}
			#checkboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#checkboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ContourcheckboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ContourcheckboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ModelcheckboxList {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ModelcheckboxList li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListOne {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListOne li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListTwo {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListTwo li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#ProfilecheckboxListThree {
				display: flex;
				flex-wrap: wrap;
				list-style-type: none;
				padding: 0;
			}
			#ProfilecheckboxListThree li {
				width: calc(10% - 12px);
				margin-right: 10px;
				margin-bottom: 10px;
			}
			#selectedRowData {
				width: 100%;
				max-width: 1000px;
				border-collapse: collapse;
				font-size: 11px;
			}
			#selectedRowData {
				width: 100%;
				//max-width: 1000px;
				border-collapse: collapse;
				font-size: 11px;
			}
			.map-container {
				height: 620px;
				width: 100%;
				margin-bottom: 20px;
			}
			img {
				max-width: 100%;
				height: auto;
				display: block;
				margin: 0 auto;
				float: left;
			}
			.image-break {
				clear: both;
			}
			@media only screen and (max-width: 1100px) {
				img {
					width: 100%;
				}
			}
			.text-label {
				background: none;
				color: white;
				font-size: 12px;
				font-weight: bold;
				text-shadow: 1px 1px 2px black;
				text-align: center;
				line-height: 1.5;
				border: none;
			}
			.chart-container {
				width: 100%;
			}
			table {
				width: 100%;
				border-collapse: collapse;
				border: 1px solid #ccc;
				font-size: 12px;
			}
			th, td {
				padding: 8px;
				text-align: left;
				border-bottom: 1px solid #ddd;
			}
			th 
			{
				background-color: #f2f2f2;
			}
			tr:nth-child(even) 
			{
				background-color: #f5f5f5;
			}
			tr:hover 
			{
				background-color: #e0e0e0;
			}
			.disclaimer-box {
				padding: 10px;
				width: 98%;
				border: 1px solid #ccc;
				margin-top: 20px;
				border-radius: 10px;
				background-color: #f9f9f9;
				float: left;
			}
			.note-box {
				padding: 10px;
				width: 98%;
				border: 1px solid #ccc;
				border-radius: 10px;
				background-color: #f9f9f9;
				float: left;
				margin-top: 20px;
				margin-bottom: 20px;
			}
			#plot-container {
			  display: flex;
			  align-items: center; /* Center vertically */
			}

			#plot {
			  flex: 1;
			}
			#Sectionslider-container {
			  display: flex;
			  flex-direction: column;
			  justify-content: center;
			  height: 100%; /* Match height of the plot */
			}
			#Sectionslider {
			  margin: auto;
			  
			  height: 100%; /* Match height of the color bar */
			  width: 10px; /* Adjust width as needed */
			}
			#Sectionmax-value {
			  text-align: center;
			  margin-top: 10px; /* Move the max value label 10px lower */
			}
			#controls {
				margin-bottom: 20px;
			}
			#description {
				width: 800px; /* Adjust this value as needed to make the text box wider */
			}
		
			.Limitscollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Limitscollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Limitscontent {
				padding: 0 10px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				border-radius: 10px;
			}
			.Limitsiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 2300px;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 0px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1135px;
				border-radius: 10px;
			}
			.Limitsiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
		
			.Methcollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
				border-radius: 10px;
			}
			.Methcollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Methcontent {
				padding: 0 10px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1110px;
				margin: 0 auto;
				margin-left: 0;
				border-radius: 10px;
			}
			.Methiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1400px;
				overflow: hidden;
				border: 2px solid lightgrey;
				padding: 0px;
				display: inline-block; /* Ensures the container sizes to its content */
				box-sizing: border-box;
				background-color: #f9f9f9;
				width: 100%;
				max-width: 1135px;
				border-radius: 10px;
			}
			.Methiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
			.editform-container {
				display: flex;
				flex-direction: column;
				gap: 10px;
			}
			.editform-row {
				display: flex;
				align-items: left;
				gap: 10px;
			}
			.editform-row label {
				min-width: 80px; /* Adjust this width as needed */
				
			}
			.editform-row input {
				flex-grow: 1;
				min-width: 80px;
				max-width: 150px;
			}
			.Temperaturecollapsible {
				background-color: #f1f1f1;
				color: #333;
				cursor: pointer;
				padding: 10px;
				width: 100%;
				border: 1px solid #ccc;
				text-align: left;
				outline: none;
				font-size: 14px;
				transition: 0.4s;
				max-width: 1135px;
				margin: 0 auto;
				margin-left: 0;
				position: relative;
			}
			.Temperaturecollapsible::after {
				content: '▼';
				position: absolute;
				right: 10px;
				top: 50%;
				transform: translateY(-50%);
			}
			.Temperaturecontent {
				padding: 0 18px;
				display: none;
				overflow: hidden;
				background-color: #f1f1f1;
				max-width: 1100px;
				margin: 0 auto;
				margin-left: 0;
			}
			.Temperatureiframe-container {
				position: relative;
				/*padding-bottom: 140%;*/
				height: 1000;
				overflow: hidden;
			}
			.Temperatureiframe-container iframe {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<div class="wait-overlay" id="waitOverlay">
			<div class="wait-message">Document Loading. Please wait...   </div>
			<div class="spinner"></div>
		</div>
		
		<div class="header">
			<img src="https://www.atsps2.net/StandardLogoLargeTransparent.PNG" alt="Icon">
			<h1>GeoVue Interactive Presentation</h1>
		</div>
		
		<div class="disclaimer-box">
		  <p><strong>Terms of Use:</strong> All the data sets, interpretations, recommendations, logs, and risk assessments, presented in this document are calculated estimates of the values and parameters they represent, as they are derived from the signal attributes of multiple sets of sensor collected data. These sensors are subject to variance, drift, noise, error and uncertainty. As such, the data collected from these sensors, and the data sets derived from the sensor collected data, are subject to the same variance, drift, noise, error and uncertainty. As such, the data sets discussed in this document cannot, and should not, be viewed or interpreted as being absolute in nature. Any actions or decisions made by the user with reference to the data provided in this document, should consider the uncertainties and risks involved in its use. As such, the client accepts and agrees in full, not to hold ‘GeoVue Ltd’, its owners, directors, or employees, liable for any financial or physical losses, damages, injuries, or claims incurred or made by any persons, companies, organizations, or institutions who make use of ‘GeoVue Ltd’ field or consulting services, or the information, interpretations, findings, and recommendations discussed in this presentation. As Electro-seismic technologies are geophysical technologies with inherent uncertainties and risks, the client accepts and agrees in full, that ‘GeoVue Ltd’, its owners, directors, or employees, does not, and cannot, guarantee that the results published in this presentation to be absolutely accurate and will not accept, or be liable for, any claim of financial losses due to unsuccessful or unsatisfactory exploration results, or otherwise, due to the use of the information discussed in this presentation, on the part of the client and/or their associates, subsidiaries, contractors, consultants, employees, or investors.</p>
		</div>
		<br>

		<div class="note-box">
		  <p><strong>Load Time Note:</strong> The presentation may take some time to load after the "Accept Terms and Load Report" button is selected. Should a "page unresponsive" message appear on your browser, either ignore the message until the document has loaded or select the "Wait" option.</p>
		</div>

		<button id="acceptButton" style="background-color: #555; 
		  border: none;
		  color: white;
		  padding: 10px 85px;
		  text-align: center;
		  text-decoration: none;
		  display: inline-block;
		  font-size: 16px;
		  margin: 4px 2px;
		  transition-duration: 0.4s;
		  cursor: pointer;
		  border-radius: 8px;
		  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
		  ">
		  &#10004;  Accept Terms and Load Presentation
		</button>
		<div id="content">
			<ul class="tabs">
				<li><a href="#" class="tab-link  active" data-slide="slide1">Site Maps</a></li>
				<li><a href="#" class="tab-link" data-slide="slide2">Points</a></li>
				<li><a href="#" class="tab-link" data-slide="slide3">Data Maps</a></li>
				<li><a href="#" class="tab-link" data-slide="slide4">Data Sections</a></li>
				<li><a href="#" class="tab-link" data-slide="slide10">Data Profiles</a></li>
				<li><a href="#" class="tab-link" data-slide="slide5">Data Models</a></li>
				<li><a href="#" class="tab-link" data-slide="slide8">Data Traces</a></li>
				<li><a href="#" class="tab-link" data-slide="slide7">Logs</a></li>
				<li><a href="#" class="tab-link" data-slide="slide6">Recommendations</a></li>
				<li><a href="#" class="tab-link" data-slide="slide11">Views</a></li>
			</ul>

			<div id="slide1" class="slides active">
				<div class="heading-container" onclick="playAudioSurveySiteMap()">
					<h2>Survey Site Map</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<button id="download-btn1">Download Map</button>
				<button type="button" onclick="AutoLineCreate()">Auto Create Lines</button>
				<button type="button" onclick="DeleteSelectionAll()">Delete All Lines</button>
				<div id="map1" class="map-container"></div>
				<figure>
					<figcaption>Map Marker Legend</figcaption>
					<img src="https://atsps2.net/recommendationslegend.png" alt="Map Marker Legend " width="500" height="35">
				</figure>
				<div class="image-break"></div>
			
				<div class="heading-container" onclick="playSiteMapSettings()">
					<h4>Site Map Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
			
				<div>
					<input type="checkbox" id="ShowRecomendations-checkbox" onchange="toggleSiteMapShowRecomendations()" unchecked>
					<label for="ShowRecomendations-checkbox">Show recommendation points</label>
				</div>
				
				<div>
					<input type="checkbox" id="RecPoints-checkbox" onchange="toggleSiteMapRecPoints()" unchecked>
					<label for="RecPoints-checkbox">Show recommendation points only </label>
				</div>

				<div>
					<input type="checkbox" id="ShowLines-checkbox" onchange="toggleSiteMapShowLines()" unchecked>
					<label for="ShowLines-checkbox">Show selection lines</label>
				</div>

				<div class="heading-container" onclick="playReportDataElevationSettings()">
					<h4>Report Data Elevation Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<input type="checkbox" id="SRTMElevation-checkbox" onchange="toggleSRTM()" unchecked>
				<label for="SRTMElevation-checkbox">Use SRTM Elevation Data</label>
								
				<br>
				<input type="checkbox" id="ZeroElevation-checkbox" onchange="toggleZero()" unchecked>
				<label for="ZeroElevation-checkbox">Use Zero Elevation Data</label>

				<div><br></div>
				<button class="SAVEcollapsible"><h2>Save Report</h2></button>
				<div class="SAVEcontent">
					<div class="SAVEiframe-container">
							<div class="block-container">
								<div class="heading-container">
									<h2>Save Presentation</h2>
								</div>
							<div style="max-width: 1100px;" style="text-align: justify;">
							<p class=MsoNormal><b>Note </b>– To save any updates made to the presentation points, use the Save Presentation option. A new presentation will be generated with the updates included.</p>
							</div>
							<div>
								<button id="fetchButton">Save Presentation</button>
							</div>
						</div>
						<br>
					</div>
				</div>
				<div><br></div>
				
				<div><br></div>
				<button class="CORRcollapsible"><h2>Edit Point Data</h2></button>
				<div class="CORRcontent">
					<div class="CORRiframe-container">
				
						<div class="block-container">
							<div class="heading-container">
								<h2>Update Point Data</h2>
							</div>

							<div style="max-width: 1100px;" style="text-align: justify;">
							<p class=MsoNormal><b>Note </b>– This feature allow for the updating of the selected points Latitude, Longitude and elevation data. Select the point to be updated, then enter the new latitude, longitude, or elevation. Once entered, select the Update option. The point data will be updated, along with all the maps displaying the point. Alternatively, the point can be dragged to a new position on the site map. When this method is used, the updated point position is automatically updated, however, the the elevation data will remain the same.</p>
							</div>
							
							<div>
								<select id="rowSelectorEditPoint" onchange="selectRowEditPoint()">
									<option value="" disabled selected>Select Point</option>
								</select>
							</div>
							<br>
							<div class="editform-container">
								<div class="editform-row">
									<label for="LatInput">Latitude:</label>
									<input type="text" id="LatInput" value="0.0">
									<label for="LatInput">(WGS84 Dec°)</label>
								</div>
								<div class="editform-row">
									<label for="LonInput">Longitude:</label>
									<input type="text" id="LonInput" value="0.0">
									<label for="LonInput">(WGS84 Dec°)</label>
								</div>
								<div class="editform-row">
									<label for="ElevInput">Elevation:</label>
									<input type="text" id="ElevInput" value="0.0">
									<label for="ElevInput">(masl)</label>
								</div>
							</div>
							<br>
							
							<div>
								<button id="SaveEditsButton" onclick="UpdatePointData()">Update</button>
							</div>
							
							<div style="max-width: 1100px;" style="text-align: justify;">
							</div>
						
						</div>

						<p style="page-break-after: always;">&nbsp;</p>
							<div class="block-container">
								<div class="heading-container">
									<h2>Bulk Update Point Data</h2>
								</div>
							<div style="max-width: 1100px;" style="text-align: justify;">
							<p class=MsoNormal><b>Note </b>– This feature allow for the loading of a KML, KMZ, CSV or GPX file to complete a bulk correction of the coordinates of the points within the project. Coordinate data must be in WGS84 Decimal degree format and elevation data must be included within the files in MASL format. The CSV data format must be as follows (Point number, Latitude, Longitude, Elevation)</p>
							</div>
							<div>
								<input type="file" id="fileInput" accept=".kml, .kmz, .gpx, .csv" style="display:none" onchange="loadCorrFile()">
								<button id="LoadCorrectionFile"onclick="selectAndLoadFile()">Load File</button>
							</div>
						</div>

					</div>
				</div>
				<div><br></div>
				
				<div><br></div>
				<button class="Importcollapsible"><h2>Import External Data</h2></button>
				<div class="Importcontent">
					<div class="Importiframe-container">
							<div class="block-container">
								<div class="heading-container">
									<h2>Import External Data</h2>
								</div>
							<div style="max-width: 1100px;" style="text-align: justify;">
							<p class=MsoNormal><b>Note </b>– To import data, a CSV (Microsoft Comma Delimited) file must be created with data in the following format - Point (The project point to which the data is assigned), Depth(below ground level in meters), Value (the magintude of the CPT or other readings), Label (such as the CPT number). A number of external data points can be added to the CSV file. Click on the Load External Data button, then select the CSV file to import. The Loaded data will be normilised to the maximum value detected in the Value column of the CSV file. This males all the imported data sets relative in ampltude to one another. To see the imported data on the Section Data plot, select the view Imported data checkbox and regenerate the plot.</p>
							</div>
							<div>
								<button id="loadExtDataButton">Load External Data</button>
								<input type="file" id="ExtfileInput" accept=".csv" style="display: none;" />
							</div>
						</div>
						<br>
					</div>
				</div>
				
				<div><br></div>
				<div class="heading-container" onclick="playViewGISDataMaps()">
					<span class="play-symbol">&#128266;</span>
				</div>
				<button class="GIScollapsible"><h2>View GIS Data Maps</h2></button>
				<div class="GIScontent">
					<div class="GISiframe-container">
						<div class="heading-container" onclick="playAudioAquiferClassification()">
							<h2>Aquifer Classification</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn2">Download Map</button>
						<div id="map2" class="map-container"></div>
						<figure>
							<figcaption>Aquifer Classification Legend</figcaption>
							<img src="https://atsps2.net/AquiferClassificationLegend.png" alt="Aquifer Classification Legend " width="1000" height="40">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioLithology()">
							<h2>Lithology</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn5">Download Map</button>
						<div id="map5" class="map-container"></div>
						<figure>
							<figcaption>Lithology Legend</figcaption>
							<img src="https://atsps2.net/LithologyLegend.jpg" alt="Lithology Legend"width="1000" height="590">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioGroundwaterLevel()">
							<h2>Groundwater Level</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn3">Download Map</button>
						<div id="map3" class="map-container"></div>
						<figure>
							<figcaption>Groundwater Level Legend</figcaption>
							<img src="https://atsps2.net/GWLLegend.png" alt="Groundwater Level Legend" width="1000" height="150">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioFaulting()">
							<h2>Faulting</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn4">Download Map</button>
						<div id="map4" class="map-container"></div>
						<figure>
							<figcaption>Faulting Legend</figcaption>
							<img src="https://atsps2.net/FaultLegend.png" alt="Faulting Legend" width="1000" height="35">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioWaterSheds()">
							<h2>Water Sheds</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn6">Download Map</button>
						<div id="map6" class="map-container"></div>
						<div class="image-break"></div>
						<figure>
							<figcaption>Water Shed Boundaries</figcaption>
							<img src="https://atsps2.net/WaterShedBoundaryLegend.png" alt="Water Shed Boundary Legend " width="1000" height="35">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioSalineAquifers()">
							<h2>Saline Aquifers</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn7">Download Map</button>
						<div id="map7" class="map-container"></div>
						<figure>
							<figcaption>Saline Aquifers Legend</figcaption>
							<img src="https://atsps2.net/SalineAquiferLegend.png" alt="Saline Aquifers Legend" width="1000" height="35">
						</figure>
						<div class="image-break"></div>
					
						<div class="heading-container" onclick="playAudioGeothermal()">
							<h2>Geothermal Maps</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<button id="download-btn8">Download Map</button>
						<div id="map8" class="map-container"></div>
						<figure>
							<figcaption>Geothermal Legend</figcaption>
							<img src="https://atsps2.net/GeothermalLegend.png" alt="Geothermal Legend" width="1000" height="40">
						</figure>
						<div class="image-break"></div>
					</div>
				</div>			
				<div><br></div>
				<div><br></div>
				<button class="Limitscollapsible"><h2>Limitations</h2></button>
				<div class="Limitscontent">
				  <div class="Limitsiframe-container">
					<iframe src="https://www.atsps2.net/limits.html" frameborder="0" allowfullscreen></iframe>
				  </div>
				</div>
				<div><br></div>
				<div><br></div>
				<button class="Methcollapsible"><h2>Methodology</h2></button>
				<div class="Methcontent">
				  <div class="Methiframe-container">
					<iframe src="https://www.atsps2.net/Methodology.png" frameborder="0" allowfullscreen></iframe>
				  </div>
				</div>
				<p style="page-break-after: always;">&nbsp;</p>
				
				<button class="Temperaturecollapsible"><h2>Temperature Calibration</h2></button>
				<div class="Temperaturecontent">
				  <div class="Temperatureiframe-container">
					<div class="block-container">
						<div class="heading-container">
							<h2>Site Temperature Calibration</h2>
						</div>
						
						<div>
						<label for="temperatureInput">Maximum formation temperature (degC):</label>
						<input type="text" id="temperatureInput" value="25" oninput="updateTemperature()">
						</div>
						<div style="max-width: 1100px;" style="text-align: justify;">
						<p class=MsoNormal><b>Note </b>– This parameter allows the user to calibrate the thermal data provided in this document, to known or estimated values in degrees Celsius. By default, the site natural thermal gradient is set to 25 degrees per km to estimate the maximum expected temperature at the project processed depth. If the survey is conducted on an active geothermal field, then the maximum geothermal resource temperature within the data processing depth range, can be used to calibrate the thermal data. Thermal data plots are available on the selectable dataset drop down lists for every chart in this document. When changing this value, it is important to regenerate the data plots to reflect the change.</p>
						</div>
					</div>
				  </div>
				</div>			
			</div>

			<div id="slide2" class="slides">
				<div class="heading-container" onclick="playAudioSurveyPoints()">
					<h2>Survey Points</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="dataTable"></div>
			</div>

			<div id="slide3" class="slides">
				<div class="heading-container" onclick="playAudioSiteParameterMaps()">
					<h2>Site Parameter Maps</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-contour" class="chart-container"></div>
				<div class="image-break"></div>
				
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateContourPlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Yield Estimates">
							<option value="dataset1">Sustainable Yield</option>
							<option value="dataset2">Minimum Yield</option>
							<option value="dataset3">Maximum Yield</option>
						</optgroup>
						<optgroup label="Well Parameters">	
							<option value="dataset11">GPS Elevation</option>
							<option value="dataset5">Drilling Depth</option>
							<option value="dataset4">Ground water level</option>	
						</optgroup>
						<optgroup label="Quality Control">	
							<option value="dataset6">Risk</option>
							<option value="dataset7">Confidence</option>
							<option value="dataset8">Correlation</option>
							<option value="dataset9">Signal to Noise Ratio</option>
							<option value="dataset39">Noise</option>
							<option value="dataset41">Vertical Resolution</option>
							<option value="dataset42">Uncertainty</option>
							<option value="dataset10">Strikes Used</option>
						</optgroup>
						<optgroup label="Magnetics">
							<option value="dataset43">Magnetic Field Strength</option>
						</optgroup>
						<optgroup label="Depth Yield Estimates">	
							<option value="dataset12">Sustainable Yield 100m</option>
							<option value="dataset13">Sustainable Yield 200m</option>
							<option value="dataset14">Sustainable Yield 300m</option>
							<option value="dataset15">Sustainable Yield 400m</option>
							<option value="dataset16">Sustainable Yield 500m</option>
							<option value="dataset17">Sustainable Yield 600m</option>
							<option value="dataset18">Sustainable Yield 700m</option>
							<option value="dataset19">Sustainable Yield 800m</option>
							<option value="dataset20">Sustainable Yield 900m</option>
							<option value="dataset21">Sustainable Yield 1000m</option>				
						</optgroup>
						<optgroup label="GeoTechnical Parameters">	
							<option value="dataset22">Soil Depth</option>
							<option value="dataset23">Soil Density</option>
							<option value="dataset24">Soil Porosity</option>
							<option value="dataset25">Soil Shear Modulus</option>
							<option value="dataset26">Soil Bulk Modulus</option>
							<option value="dataset27">Soil Compressibility</option>
							<option value="dataset28">Soil Poisson Ratio</option>
							<option value="dataset29">Soil Youngs Modulus</option>
							<option value="dataset30">Soil Acoustic Impeadance</option>
							<option value="dataset31">Soil Storativity</option>
							<option value="dataset32">Soil Diffusivity</option>
							<option value="dataset33">Soil Hydraulic Conductivity</option>
							<option value="dataset34">Soil Transmissivity</option>
							<option value="dataset35">Soil Permeability</option>
							<option value="dataset36">Soil Clay Content</option>
							<option value="dataset37">Soil SPTN</option>
							<option value="dataset38">Soil SPTRQD</option>
						</optgroup>
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– Point numbers shown on chart</p>
				</div>
				
				<div class="heading-container" onclick="playCreateSiteParameterMapViews()">
					<h4>Create Site Parameter Map Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector1" onchange="updateDescription1()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description1" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView1()">&#8593;</button>
					<button onclick="nextView1()">&#8595;</button>
					<button onclick="savePlot1()">Save View</button>
					<button onclick="loadPlot1()">Load View</button>
				</div>
				
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector5" onchange="updateDescription5()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description5" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot5()">Save View</button>
				</div>
				
				<div class="heading-container" onclick="playAudioSelectContourPoints()">
					<h4>Select Contour Map Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleContourForm()">View Contour Map Points</button>
					<form id="ContourcheckboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Contour Points:</legend>
							<ul id="ContourcheckboxList"></ul>
						</fieldset>
						<button type="button" onclick="ContourselectAll()">Select All</button>
						<button type="button" onclick="ContourdeselectAll()">Deselect All</button>
						<button type="button" onclick="ContourshowSelectedPoints()">Render Section</button>
						<input type="text" id="ContourSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ContoursaveSelection()">Save Selection</button>
						<select id="ContourSelectionDropdown"></select>
						<button type="button" onclick="ContourloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionContour()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>

			<div id="slide4" class="slides">
				<div class="heading-container" onclick="playAudioSiteSectionLine()">
					<h2>Site Section Line</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-Sections" class="chart-container"></div>
				<div class="image-break"></div>
				
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateSectionPlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
							<option value="dataset44">Seismic Reflection</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Bulk Resistivity</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>
				
				<div class="heading-container" onclick="playAudioSectionSettings()">
					<h4>Section Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div>	
					<input type="checkbox" id="show-sectionlogs-checkbox" onchange="togglesectionLogs()" unchecked>
					<label for="show-sectionlogs-checkbox">Show Recommended Drilling Depth Logs</label>
				</div>
				<div>
					<input type="checkbox" id="show-Fracturepoints-checkbox" onchange="togglefracturePoints()" unchecked>
					<label for="show-sectionlogs-checkbox">Show Detected Fracture points</label>
				</div>
				<div>
				<input type="checkbox" id="show-ExternalData-checkbox" onchange="toggleExternalData()" unchecked>
				<label for="show-ExternalData-checkbox">Show Imported Data</label>
				</div>
				
				<div class="heading-container" onclick="playSectionAmplitudeSettings()">
					<h4>Section Amplitude Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
				<label for="Sectionslider" style="width: 170px;">Data Max Relative Value:</label>
				<input type="range" min="0" max="100" value="100" id="range-slider" style="width: 400px;">
				<span id="Sectionmax-value">100</span>
				</div>

				<div class="heading-container" onclick="playCreateSiteSectionLineViews()">
					<h4>Create Site Section Line Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
					<select id="viewSelector2" onchange="updateDescription2()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description2" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView2()">&#8593;</button>
					<button onclick="nextView2()">&#8595;</button>
					<button onclick="savePlot2()">Save View</button>
					<button onclick="loadPlot2()">Load View</button>
				</div>	
 
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector6" onchange="updateDescription6()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description6" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot6()">Save View</button>
				</div>	
				
				<div class="heading-container" onclick="playAudioSelectSectionPoints()">
					<h4>Select Section Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleSectionForm()">View Section Points</button>
					<form id="checkboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Section Points:</legend>
							<ul id="checkboxList"></ul>
						</fieldset>
						<button type="button" onclick="selectAll()">Select All</button>
						<button type="button" onclick="deselectAll()">Deselect All</button>
						<button type="button" onclick="showSelectedPoints()">Render Section</button>
						<input type="text" id="SectionSelectionName" placeholder="Selection Name">
						<button type="button" onclick="SectionsaveSelection()">Save Selection</button>
						<select id="SectionSelectionDropdown"></select>
						<button type="button" onclick="SectionloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionSection()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>

			<div id="slide5" class="slides">
				<div class="heading-container" onclick="playAudioSiteModels()">
					<h2>Site Models</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-Model1" class="chart-container" style="width: 100%;"></div>
				<div class="image-break"></div>
				<button id="animation-btn">Start Model Rotation</button>
				<div class="image-break"></div>
				
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateVolumePlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Bulk Resistivity</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>
				
				<div class="heading-container" onclick="playAudioModelSettings()">
					<h4>Model Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
				  <label for="isomin-slider" style="width: 180px;">Iso-Surface Minimum %:</label>
				  <input type="range" min="0" max="100" value="70" class="slider" id="isomin-slider" style="width: 400px;">
				  <span id="isomin-value">70</span>
				</div>
				<div style="display: flex; align-items: center;">
				  <label for="isomax-slider" style="width: 180px;">Iso-Surface Maximum %:</label>
				  <input type="range" min="0" max="100" value="100" class="slider" id="isomax-slider" style="width: 400px;">
				  <span id="isomax-value">100</span>
				</div><br>
				<div>
				<input type="checkbox" id="show-topography-checkbox" onchange="toggleTopography()" checked>
				<label for="show-topography-checkbox">Show Topography</label>
				</div>
				<div>
				<input type="checkbox" id="show-survey-points-checkbox" onchange="toggleSurveyPoints()" checked>
				<label for="show-survey-points-checkbox">Show Survey Points</label>
				</div>
				<div>
				<input type="checkbox" id="show-logs-checkbox" onchange="toggleLogs()" checked>
				<label for="show-logs-checkbox">Show Logs</label>
				</div>
				<div class="heading-container" onclick="playAudioSliceSettings()">
					<h4>Slice Settings :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div style="display: flex; align-items: center;">
					<label for="DepthsliceSlider" style="width: 180px;">Depth Slice Position:</label>
					<input type="range" min="0" max="99" value="50" step="1" id="DepthsliceSlider" style="width: 400px;">
				</div>
				<div style="display: flex; align-items: center;">
					<label for="LatsliceSlider" style="width: 180px;">Latitude Slice Position:</label>
					<input type="range" min="0" max="29" value="15" step="1" id="LatsliceSlider" style="width: 400px;">
				</div>
				<div style="display: flex; align-items: center;">
					<label for="LonsliceSlider" style="width: 180px;">Longitude Slice Position:</label>
					<input type="range" min="0" max="29" value="15" step="1" id="LonsliceSlider" style="width: 400px;">
				</div><br>
				
				<div>
				<input type="checkbox" id="show-DepthSlice-checkbox" onchange="toggleDepthSlice()" checked>
				<label for="show-DepthSlice-checkbox">Show Depth Slice</label>
				</div>
				<div>
				<input type="checkbox" id="show-LatSlice-checkbox" onchange="toggleLatSlice()" checked>
				<label for="show-LatSlice-checkbox">Show Lat Slice</label>
				</div>
				<div>
				<input type="checkbox" id="show-LonSlice-checkbox" onchange="toggleLonSlice()" checked>
				<label for="show-LonSlice-checkbox">Show Lon Slice</label>
				</div>

				<div class="heading-container" onclick="playCreateSiteModelViews()">
					<h4>Create Site Model Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
				<select id="viewSelector4" onchange="updateDescription4()">
					<option value="0">View 1</option>
					<option value="1">View 2</option>
					<option value="2">View 3</option>
					<option value="3">View 4</option>
					<option value="4">View 5</option>
					<option value="5">View 6</option>
					<option value="6">View 7</option>
					<option value="7">View 8</option>
					<option value="8">View 9</option>
					<option value="9">View 10</option>
					<option value="10">View 11</option>
					<option value="11">View 12</option>
					<option value="12">View 13</option>
					<option value="13">View 14</option>
					<option value="14">View 15</option>
					<option value="15">View 16</option>
					<option value="16">View 17</option>
					<option value="17">View 18</option>
					<option value="18">View 19</option>
					<option value="19">View 20</option>
				</select>
				<input type="text" id="description4" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
				<button onclick="prevView4()">&#8593;</button>
				<button onclick="nextView4()">&#8595;</button>
				<button onclick="savePlot4()">Save View</button>
				<button onclick="loadPlot4()">Load View</button>
			</div>
			
			<div class="heading-container" onclick="playCreatePresentationViews()">
				<h4>Create Presentation Views :</h4>
				<span class="play-symbol">&#128266;</span>
			</div>
			<div id="controls">
				<select id="viewSelector8" onchange="updateDescription8()">
					<option value="0">View 1</option>
					<option value="1">View 2</option>
					<option value="2">View 3</option>
					<option value="3">View 4</option>
					<option value="4">View 5</option>
					<option value="5">View 6</option>
					<option value="6">View 7</option>
					<option value="7">View 8</option>
					<option value="8">View 9</option>
					<option value="9">View 10</option>
					<option value="10">View 11</option>
					<option value="11">View 12</option>
					<option value="12">View 13</option>
					<option value="13">View 14</option>
					<option value="14">View 15</option>
					<option value="15">View 16</option>
					<option value="16">View 17</option>
					<option value="17">View 18</option>
					<option value="18">View 19</option>
					<option value="19">View 20</option>
					<option value="20">View 21</option>
					<option value="21">View 22</option>
					<option value="22">View 23</option>
					<option value="23">View 24</option>
					<option value="24">View 25</option>
					<option value="25">View 26</option>
					<option value="26">View 27</option>
					<option value="27">View 28</option>
					<option value="28">View 29</option>
					<option value="29">View 30</option>
					<option value="30">View 31</option>
					<option value="31">View 32</option>
					<option value="32">View 33</option>
					<option value="33">View 34</option>
					<option value="34">View 35</option>
					<option value="35">View 36</option>
					<option value="36">View 37</option>
					<option value="37">View 38</option>
					<option value="38">View 39</option>
					<option value="39">View 40</option>
					<option value="40">View 41</option>
					<option value="41">View 42</option>
					<option value="42">View 43</option>
					<option value="43">View 44</option>
					<option value="44">View 45</option>
					<option value="45">View 46</option>
					<option value="46">View 47</option>
					<option value="47">View 48</option>
					<option value="48">View 49</option>
					<option value="49">View 50</option>
				</select>
				<input type="text" id="description8" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
				<button onclick="savePlot8()">Save View</button>
			</div>
			
				<div class="heading-container" onclick="audioPlayerSelectModelPoints()">
				<h4>Select Model Points :</h4>
				<span class="play-symbol">&#128266;</span>
				</div>
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleModelForm()">View Model Points</button>
					<form id="ModelcheckboxForm" style="max-width: 100%; display: none;">
						<fieldset>
							<legend>Select Model Points:</legend>
							<ul id="ModelcheckboxList"></ul>
						</fieldset>
						<button type="button" onclick="ModelselectAll()">Select All</button>
						<button type="button" onclick="ModeldeselectAll()">Deselect All</button>
						<button type="button" onclick="ModelshowSelectedPoints()">Render Model</button>
						<input type="text" id="ModelSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ModelsaveSelection()">Save Selection</button>
						<select id="ModelSelectionDropdown"></select>
						<button type="button" onclick="ModelloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionModel()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
					</form>
				</div>
			</div>

			<div id="slide6" class="slides">
				<div class="heading-container" onclick="playAudioRecommendations()">
					<h2>Recommendations</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="RecdataTable"></div>

				<div>
				
					<p class=MsoNormal><h2>Recommendation Definitions<o:p></o:p></h2></p>


					<p class=MsoNormal><b>Risk</b> - The calculated total risk of attaining the
					specified point yield parameters indicated in the recommendations table. Risk is defined by the
					site noise content, data correlation, data signal to noise ratios and number of
					strikes used in processing.<o:p></o:p></p>


					<p class=MsoNormal><b>Confidence</b> - The calculated measure of confidence in
					attaining the point specified yield parameters indicated in the recommendations table.
					Confidence is defined by the area, volume, min and max
					yield, correlating points and composition of the aquifers detected under the
					point.<o:p></o:p></p>


					<p class=MsoNormal><b>Min Yield </b>- The estimated minimum yield, in litres per
					second, the point will produce if drilled to the specified depth. This estimated
					value is calculated by assuming no fractures or dual porosity formations are
					intersected under the point and thus represents the lowest calculated yield for
					the point. All aquifers above the specified static water level or user defined casing
					depth is excluded from the yield estimation.<o:p></o:p></p>


					<p class=MsoNormal><b>Max Yield </b>- The estimated maximum yield, in litres per
					second, the point will produce if drilled to the specified depth. This estimated
					value is calculated by assuming large, extensive, well connected and 
					well developed fractures or dual porosity formations are
					intersected under the point and thus represents the highest calculated yield
					for the point. All aquifers above the specified static water level or user
					defined casing depth is excluded from the yield
					estimation.<o:p></o:p></p>


					<p class=MsoNormal><b>Sustainable Yield </b>- The estimated sustainable yield,
					in litres per second, the point should produce if drilled to the specified
					depth. All aquifers above the specified static water level or user defined
					casing depth is excluded from the yield estimation.
					This value is calculated by applying the area, volume, composition, min and max
					yield, risk and confidence parameters for the aquifers indicated to be
					intersected by the point, to estimate what the sustainable yield of the points
					will be. This value includes both the local and wide area aquifers sustainable
					yield estimates, within the specified yield influence radius, to provide the
					most realistic estimate for sustainable yield at any given point location. The
					sustainable yield value specified in the recommendations table, is a calculated estimate for sustainable
					yield a point will produce. As such, the estimated sustainable yield, specified
					on the recommendations table, is subject to variation from the true sustainable yield
					encountered at the point. The true sustainable yield encountered at the point
					can and may vary between the specified estimated minimum and maximum yield
					values for the point.<o:p></o:p></p>

					<p class=MsoNormal><b>Rec Drill Depth </b>– The maximum depth to which a
					recommended point should be drilled.</p>
				
					<p class=MsoNormal><b>Vert. Res </b>– The maximum calculated vertical resolution of interpreted geological interface depths. </p>
				
					<p class=MsoNormal><b>Uncertainty </b>– The maximum calculated uncertainty of the interpreted geological interface depths.</p>
				</div>
			</div>

			<div id="slide7" class="slides">
				<div class="heading-container" onclick="playAudioPointVirtualLogs()">
					<h2>Point Virtual Logs</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<select id="rowSelector" onchange="selectRow()">
					<option value="" disabled selected>Select Point Log</option>
				</select><br>
				<table id="selectedRowData">
					<thead>
						<tr>
							<th>No</th>
							<th>L</th>
							<th>A</th>
							<th>From (mbgl)</th>
							<th>To (mbgl)</th>
							<th>Lithology</th>
							<th>Aquifer</th>
							<th>Condition</th>
							<th>Fractured Aquifer</th>
							<th>Min Yield (l/s)</th>
							<th>Max Yield (l/s)</th>
							<th>Sus Yield (l/s)</th>
							<th>Porespace Hydraulic Conductivity (m/d)</th>
							<th>Matrix  Hydraulic Conductivity (m/d)</th>
							<th>Porosity (%)</th>
							<th>Specific Storage (1/m)</th>
							<th>Storativity</th>
							<th>Diffusivity (m2/d)</th>
							<th>Clay(%)</th>
							<th>Density (kg/m3)</th>
							<th>Shear Mod (Pa)</th>
							<th>Bulk Mod (Pa)</th>
							<th>Compressibiliy (1/Pa)</th>
							<th>Youngs Mod (Pa)</th>
							<th>Water Quality (%)</th>
							<th>Formation Aquifer Indicator</th>
							<th>Formation Fracturing</th>
							<th>SPTN</th>
							<th>SPTRQD</th>
							<th>Seismic Velocity (m/s)</th>
							<th>Acoustic Impedance (Pa s/m3)</th>
							<th>Frenzel Radius (m)</th>
							<th>Transmission Coefficient</th>
							<th>Critical Angle (Deg)</th>
							<th>Seismic Attenuation Qp (GPa)</th>
							<th>Seismic Attenuation Qs (GPa)</th>
							<th>Apparent Resistivity (Ohm/m)</th>
							<th>Poisson Ratio (Ratio)</th>
							<th>Specific Volume (m3/kg)</th>
							<th>Porespace Transmissivity (m2/d)</th>
							<th>Porespace Permeability (md)</th>
							<th>Matrix Transmissivity (m2/d)</th>
							<th>Matrix Permeability (md)</th>
							<th>Permeability Contrast (Ratio)</th>
							<th>Aquifer Probability (%)</th>
							<th>Formation Temperature (degC)</th>
							<th>Aquiclude Probability (%)</th>
							<th>Hydrocarbon Probability (%)</th>
							<th>Saturation (%)</th>
						</tr>
					</thead>
					<tbody id="selectedRow">
					</tbody>
				</table>
				<button onclick="exportTableToExcel('selectedRowData', 'ExportedData')">Export to Excel</button>
			</div>
			
			<div id="slide8" class="slides">
				<div class="heading-container" onclick="playAudioPointDataTraces()">
					<h2>Point Data Traces</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<select id="PointSelector" onchange="selectPoint()">
					<option value="" disabled selected>Select Point</option>
				</select><br>
				<div id="Traceplot-0-Lith" style="display: inline-block;"></div>
				<div id="Traceplot-1-Aqui" style="display: inline-block;"></div>
				<div id="Traceplot-2-Cond" style="display: inline-block;"></div>
				<div id="Traceplot-3-Frac" style="display: inline-block;"></div>
				<div id="Traceplot-4-Min" style="display: inline-block;"></div>
				<div id="Traceplot-5-Max" style="display: inline-block;"></div>
				<div id="Traceplot-6-Sus" style="display: inline-block;"></div>
				<div id="Traceplot-7-PrimK" style="display: inline-block;"></div>
				<div id="Traceplot-8-SecK" style="display: inline-block;"></div>
				<div id="Traceplot-9-Poro" style="display: inline-block;"></div>
				<div id="Traceplot-10-SStor" style="display: inline-block;"></div>
				<div id="Traceplot-11-Stor" style="display: inline-block;"></div>
				<div id="Traceplot-12-Diff" style="display: inline-block;"></div>
				<div id="Traceplot-13-Clay" style="display: inline-block;"></div>
				<div id="Traceplot-14-Dens" style="display: inline-block;"></div>
				<div id="Traceplot-15-Shear" style="display: inline-block;"></div>
				<div id="Traceplot-16-Bulk" style="display: inline-block;"></div>
				<div id="Traceplot-17-Comp" style="display: inline-block;"></div>
				<div id="Traceplot-18-Yong" style="display: inline-block;"></div>
				<div id="Traceplot-19-WQ" style="display: inline-block;"></div>
				<div id="Traceplot-20-AI" style="display: inline-block;"></div>
				<div id="Traceplot-21-FC" style="display: inline-block;"></div>
				<div id="Traceplot-22-SPTN" style="display: inline-block;"></div>
				<div id="Traceplot-23-SPTRQD" style="display: inline-block;"></div>
				<div id="Traceplot-24-SV" style="display: inline-block;"></div>
				<div id="Traceplot-25-AcouI" style="display: inline-block;"></div>
				<div id="Traceplot-26-FR" style="display: inline-block;"></div>
				<div id="Traceplot-27-TC" style="display: inline-block;"></div>
				<div id="Traceplot-28-CA" style="display: inline-block;"></div>
				<div id="Traceplot-29-QP" style="display: inline-block;"></div>
				<div id="Traceplot-30-QS" style="display: inline-block;"></div>
				<div id="Traceplot-31-Res" style="display: inline-block;"></div>
				<div id="Traceplot-32-ET" style="display: inline-block;"></div>
				<div id="Traceplot-33-MT" style="display: inline-block;"></div>
				<div id="Traceplot-34-PT" style="display: inline-block;"></div>
				<div id="Traceplot-35-PP" style="display: inline-block;"></div>
				<div id="Traceplot-36-MT" style="display: inline-block;"></div>
				<div id="Traceplot-37-MP" style="display: inline-block;"></div>
				<div id="Traceplot-38-PC" style="display: inline-block;"></div>
				<div id="Traceplot-39-AP" style="display: inline-block;"></div>
				<div id="Traceplot-40-Temp" style="display: inline-block;"></div>
				<div id="Traceplot-41-AC" style="display: inline-block;"></div>
				<div id="Traceplot-42-OIL" style="display: inline-block;"></div>
				<div id="Traceplot-43-SAT" style="display: inline-block;"></div>
			</div>
			
			<div id="slide9" class="slides">
				<div class="heading-container" onclick="playAudioViewDataSetDescriptions()">
					<span class="play-symbol">&#128266;</span>
				</div>
				<button class="collapsible"><h2>Data Set Descriptions</h2></button>
				<div class="desccontent">
				  <div class="iframe-container">
					
				  </div>
				</div>
			</div>
			
			<div id="slide10" class="slides">
				<div class="heading-container" onclick="playAudioSiteModels()">
					<h2>Site Profiles</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-Profile1" class="chart-container" style="width: 100%;"></div>
				<div class="image-break"></div>
				<button id="Profanimation-btn">Start Profile Rotation</button>
				<div class="image-break"></div>
				
				<label for="correct-chart-checkbox">Correct Chart</label>
				<input type="checkbox" id="correct-chart-checkbox">
				<div class="image-break"></div>
				
				<form>
					<p style="font-size:18px; "><b>Select parameter to view : </b></p>
					<select onchange="updateProfilePlot(this.value)" onmousedown="if(this.options.length>8){this.size=8;}" onblur="this.size=0;" style="height: 550; font-size: 20px; max-width: 600px; width: 100%;">
						<optgroup label="Aquifer Classification">	
							<option value="dataset40">Aquifer Probability</option>
							<option value="dataset42">Aquiclude Probability</option>
							<option value="dataset2">Aquifer Type</option>
						</optgroup>
						<optgroup label="Aquifer Yield Estimates">	
							<option value="dataset5">Min Yield</option>
							<option value="dataset6">Max Yield</option>
							<option value="dataset7">Sus Yield</option>
						</optgroup>
						<optgroup label="Hydrological Properties">
							<option value="dataset4">Fractured Aquifer</option>
							<option value="dataset20">Water Quality</option>
							<option value="dataset9">Matrix Hydraulic Conductivity</option>
							<option value="dataset37">Matrix Transmissivity</option>
							<option value="dataset38">Matrix Permeability</option>
							<option value="dataset8">Porespace Hydraulic Conductivity</option>
							<option value="dataset35">Porespace Transmissivity</option>
							<option value="dataset36">Porespace Permeability</option>
							<option value="dataset11">Specific Storage</option>
							<option value="dataset12">Storativity</option>
							<option value="dataset13">Porespace Diffusivity</option>
							<option value="dataset39">Permeability Contrast</option>
							<option value="dataset45">Saturation</option>
						</optgroup>
						<optgroup label="GeoTechnical Properties">
							<option value="dataset1">Formation Type</option>
							<option value="dataset22">Formation Fracturing</option>
							<option value="dataset21">Formation Aquifer Indicator</option>
							<option value="dataset15">Density</option>
							<option value="dataset10">Porosity</option>
							<option value="dataset16">Shear Modulus</option>
							<option value="dataset17">Bulk Modulus</option>
							<option value="dataset19">Youngs Modulus</option>
							<option value="dataset18">Compressibility</option>
							<option value="dataset33">Poisson Ratio</option>
							<option value="dataset34">Specific Volume</option>
							<option value="dataset14">Clay Content</option>
							<option value="dataset23">SPTN</option>
							<option value="dataset24">SPTRQD</option>
						</optgroup>
						<optgroup label="Acoustic Properties">	
							<option value="dataset25">Seismic P-Wave Velocity</option>
							<option value="dataset26">Acoustic Impeadance</option>
							<option value="dataset27">Frenzel Radius</option>
							<option value="dataset28">Transmission Coefficient</option>
							<option value="dataset29">Critical Angle</option>
							<option value="dataset30">Seismic Attenuation Qp</option>
							<option value="dataset31">Seismic Attenuation Qs</option>
						</optgroup>
						<optgroup label="Electrical Properties">
							<option value="dataset32">Apparent Bulk Resistivity</option>
						</optgroup>
						<optgroup label="Geothermal Properties">	
							<option value="dataset41">Formation Temperature</option>
							<!-- <option value="dataset3">Condition</option>-->
						</optgroup>
						<optgroup label="Hydrocarbon Properties">
							<option value="dataset43">Hydrocarbon Potential</option>
						</optgroup>
					</select>
				</form>
				
				<div style="max-width: 1000px;" style="text-align: justify;">
				<p class=MsoNormal><b>Note </b>– All data referenced to first selected point coordinate.</p>
				</div>
				
				<div class="heading-container" onclick="playCreateSiteProfileViews()">
					<h4>Create Site Profile Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>	
				<div id="controls">
					<select id="viewSelector3" onchange="updateDescription3()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
					</select>
					<input type="text" id="description3" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView3()">&#8593;</button>
					<button onclick="nextView3()">&#8595;</button>
					<button onclick="savePlot3()">Save View</button>
					<button onclick="loadPlot3()">Load View</button>
				</div>
				
				<div class="heading-container" onclick="playCreatePresentationViews()">
					<h4>Create Presentation Views :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="controls">
					<select id="viewSelector7" onchange="updateDescription7()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description7" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="savePlot7()">Save View</button>
				</div>
				
				<div class="heading-container" onclick="audioPlayerSelectProfilePoints()">
					<h4>Select Profile Points :</h4>
					<span class="play-symbol">&#128266;</span>
				</div>
				
				<div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileOneForm()">View Profile One Points</button>
					<div id="profileFormOne" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormOne">
							<fieldset>
								<legend>Select Profile One Points:</legend>
								<ul id="ProfilecheckboxListOne"></ul>
							</fieldset>
							<button type="button" onclick="ProfileselectAllOne()">Select All</button>
							<button type="button" onclick="ProfiledeselectAllOne()">Deselect All</button>
							<button type="button" onclick="ProfileshowSelectedPointsOne()">Render Profile</button>
							<input type="text" id="ProfileOneSelectionName" placeholder="Selection Name">
							<button type="button" onclick="ProfileOnesaveSelection()">Save Selection</button>
							<select id="ProfileOneSelectionDropdown"></select>
							<button type="button" onclick="ProfileOneloadSelection()">Load Selection</button>
							<button type="button" onclick="DeleteSelectionProfileOne()">Delete Selection</button>
							<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
				
				<br><div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileTwoForm()">View Profile Two Points</button>
					<div id="profileFormTwo" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormTwo">
							<fieldset>
								<legend>Select Profile Two Points:</legend>
								<ul id="ProfilecheckboxListTwo"></ul>
							</fieldset>
							<button type="button" onclick="ProfileselectAllTwo()">Select All</button>
							<button type="button" onclick="ProfiledeselectAllTwo()">Deselect All</button>
							<button type="button" onclick="ProfileshowSelectedPointsTwo()">Render Profile</button>
							<input type="text" id="ProfileTwoSelectionName" placeholder="Selection Name">
							<button type="button" onclick="ProfileTwosaveSelection()">Save Selection</button>
							<select id="ProfileTwoSelectionDropdown"></select>
							<button type="button" onclick="ProfileTwoloadSelection()">Load Selection</button>
							<button type="button" onclick="DeleteSelectionProfileTwo()">Delete Selection</button>
							<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
				
				<br><div style="max-width: 1100px;">
					<button class="collapsible" type="button" onclick="toggleProfileThreeForm()">View Profile Three Points</button>
					<div id="profileFormThree" style="max-width: 100%; display: none;">
						<form id="ProfilecheckboxFormThree">
							<fieldset>
							<legend>Select Profile Three Points:</legend>
							<ul id="ProfilecheckboxListThree"></ul>
						</fieldset>
						<button type="button" onclick="ProfileselectAllThree()">Select All</button>
						<button type="button" onclick="ProfiledeselectAllThree()">Deselect All</button>
						<button type="button" onclick="ProfileshowSelectedPointsThree()">Render Profile</button>
						<input type="text" id="ProfileThreeSelectionName" placeholder="Selection Name">
						<button type="button" onclick="ProfileThreesaveSelection()">Save Selection</button>
						<select id="ProfileThreeSelectionDropdown"></select>
						<button type="button" onclick="ProfileThreeloadSelection()">Load Selection</button>
						<button type="button" onclick="DeleteSelectionProfileThree()">Delete Selection</button>
						<button type="button" onclick="DeleteSelectionAll()">Delete All Selections</button>
						</form>
					</div>
				</div>
			</div>
		
			<div id="slide11" class="slides">
		
				<!--<div class="block-container">
						<br><div class="heading-container" onclick="playViewControls()">
							<h2>View Controls</h2>
							<span class="play-symbol">&#128266;</span>
						</div>
						<div id="controls">
							<button onclick="saveAllDataToFile()">Save All View Data to File</button>
							<input type="file" id="fileInput" style="display:none;" onchange="loadAllDataFromFile(event)">
							<button onclick="document.getElementById('fileInput').click()">Load all View Data from File</button>
						</div>
					</div>-->
			
				<div class="heading-container" onclick="playPresentationViews()">
					<h2>Presentation Views</h2>
					<span class="play-symbol">&#128266;</span>
				</div>
				<div id="plotly-presentation" class="chart-container"></div>
				<div class="image-break"></div>
				
				<div class="heading-container">
					<h4>Select presentation view :</h4>
				</div>
				<div id="controls">
					<select id="viewSelector9" onchange="updateDescription9()">
						<option value="0">View 1</option>
						<option value="1">View 2</option>
						<option value="2">View 3</option>
						<option value="3">View 4</option>
						<option value="4">View 5</option>
						<option value="5">View 6</option>
						<option value="6">View 7</option>
						<option value="7">View 8</option>
						<option value="8">View 9</option>
						<option value="9">View 10</option>
						<option value="10">View 11</option>
						<option value="11">View 12</option>
						<option value="12">View 13</option>
						<option value="13">View 14</option>
						<option value="14">View 15</option>
						<option value="15">View 16</option>
						<option value="16">View 17</option>
						<option value="17">View 18</option>
						<option value="18">View 19</option>
						<option value="19">View 20</option>
						<option value="20">View 21</option>
						<option value="21">View 22</option>
						<option value="22">View 23</option>
						<option value="23">View 24</option>
						<option value="24">View 25</option>
						<option value="25">View 26</option>
						<option value="26">View 27</option>
						<option value="27">View 28</option>
						<option value="28">View 29</option>
						<option value="29">View 30</option>
						<option value="30">View 31</option>
						<option value="31">View 32</option>
						<option value="32">View 33</option>
						<option value="33">View 34</option>
						<option value="34">View 35</option>
						<option value="35">View 36</option>
						<option value="36">View 37</option>
						<option value="37">View 38</option>
						<option value="38">View 39</option>
						<option value="39">View 40</option>
						<option value="40">View 41</option>
						<option value="41">View 42</option>
						<option value="42">View 43</option>
						<option value="43">View 44</option>
						<option value="44">View 45</option>
						<option value="45">View 46</option>
						<option value="46">View 47</option>
						<option value="47">View 48</option>
						<option value="48">View 49</option>
						<option value="49">View 50</option>
					</select>
					<input type="text" id="description9" placeholder="Enter view description here" style="max-width: 300px; width: 100%;">
					<button onclick="prevView9()">&#8593;</button>
					<button onclick="nextView9()">&#8595;</button>
					<button onclick="loadPlot9()">Load View</button>
				</div>
			</div>
		</div>
		
		<audio id="audioPlayerIntroduction" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Introduction 2.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSurveySiteMap" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Survey Site Map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerRecommendations" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Recommendations.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSurveyPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Survey Points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerViewDataSetDescriptions" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View data descriptions.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerAquiferClassification" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Aquifer classification map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerWaterSheds" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Water Shed map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerLithology" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Lithology map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerGroundwaterLevel" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Groundwater level map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerFaulting" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Faulting map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSalineAquifers" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Saline aquifers map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerGeothermal" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Geothermal map.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteParameterMaps" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site parameters maps.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteSectionLine" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site Section Line.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSectionSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Section Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSelectSectionPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select section points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteModels" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site models.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerModelSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Model settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSliceSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Slice settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerPointDataTraces" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Point data traces.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerPointVirtualLogs" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Point Virtual Logs.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSelectModelPoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select Model points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSelectProfilePoints" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Select Model points.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<audio id="audioPlayerSiteMapSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Site Map Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerReportDataElevationSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Report Data Elevation Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerViewGISDataMaps" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View GIS Data Maps.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteParameterMapViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Parameter Map Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreatePresentationViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Presentation Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteSectionLineViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Section Line Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerSectionAmplitudeSettings" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Section Amplitude Settings.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteProfileViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Profile Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerCreateSiteModelViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Create Site Model Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerViewControls" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/View Controls.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
				
		<audio id="audioPlayerPresentationViews" controls style="display: none;">
		  <source src="https://www.atsps2.net/Audio/Presentation Views.mp3" type="audio/mpeg">
		  Your browser does not support the audio element.
		</audio>
		
		<script>
			var VolData =[];
			var VolDataMax = 0;
			var isominValue = 70;
			var isomaxValue = 100;
			var selectedDataHold = 'dataset1'
			var HoldModelUnit = '';
			var TopEndMeshdataHold = [];
			var rawTopdataHold = [];
			var logscatterdataHold = [];
			var VolumeState = 1;
			var TopographyState = 1;
			var PointsState = 1;
			var LogState = 1;
			var DepthSliceState = 1;
			var LatSliceState = 1;
			var LonSliceState = 1;
			var SectionLogsState = 0;
			var FracturePointState = 0;
			var ExternalDataState = 0;
			var HoldFracscatterData = [];
			var HoldSectioncontourData = [];
			var HoldSectionLogscatterData = [];
			var HoldSectionExtLogscatterData = [];
			var HoldSectionToplineData = [];
			var HoldSectionBottomlineData = [];
			var HoldSectionlayout = [];
			var HoldcontourDataScatter = [];
			var HoldLayout = [];
			var DepthSliceCount = 50;
			var LatSliceCount = 15;
			var LonSliceCount = 15;
			var UpdateSliceDepthArray = [];
			var UpdateSliceLatArray = [];
			var UpdateSliceLonArray = [];
			var SiteMapcontourData = []; 
			var SiteMapscatterData = [];
			var HoldSiteMaplayout = [];
			var SectionBoxData = [];
			var ModelBoxData = [];
			var HoldselectedData = '';
			var HolddataLith = [];
			var HolddataAqui = [];
			var HolddataCond = [];
			var HolddataFrac = [];
			var HolddataMin = [];
			var HolddataMax = [];
			var HolddataSus = [];
			var HolddataPrimK = [];
			var HolddataSecK = [];
			var HolddataPoro = [];
			var HolddataSStor = [];
			var HolddataStor = [];
			var HolddataDiff = [];
			var HolddataClay = [];
			var HolddataDens = [];
			var HolddataShear = [];
			var HolddataBulk = [];
			var HolddataComp = [];
			var HolddataYong = [];
			var HolddataWQ = [];
			var HolddataAI = [];
			var HolddataFC = [];
			var HolddataSPTN = [];
			var HolddataSPTRQD = [];
			var HolddataSV = [];
			var HolddataAcouI = [];
			var HolddataFR = [];
			var HolddataTC = [];
			var HolddataCA = [];
			var HolddataQP = [];
			var HolddataQS = [];
			var HolddataRes = [];
			var HolddataET = [];
			var HolddataMagT = [];
			var HolddataPT = [];
			var HolddataPP = [];
			var HolddataMT = [];
			var HolddataMP = [];
			var HolddataPC = [];
			var HolddataAP = [];
			var HolddataTemp = [];
			var HolddataAquilude = [];
			var HolddataOil = [];
			var HolddataSAT = [];
			var ProfileBoxData = new Array(3);
			for (var i = 0; i < ProfileBoxData.length; i++) {
				ProfileBoxData[i] = [];
			}
			var HoldProfileSurfaceGroup = [];
			var HoldProfilerawTopdata = [];
			var HoldProfileLayout = [];
			var ProfileselectedDataHold = 'dataset1';
			var ContourBoxData = [];
			var ContourHoldselectedData = '';
			var gd = document.getElementById('plotly-Model1');
			var animationButton = document.getElementById('animation-btn');
			var animationInterval;
			var isAnimating = false;
			var Profgd = document.getElementById('plotly-Profile1');
			var ProfanimationButton = document.getElementById('Profanimation-btn');
			var ProfanimationInterval;
			var ProfisAnimating = false;
			var SiteMapShowRecPointsOnly = false;
			var SiteMapShowRecPointsOnlychanged = false;
			var SiteMapmarkers = [];
			var SiteMapmarkersInst;
			var UserSetmaxValue = 100;
			var map1;
			var map2;
			var map3;
			var map4;
			var map5;
			var map6;
			var map7;
			var map8;
			var HoldPresentationLayout =[];			
			var SRTMLoaded = 0;
			var BoxElevationArray = [];
			let SRTMelevations = [];			
			let GlobalTemperature = 25;			
			let CorrectChart = 0;					
			var SiteMaplines = [];
			var SiteMapShowLines = false;
			var SiteMapShowRecomendationPoints = false;
			var RecDetected = false;
			
			const FormationFractureCondition = [
			  'Unfractured',
			  'Fractured'
			];
			
			const FormationCondition = [
			  'Unaltered',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Weathered',
			  'Fractured',
			  'Porous',
			  'Fractured',
			  'Course',
			  'Fine',
			  'Soil'
			];

			const AquiferTypeFull = [  
			  'Unclassified',
			  'Weathered Ultra Mafic',
			  'Fractured Ultra Mafic',
			  'Weathered Metamorphic',
			  'Fractured Metamorphic',
			  'Weathered Mafic',
			  'Fractured Mafic',
			  'Weathered Igneous',
			  'Fractured Igneous',
			  'Weathered Conglomerate',
			  'Fractured Conglomerate',
			  'Weathered Volcanic',
			  'Fractured Volcanic',
			  'Weathered Sedimentary',
			  'Fractured Sedimentary',
			  'Dual Porosity Sediment',
			  'Unconsolidated Sediment',
			  'Saturated Soil'
			];
			
			const AquiferType = [
			  'Unclassified',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Hard',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Consolidated',
			  'Dual Porosity',
			  'Unconsolidated',
			  'Saturated'
			];

			const LithType = [
			  'Unclassified',
			  'Soil',
			  'Sediment',
			  'Volcanic',
			  'Conglomerate',
			  'Sedimentary',
			  'Igneous',
			  'Salt',
			  'Mafic',
			  'Metamorphic',
			  'Ultra Mafic'
			];
			
			const AquiferTypeColor = [
			  'LightGrey',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'Teal',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'SkyBlue',
			  'Blue',
			  'Navy',
			  'Aqua'
			];

			const LithTypeColor = [
			  'LightGrey',
			  'Brown',
			  'Yellow',
			  'Silver',
			  'Green',
			  'Orange',
			  'MediumGray',
			  'Cream',
			  'Gray',
			  'DarkGrey',
			  'Black'
			];
						
			%%%@@@			
			$$$PQR@@@			
			$$$ABC@@@			
			$$$DEF@@@			
			$$$GHI@@@			
			$$$JKL@@@			
			$$$MNO@@@			
			&&&###
			
			var datasets = {
				dataset1: {
				  name: 'Calculated Sustainable Yield Estimate(l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cjegt9c5l1x672qqghx7cya9p',
				  SectionName : 'Calculated Formation Type Estimate',
				  LegendUnit: 'Lith Group',
				  SectionIndex : 2,
				  Index : 0
				},
				dataset2: {
				  name: 'Calculated Minimum Yield Estimate (l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cjegw9m9q5xi32sn7gk1h9cyr',
				  SectionName : 'Calculated Aquifer Type Estimate',
				  LegendUnit: 'Aqui Group',
				  SectionIndex : 3,
				  Index : 1
				},
				dataset3: {
				  name: 'Calculated Maximum Yield Estimate (l/s)',
				  unit: 'l/s',
				  ID : 'atsgeosuite/cj574xv2o32t32so13rwxp8xd',
				  SectionName : 'Calculated Formation Condition Estimate',
				  LegendUnit: 'Cond',
				  SectionIndex : 4,
				  Index : 2
				},
				dataset4: {
				  name: 'Calculated Ground water level Estimate (mbgl)',
				  unit: 'mbgl',
				  ID : 'atsgeosuite/cj4kr154256zy2sn5j1fhpjru',
				  SectionName : 'Calculated Aquifer Formation Fracturing Estimate',
				  LegendUnit: 'Frac',
				  SectionIndex : 5,
				  Index : 3
				},
				dataset5: {
				  name: 'Calculated Drilling Depth Estimate (mbgl)',
				  unit: 'mbgl',
				  ID : 'atsgeosuite/cj574ejge327j2rmtgchz8002',
				  SectionName : 'Calculated Min Yeild Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 6,
				  Index : 4
				},
				dataset6: {
				  name: 'Calculated Risk (%)',
				  unit: '%',
				  ID : 'atsgeosuite/cjegvjtxi1zbg2qqg0kgzsqul',
				  SectionName : 'Calculated Max Yield Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 7,
				  Index : 5
				},
				dataset7: {
				  name: 'Calculated Interpretion Confidence (%)',
				  unit: '%',
				  ID : 'atsgeosuite/cjfs65s3j1fd52sn2fl9rfc74',
				  SectionName : 'Calculated Sus Yield Estimate (l/s)',
				  LegendUnit: 'l/s',
				  SectionIndex : 8,
				  Index : 6
				},
				dataset8: {
				  name: 'Measured Correlation (%)',
				  unit: '%',
				  ID : '',
				  SectionName : 'Calculated Porespace Hydraulic Conductivity Estimate (m/d)',
				  LegendUnit: 'm/d',
				  SectionIndex : 9,
				  Index : 7
				},
				dataset9: {
				  name: 'Measured Signal to Noise Ratio',
				  unit: 'SNR',
				  ID : '',
				  SectionName : 'Calculated Matrix Hydraulic Conductivity Estimate (m/d)',
				  LegendUnit: 'm/d',
				  SectionIndex : 10,
				  Index : 8
				},
				dataset10: {
				  name: 'Measured Strikes Used',
				  unit: 'Strikes',
				  ID : '',
				  SectionName : 'Calculated Porosity Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 11,
				  Index : 9
				},
				dataset11: {
				  name: 'Measured GPS Elevation (masl)',
				  unit: 'masl',
				  ID : '',
				  SectionName : 'Calculated Specific Storage Estimate (1/m)',
				  LegendUnit: '1/m',
				  SectionIndex : 12,
				  Index : 10
				},
				dataset12: {
				  name: 'Calculated Sustainable Yield Estimate 100m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Storativity Estimate',
				  LegendUnit: 'unitless',
				  SectionIndex : 13,
				  Index : 11
				},
				dataset13: {
				  name: 'Calculated Sustainable Yield Estimate 200m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Porespace Diffusivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 14,
				  Index : 12
				},
				dataset14: {
				  name: 'Calculated Sustainable Yield Estimate 300m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Clay Content Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 15,
				  Index : 13
				},
				dataset15: {
				  name: 'Calculated Sustainable Yield Estimate 400m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Density Estimate (kg/m3)',
				  LegendUnit: 'kg/m3',
				  SectionIndex : 16,
				  Index : 14
				},
				dataset16: {
				  name: 'Calculated Sustainable Yield Estimate 500m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Shear Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 17,
				  Index : 15
				},
				dataset17: {
				  name: 'Calculated Sustainable Yield Estimate 600m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Bulk Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 18,
				  Index : 16
				},
				dataset18: {
				  name: 'Calculated Sustainable Yield Estimate 700m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Compressibility Estimate (1/Pa)',
				  LegendUnit: '1/Pa',
				  SectionIndex : 19,
				  Index : 17
				},
				dataset19: {
				  name: 'Calculated Sustainable Yield Estimate 800m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Youngs Modulus Estimate (Pa)',
				  LegendUnit: 'Pa',
				  SectionIndex : 20,
				  Index : 18
				},
				dataset20: {
				  name: 'Calculated Sustainable Yield Estimate 900m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Relative Water Quality Estimate (%)',
				  LegendUnit: '%',
				  SectionIndex : 21,
				  Index : 19
				},
				dataset21: {
				  name: 'Calculated Sustainable Yield Estimate 1000m (l/s)',
				  unit: 'l/s',
				  ID : '',
				  SectionName : 'Calculated Formation Aquifer Indicator',
				  LegendUnit: 'unitless',
				  SectionIndex : 22,
				  Index : 20
				},
				dataset22: {
				  name: 'Calculated Soil Depth (mbgl)',
				  unit: 'mbgl',
				  ID : '',
				  SectionName : 'Measured Formation Fracturing (Count)',
				  LegendUnit: 'Count',
				  SectionIndex : 23,
				  Index : 21
				},
				dataset23: {
				  name: 'Calculated Soil Density (kg/m3)',
				  unit: 'kg/m3',
				  ID : '',
				  SectionName : 'Calculated SPTN Estimate (Unitless)',
				  LegendUnit: 'Unitless',
				  SectionIndex : 24,
				  Index : 22
				},
				dataset24: {
				  name: 'Calculated Soil Porosity (%)',
				  unit: '%',
				  ID : '',
				  SectionName : 'Calculated SPTRQD Estimate (Unitless)',
				  LegendUnit: 'Unitless',
				  SectionIndex : 25,
				  Index : 23
				},
				dataset25: {
				  name: 'Calculated Soil Shear Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Seismic P-Wave Velocity Estimate (m/s)',
				  LegendUnit: 'm/s',
				  SectionIndex : 26,
				  Index : 24
				},
				dataset26: {
				  name: 'Calculated Soil Bulk Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Acoustic Impeadance Estimate (Pa s/m3)',
				  LegendUnit: 'Pa s/m3',
				  SectionIndex : 27,
				  Index : 25
				},
				dataset27: {
				  name: 'Calculated Soil Compressibility (1/Pa)',
				  unit: '1/Pa',
				  ID : '',
				  SectionName : 'Calculated Frenzel Radius Estimate (m)',
				  LegendUnit: 'm',
				  SectionIndex : 28,
				  Index : 26
				},
				dataset28: {
				  name: 'Calculated Soil Poisson Ratio (Ratio)',
				  unit: 'Ratio',
				  ID : '',
				  SectionName : 'Calculated Transmittion Coefficient Estimate (Coeff)',
				  LegendUnit: 'Coeff',
				  SectionIndex : 29,
				  Index : 27
				},
				dataset29: {
				  name: 'Calculated Soil Youngs Modulus (Pa)',
				  unit: 'Pa',
				  ID : '',
				  SectionName : 'Calculated Critical Angle Estimate (Deg)',
				  LegendUnit: 'Deg',
				  SectionIndex : 30,
				  Index : 28
				},
				dataset30: {
				  name: 'Calculated Soil Acoustic Impeadance (Pa s/m3)',
				  unit: 'Pa s/m3',
				  ID : '',
				  SectionName : 'Calculated Seismic Attenuation Qp Estimate (GPa)',
				  LegendUnit: 'GPa',
				  SectionIndex : 31,
				  Index : 29
				},
				dataset31: {
				  name: 'Calculated Soil Storativity',
				  unit: 'unitless',
				  ID : '',
				  SectionName : 'Calculated Seismic Attenuation Qs Estimate (GPa)',
				  LegendUnit: 'GPa',
				  SectionIndex : 32,
				  Index : 30
				},
				dataset32: {
				  name: 'Calculated Soil Diffusivity (m2/d)',
				  unit: 'm2/d',
				  ID : '',
				  SectionName : 'Calculated Apparent Bulk Resistivity Estimate (Ohm.m)',
				  LegendUnit: 'Ohm.m',
				  SectionIndex : 33,
				  Index : 31
				},
				dataset33: {
				  name: 'Calculated Soil Hydraulic Conductivity (m/d)',
				  unit: 'm/d',
				  ID : '',
				  SectionName : 'Calculated Poisson Ratio Estimate (Ratio)',
				  LegendUnit: 'Ratio',
				  SectionIndex : 34,
				  Index : 32
				},
				dataset34: {
				  name: 'Calculated Soil Transmissivity (m2/d)',
				  unit: 'm2/d',
				  ID : '',
				  SectionName : 'Calculated Specific Volume Estimate (m3/kg)',
				  LegendUnit: 'm3/kg',
				  SectionIndex : 35,
				  Index : 33
				},
				dataset35: {
				  name: 'Calculated Soil Permeability (md)',
				  unit: 'md',
				  ID : 'QUl6YQ==',
				  SectionName : 'Calculated Porespace Transmissivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 36,
				  Index : 34
				},
				dataset36: {
				  name: 'Calculated Soil Clay Content (%)',
				  unit: '%',
				  ID : 'U3lBcw==',
				  SectionName : 'Calculated Porespace Permeability Estimate (md)',
				  LegendUnit: 'md',
				  SectionIndex : 37,
				  Index : 35
				},
				dataset37: {
				  name: 'Calculated Soil SPTN (Unitless)',
				  unit: 'Unitless',
				  ID : 'RkJ3Zw==',
				  SectionName : 'Calculated Matrix Transmisivity Estimate (m2/d)',
				  LegendUnit: 'm2/d',
				  SectionIndex : 38,
				  Index : 36
				},
				dataset38: {
				  name: 'Calculated Soil SPTRQD (Unitless)',
				  unit: 'Unitless',
				  ID : 'bWQzX2I=',
				  SectionName : 'Calculated Matrix Permeability Estimate (md)',
				  LegendUnit: 'md',
				  SectionIndex : 39,
				  Index : 37
				},
				dataset39: {
				  name: 'Noise (v)',
				  unit: 'V',
				  ID : 'VzF0LVpv',
				  SectionName : 'Calculated Permeability Contrast Estimate (Ratio)',
				  LegendUnit: 'Ratio',
				  SectionIndex : 40,
				  Index : 38
				},
				dataset40: {
				  name: 'Processing Depth (m)',
				  unit: 'm',
				  ID : 'MV9OZnM=',
				  SectionName : 'Calculated Aquifer Probability (%)',
				  LegendUnit: '%',
				  SectionIndex : 41,
				  Index : 39
				},
				dataset41: {
				  name: 'Vertical Resolution (m)',
				  unit: 'm',
				  ID : 'ZW9fTlE5',
				  SectionName : 'Calculated Formation Temperature Estimate (DegC)',
				  LegendUnit: 'DegC',
				  SectionIndex : 42,
				  Index : 40
				},
				dataset42: {
				  name: 'Uncertainty (%)',
				  unit: '%',
				  ID : 'ZWl3MkE=',
				  SectionName : 'Calculated Relative Formation Aquiclude Probability (%)',
				  LegendUnit: '%',
				  SectionIndex : 43,
				  Index : 41
				},
				dataset43: {
				  name: 'Magnetic Field Strength (nT)',
				  unit: 'nT',
				  ID : '',
				  SectionName : 'Calculated Hydrocarbon Potential (%)',
				  LegendUnit: '%',
				  SectionIndex : 44,
				  Index : 42
				},
				dataset44: {
				  name: '',
				  unit: '',
				  ID : '',
				  SectionName : 'Calculated Seismic Reflection',
				  LegendUnit: '',
				  SectionIndex : 45,
				  Index : 43
				},
				dataset45: {
				  name: '',
				  unit: '',
				  ID : '',
				  SectionName : 'Calculated Formation Saturation',
				  LegendUnit: '%',
				  SectionIndex : 45, //This index is 45 because the Seismic reflection data is calculated and not in BoxData
				  Index : 44
				}
			};
			
			for (let i = 0; i < BoxData.data.length; i++)
			{
				BoxData.data[i][1] = parseFloat(BoxData.data[i][1]);
				BoxData.data[i][2] = parseFloat(BoxData.data[i][2]);
				BoxData.data[i][3][10] = parseFloat(BoxData.data[i][3][10]);
			}

			for (let i = 0; i < BoxData.data.length; i++)
			{
				if (BoxData.data[i][4] > 0)
				{
					RecDetected = true;
				}
			}
			if (RecDetected == false)
			{
				let indexedData = BoxData.data.map((item, index) => ({ originalIndex: index, data: item }));
				indexedData.sort((a, b) => b.data[3][0] - a.data[3][0]);
				indexedData.forEach((item, rank) => {
					item.data[4] = rank + 1;
				});
				//BoxData.data = indexedData.map(item => item.data);
			
			}
			
			var tableHTML = '<table>';
			var ReccomCount = 1;
			tableHTML += '<tr><th>Rec No.</th><th>Point</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th></th></tr>';
			
			for (var i = 0; i < 10; i++)
			{
			BoxData.data.forEach(function(row) 
			{
				if (row[4] == i)
				{
					tableHTML += '<tr>';
					tableHTML += '<td>' + row[4] + '</td>';
					tableHTML += '<td>' + row[0] + '</td>';
					tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>';     // Lat
					tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>';     // Lon
					tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
					tableHTML += '<td>' + row[3][0] + '</td>';
					tableHTML += '<td>' + row[3][1] + '</td>';
					tableHTML += '<td>' + row[3][2] + '</td>';
					tableHTML += '<td>' + row[3][5] + '</td>';
					tableHTML += '<td>' + row[3][6] + '</td>';
					tableHTML += '<td>' + row[3][4] + '</td>';
					tableHTML += '</tr>';
				}
			});
			}
			tableHTML += '</table>';
			document.getElementById('RecdataTable').innerHTML = tableHTML;

			function refreshRecTable() {
				// Initialize the table HTML with headers
				var tableHTML = '<table>';
				tableHTML += '<tr><th>Rec No.</th><th>Point</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th></th></tr>';

				// Loop through data and populate the table rows
				for (var i = 0; i < 10; i++) {
					BoxData.data.forEach(function(row) {
						if (row[4] == i) {
							tableHTML += '<tr>';
							tableHTML += '<td>' + row[4] + '</td>'; // Rec No.
							tableHTML += '<td>' + row[0] + '</td>'; // Point
							tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>'; // Lat
							tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>'; // Lon
							tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
							tableHTML += '<td>' + row[3][0] + '</td>'; // Sust. yield (l/s)
							tableHTML += '<td>' + row[3][1] + '</td>'; // Min yield (l/s)
							tableHTML += '<td>' + row[3][2] + '</td>'; // Max yield (l/s)
							tableHTML += '<td>' + row[3][5] + '</td>'; // Risk (%)
							tableHTML += '<td>' + row[3][6] + '</td>'; // Interp. Confidence (%)
							tableHTML += '<td>' + row[3][4] + '</td>'; // Drill Depth (mbgl)
							tableHTML += '</tr>';
						}
					});
				}

				// Close the table tag
				tableHTML += '</table>';

				// Update the DOM with the new table HTML
				document.getElementById('RecdataTable').innerHTML = tableHTML;
			}
			
			function ProfilecreateCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ProfilecheckboxListOne');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ProfileBoxData[0].push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointOne';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedOne(checkbox);
					});
				}
			
				const checkboxListTwo = document.getElementById('ProfilecheckboxListTwo');
				for (let i = 0; i < DataArray.length; i++) 
				{
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointTwo';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = false;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxListTwo.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedTwo(checkbox);
					});
				}
			
				const checkboxListThree = document.getElementById('ProfilecheckboxListThree');
				for (let i = 0; i < DataArray.length; i++) 
				{
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'PPointThree';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = false;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxListThree.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ProfilecheckboxChangedThree(checkbox);
					});
				}
			}
			ProfilecreateCheckboxes();
			
			function ProfileselectAllOne() 
			{
				ProfileBoxData[0] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointOne');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[0].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllOne() 
			{
				ProfileBoxData[0] = [];
				const checkboxes = document.getElementsByName('PPointOne');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedOne(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[0].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsOne() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointOne');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ProfileselectAllTwo() 
			{
				ProfileBoxData[1] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointTwo');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[1].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllTwo() 
			{
				ProfileBoxData[1] = [];
				const checkboxes = document.getElementsByName('PPointTwo');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedTwo(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[1].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsTwo() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointTwo');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ProfileselectAllThree() 
			{
				ProfileBoxData[2] = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointThree');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ProfileBoxData[2].push(DataArray[checkbox.value]);
				});
			}

			function ProfiledeselectAllThree() 
			{
				ProfileBoxData[2] = [];
				const checkboxes = document.getElementsByName('PPointThree');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ProfilecheckboxChangedThree(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ProfileBoxData[2].push(DataArray[checkbox.value]);
				}
			}

			function ProfileshowSelectedPointsThree() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('PPointThree');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateProfilePlot(ProfileselectedDataHold);
					generateSiteMapProfileLines(map1);
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function ModelcreateCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ModelcheckboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ModelBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'MPoint';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ModelcheckboxChanged(checkbox);
					});
				}
			}
			ModelcreateCheckboxes();
			
			function ModelselectAll() 
			{
				ModelBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('MPoint');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ModelBoxData.push(DataArray[checkbox.value]);
				});
			}

			function ModeldeselectAll() 
			{
				ModelBoxData = [];
				const checkboxes = document.getElementsByName('MPoint');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ModelcheckboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ModelBoxData.push(DataArray[checkbox.value]);
				}
			}

			function ModelshowSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('MPoint');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateVolumePlot(selectedDataHold);
					generateSiteMapLines(map1, ModelBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function createCheckboxesContour() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('ContourcheckboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					ContourBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'CPoint';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						ContourcheckboxChanged(checkbox);
					});
				}
			}
			createCheckboxesContour();
			
			function ContourselectAll() 
			{
				ContourBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('CPoint');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					ContourBoxData.push(DataArray[checkbox.value]);
				});
			}

			function ContourdeselectAll() 
			{
				ContourBoxData = [];
				const checkboxes = document.getElementsByName('CPoint');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function ContourcheckboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					ContourBoxData.push(DataArray[checkbox.value]);
				}
			}

			function ContourshowSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('CPoint');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateContourPlot(ContourHoldselectedData);
					generateSiteMapLines(map1, ContourBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			function createCheckboxes() 
			{
				var DataArray = BoxData.data;
				const checkboxList = document.getElementById('checkboxList');
				for (let i = 0; i < DataArray.length; i++) 
				{
					SectionBoxData.push(DataArray[i]);
					const listPoint = document.createElement('li');
					listPoint.style.width = "calc(10% - 12px)";
					const checkbox = document.createElement('input');
					checkbox.type = 'checkbox';
					checkbox.name = 'Point';
					checkbox.value = i;
					checkbox.id = 'Point' + DataArray[i][0];
					checkbox.checked = true;
					const label = document.createElement('label');
					label.htmlFor = 'Point' + DataArray[i][0];
					label.appendChild(document.createTextNode('Point ' + DataArray[i][0]));
					listPoint.appendChild(checkbox);
					listPoint.appendChild(label);
					checkboxList.appendChild(listPoint);
					checkbox.addEventListener('change', function() 
					{
						checkboxChanged(checkbox);
					});
				}
			}
			createCheckboxes();
			
			function selectAll() 
			{
				SectionBoxData = [];
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('Point');
				checkboxes.forEach(checkbox => 
				{
					checkbox.checked = true;
					SectionBoxData.push(DataArray[checkbox.value]);
				});
			}

			function deselectAll() 
			{
				SectionBoxData = [];
				const checkboxes = document.getElementsByName('Point');
				checkboxes.forEach(checkbox => {
					checkbox.checked = false;
				});
			}

			function checkboxChanged(checkbox) 
			{
				var DataArray = BoxData.data;
				
				if (!checkbox.checked) 
				{
					checkbox.checked = true;
				} 
				else 
				{
					SectionBoxData.push(DataArray[checkbox.value]);
				}
			}

			function showSelectedPoints() 
			{
				var DataArray = BoxData.data;
				const checkboxes = document.getElementsByName('Point');
				let selectedCount = 0;
				checkboxes.forEach(checkbox => 
				{
					if (checkbox.checked) 
					{
						selectedCount++;
					}
				});
				if (selectedCount >= 2)
				{
					updateSectionPlot(HoldselectedData);
					generateSiteMapLines(map1, SectionBoxData, "Selection");
				}
				else
				{
					alert("Only one checkbox is selected. Please select at least two checkboxes.");
				}
			}

			if ( selectionPointArray.length === 0)
			{
				selectionPointArray.push({
					name: "All",
					data: SectionBoxData
				});
			
				const Contourdropdown = document.getElementById('ContourSelectionDropdown');
				Contourdropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Contourdropdown.appendChild(option);
				});

				const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
				Sectiondropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Sectiondropdown.appendChild(option);
				});
			
				const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
				ProfileOnedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileOnedropdown.appendChild(option);
				});
				
				const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
				ProfileTwodropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileTwodropdown.appendChild(option);
				});
				
				const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
				ProfileThreedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileThreedropdown.appendChild(option);
				});
				
				const Modeldropdown = document.getElementById('ModelSelectionDropdown');
				Modeldropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Modeldropdown.appendChild(option);
				});
			}
			else
			{
				const Contourdropdown = document.getElementById('ContourSelectionDropdown');
				Contourdropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Contourdropdown.appendChild(option);
				});
				
				const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
				Sectiondropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Sectiondropdown.appendChild(option);
				});
				
				const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
				ProfileOnedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileOnedropdown.appendChild(option);
				});
			
				const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
				ProfileTwodropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileTwodropdown.appendChild(option);
				});
			
				const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
				ProfileThreedropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					ProfileThreedropdown.appendChild(option);
				});
			
				const Modeldropdown = document.getElementById('ModelSelectionDropdown');
				Modeldropdown.innerHTML = '';

				selectionPointArray.forEach(selection => {
					const option = document.createElement('option');
					option.value = selection.name;
					option.innerText = selection.name;
					Modeldropdown.appendChild(option);
				});
			}
			
			function updateCheckboxList(checkboxListId, DataArray) {
				// Get the checkbox list element by ID
				const checkboxList = document.getElementById(checkboxListId);

				// Get all checkboxes within the checkbox list
				const checkboxes = checkboxList.getElementsByTagName('input');

				// Uncheck all checkboxes in the list
				for (let i = 0; i < checkboxes.length; i++) {
					checkboxes[i].checked = false; // Uncheck each checkbox
				}

				// Check the checkboxes that match DataArray
				for (let i = 0; i < DataArray.length; i++) {
					const checkboxId = 'Point' + DataArray[i][0]; // Generate checkbox ID from DataArray

					// Loop through checkboxes to find the matching one
					for (let v = 0; v < checkboxes.length; v++) {
						if (checkboxes[v].id === checkboxId) { // Corrected the condition by closing parenthesis
							checkboxes[v].checked = true; // Check the checkbox if the ID matches
						}
					}
				}
			}
			
			function RefreshSelectionDropdownLists() {
			  const Contourdropdown = document.getElementById('ContourSelectionDropdown');
			  Contourdropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Contourdropdown.appendChild(option);
			  });

			  const Sectiondropdown = document.getElementById('SectionSelectionDropdown');
			  Sectiondropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Sectiondropdown.appendChild(option);
			  });

			  const ProfileOnedropdown = document.getElementById('ProfileOneSelectionDropdown');
			  ProfileOnedropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileOnedropdown.appendChild(option);
			  });

			  const ProfileTwodropdown = document.getElementById('ProfileTwoSelectionDropdown');
			  ProfileTwodropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileTwodropdown.appendChild(option);
			  });

			  const ProfileThreedropdown = document.getElementById('ProfileThreeSelectionDropdown');
			  ProfileThreedropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				ProfileThreedropdown.appendChild(option);
			  });

			  const Modeldropdown = document.getElementById('ModelSelectionDropdown');
			  Modeldropdown.innerHTML = '';

			  selectionPointArray.forEach(selection => {
				const option = document.createElement('option');
				option.value = selection.name;
				option.innerText = selection.name;
				Modeldropdown.appendChild(option);
			  });
			}

			function ContoursaveSelection()
			{
				const selectionName = document.getElementById('ContourSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ContourBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ContourSelectionName').value = "";
			}
			
			function SectionsaveSelection()
			{
				const selectionName = document.getElementById('SectionSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: SectionBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('SectionSelectionName').value = "";
			}
			
			function ProfileOnesaveSelection()
			{
				const selectionName = document.getElementById('ProfileOneSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					//return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[0]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileOneSelectionName').value = "";
			}
			
			function ProfileTwosaveSelection()
			{
				const selectionName = document.getElementById('ProfileTwoSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[1]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileTwoSelectionName').value = "";
			}
			
			function ProfileThreesaveSelection()
			{
				const selectionName = document.getElementById('ProfileThreeSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ProfileBoxData[2]
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ProfileThreeSelectionName').value = "";
			}
			
			function ModelsaveSelection()
			{
				const selectionName = document.getElementById('ModelSelectionName').value;
				if (!selectionName) {
					alert('Please provide a name for the selection.');
					return;
				}
				
				selectionPointArray.push({
					name: selectionName,
					data: ModelBoxData
				});
			
				RefreshSelectionDropdownLists();
				document.getElementById('ModelSelectionName').value = "";
			}

			function ContourloadSelection()
			{
				const dropdown = document.getElementById('ContourSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ContourBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ContourcheckboxList', ContourBoxData);
				
				ContourshowSelectedPoints();
				generateSiteMapLines(map1, ContourBoxData, selectionName);
			}
			
			function SectionloadSelection()
			{
				const dropdown = document.getElementById('SectionSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					SectionBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('checkboxList', SectionBoxData);
				
				showSelectedPoints();
				generateSiteMapLines(map1, SectionBoxData, selectionName);
			}
			
			function ProfileOneloadSelection()
			{
				const dropdown = document.getElementById('ProfileOneSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[0] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListOne', ProfileBoxData[0]);
				
				ProfileshowSelectedPointsOne();
				generateSiteMapProfileLines(map1);
			}
			
			function ProfileTwoloadSelection()
			{
				const dropdown = document.getElementById('ProfileTwoSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[1] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListTwo', ProfileBoxData[1]);
				
				ProfileshowSelectedPointsTwo();
				generateSiteMapProfileLines(map1);
			}
			
			function ProfileThreeloadSelection()
			{
				const dropdown = document.getElementById('ProfileThreeSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ProfileBoxData[2] = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ProfilecheckboxListThree', ProfileBoxData[2]);
				
				ProfileshowSelectedPointsThree();
				generateSiteMapProfileLines(map1);
			}
			
			function ModelloadSelection()
			{
				const dropdown = document.getElementById('ModelSelectionDropdown');
				const selectionName = dropdown.value;

				if (!selectionName) {
					alert('Please select a selection from the Droplist.');
					return;
				}

				const foundSelection = selectionPointArray.find(selection => selection.name === selectionName);

				if (foundSelection) {
					ModelBoxData = foundSelection.data; // This will give you the corresponding data
				} else {
					alert("Selection not found");
				}
				
				updateCheckboxList('ModelcheckboxList', ModelBoxData);
				
				ModelshowSelectedPoints();
				generateSiteMapLines(map1, ModelBoxData, selectionName);
			}

			function selectTracePoint(Index) 
			{
			  var selectElement = document.getElementById("PointSelector");
			  selectElement.selectedIndex = Index;
			}
			
			function populateTraceDropdown() 
			{
				var dropdown = document.getElementById("PointSelector");
				dropdown.innerHTML = "<option value='' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}
			populateTraceDropdown();
			
			function selectPoint() 
			{
				var dropdown = document.getElementById("PointSelector");
				var selectedIndex = dropdown.value;
				if (selectedIndex === "") 
				{
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];
				var dataLith = [];
				var dataAqui = [];
				var dataCond = [];
				var dataFrac = [];
				var dataMin = [];
				var dataMax = [];
				var dataSus = [];
				var dataPrimK = [];
				var dataSecK = [];
				var dataPoro = [];
				var dataSStor = [];
				var dataStor = [];
				var dataDiff = [];
				var dataClay = [];
				var dataDens = [];
				var dataShear = [];
				var dataBulk = [];
				var dataComp = [];
				var dataYong = [];
				var dataWQ = [];
				var dataAI = [];
				var dataFC = [];
				var dataSPTN = [];
				var dataSPTRQD = [];
				var dataSV = [];
				var dataAcouI = [];
				var dataFR = [];
				var dataTC = [];
				var dataCA = [];
				var dataQP = [];
				var dataQS = [];
				var dataRes = [];
				var dataET = [];
				var dataMagT = [];
				var dataPT = [];
				var dataPP = [];
				var dataMT = [];
				var dataMP = [];
				var dataPC = [];
				var dataAP = [];
				var dataTemp = [];
				var dataAquilude = [];
				var dataOil = [];
				var dataSAT = [];
				
				for (var i = 0; i < selectedRowData[6].length; i++) 
				{
					dataLith.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][2]});
					dataLith.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][2]});
					dataAqui.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][3]});
					dataAqui.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][3]});
					dataCond.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][4]});
					dataCond.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][4]});
					dataFrac.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][5]});
					dataFrac.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][5]});
					dataMin.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][6]});
					dataMin.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][6]});
					dataMax.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][7]});
					dataMax.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][7]});
					dataSus.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][8]});
					dataSus.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][8]});
					dataPrimK.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][9]});
					dataPrimK.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][9]});
					dataSecK.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][10]});
					dataSecK.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][10]});
					dataPoro.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][11]});
					dataPoro.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][11]});
					dataSStor.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][12]});
					dataSStor.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][12]});
					dataStor.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][13]});
					dataStor.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][13]});
					dataDiff.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][14]});
					dataDiff.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][14]});
					dataClay.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][15]});
					dataClay.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][15]});
					dataDens.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][16]});
					dataDens.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][16]});
					dataShear.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][17]});
					dataShear.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][17]});
					dataBulk.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][18]});
					dataBulk.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][18]});
					dataComp.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][19]});
					dataComp.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][19]});
					dataYong.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][20]});
					dataYong.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][20]});
					dataWQ.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][21]});
					dataWQ.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][21]});		
					dataAI.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][22]});
					dataAI.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][22]});
					dataFC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][23]});
					dataFC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][23]});
					dataSPTN.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][24]});
					dataSPTN.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][24]});
					dataSPTRQD.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][25]});
					dataSPTRQD.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][25]});
					dataSV.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][26]});
					dataSV.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][26]});
					dataAcouI.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][27]});
					dataAcouI.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][27]});
					dataFR.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][28]});
					dataFR.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][28]});
					dataTC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][29]});
					dataTC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][29]});
					dataCA.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][30]});
					dataCA.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][30]});
					dataQP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][31]});
					dataQP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][31]});
					dataQS.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][32]});
					dataQS.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][32]});
					dataRes.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][33]});
					dataRes.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][33]});
					dataET.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][34]});
					dataET.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][34]});
					dataMagT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][35]});
					dataMagT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][35]});
					dataPT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][36]});
					dataPT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][36]});
					dataPP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][37]});
					dataPP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][37]});
					dataMT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][38]});
					dataMT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][38]});
					dataMP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][39]});
					dataMP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][39]});
					dataPC.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][40]});
					dataPC.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][40]});
					dataAP.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][41]});
					dataAP.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][41]});
					dataTemp.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][42] * GlobalTemperature + 10});
					dataTemp.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][42] * GlobalTemperature + 10});
					dataAquilude.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][43]});
					dataAquilude.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][43]});
					dataOil.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][44]});
					dataOil.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][44]});
					dataSAT.push({depth: selectedRowData[6][i][0], value: selectedRowData[6][i][45]});
					dataSAT.push({depth: selectedRowData[6][i][1] - 0.01, value: selectedRowData[6][i][45]});
				}
				HolddataLith = dataLith;
				HolddataAqui = dataAqui;
				HolddataCond = dataCond;
				HolddataFrac = dataFrac;
				HolddataMin = dataMin;
				HolddataMax = dataMax;
				HolddataSus = dataSus;
				HolddataPrimK = dataPrimK;
				HolddataSecK = dataSecK;
				HolddataPoro = dataPoro;
				HolddataSStor = dataSStor;
				HolddataStor = dataStor;
				HolddataDiff = dataDiff;
				HolddataClay = dataClay;
				HolddataDens = dataDens;
				HolddataShear = dataShear;
				HolddataBulk = dataBulk;
				HolddataComp = dataComp;
				HolddataYong = dataYong;
				HolddataWQ = dataWQ;
				HolddataAI = dataAI;
				HolddataFC = dataFC;
				HolddataSPTN = dataSPTN;
				HolddataSPTRQD = dataSPTRQD;
				HolddataSV = dataSV;
				HolddataAcouI = dataAcouI;
				HolddataFR = dataFR;
				HolddataTC = dataTC;
				HolddataCA = dataCA;
				HolddataQP = dataQP;
				HolddataQS = dataQS;
				HolddataRes = dataRes;
				HolddataET = dataET;
				HolddataMagT = dataMagT;
				HolddataPT = dataPT;
				HolddataPP = dataPP;
				HolddataMT = dataMT;
				HolddataMP = dataMP;
				HolddataPC = dataPC;
				HolddataAP = dataAP;
				HolddataTemp = dataTemp;
				HolddataAquilude = dataAquilude;
				HolddataOil = dataOil;
				HolddataSAT = dataSAT;
				UpdateTraces('Traceplot-0-Lith', dataLith, 'Lithology Type', 'Type');
				UpdateTraces('Traceplot-1-Aqui', dataAqui, 'Aquifer Type', 'Type');
				UpdateTraces('Traceplot-2-Cond', dataCond, 'Condition Type', 'Type');
				UpdateTraces('Traceplot-3-Frac', dataFrac, 'Fractured Aquifer', 'Presences');
				UpdateTraces('Traceplot-4-Min', dataMin, 'Minimum Yield', 'l/s');
				UpdateTraces('Traceplot-5-Max', dataMax, 'Maximum Yield', 'l/s');
				UpdateTraces('Traceplot-6-Sus', dataSus, 'Sustainable Yield', 'l/s');
				UpdateTraces('Traceplot-7-PrimK', dataPrimK, 'PoreSpace Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-8-SecK', dataSecK, 'Matrix Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-9-Poro', dataPoro, 'Porosity', '%');
				UpdateTraces('Traceplot-10-SStor', dataSStor, 'Specific Storage', '1/m');
				UpdateTraces('Traceplot-11-Stor', dataStor, 'Storativity', 'Unitless');
				UpdateTraces('Traceplot-12-Diff', dataDiff, 'Porespace Diffusivity', 'm2/s');
				UpdateTraces('Traceplot-13-Clay', dataClay, 'Clay Content', '%');
				UpdateTraces('Traceplot-14-Dens', dataDens, 'Density', 'kg/m3');
				UpdateTraces('Traceplot-15-Shear', dataShear, 'Shear Modulus', 'Pa');
				UpdateTraces('Traceplot-16-Bulk', dataBulk, 'Bulk Modulus', 'Pa');
				UpdateTraces('Traceplot-17-Comp', dataComp, 'Compressibility', '1/Pa');
				UpdateTraces('Traceplot-18-Yong', dataYong, 'Youngs Modulus', 'Pa');
				UpdateTraces('Traceplot-19-WQ', dataWQ, 'Relative Water Quality', 'Rel %');
				UpdateTraces('Traceplot-20-AI', dataAI, 'Aquifer Indicator', 'Presence');
				UpdateTraces('Traceplot-21-FC', dataFC, 'Formation Fracturing', 'Count');
				UpdateTraces('Traceplot-22-SPTN', dataSPTN, 'SPTN', 'Unitless');
				UpdateTraces('Traceplot-23-SPTRQD', dataSPTRQD, 'SPTRQD', 'Unitless');
				UpdateTraces('Traceplot-24-SV', dataSV, 'Seismic P-Wave Velocity', 'm/s');
				UpdateTraces('Traceplot-25-AcouI', dataAcouI, 'Acoustic Impeadance', 'Pa s/m3');
				UpdateTraces('Traceplot-26-FR', dataFR, 'Frenzel Radius', 'm');
				UpdateTraces('Traceplot-27-TC', dataTC, 'Transmission Coefficient', 'Coeff');
				UpdateTraces('Traceplot-28-CA', dataCA, 'Critical Angle', 'Deg');
				UpdateTraces('Traceplot-29-QP', dataQP, 'Seismic Attenuation Qp', 'GPa');
				UpdateTraces('Traceplot-30-QS', dataQS, 'Seismic Attenuation Qs', 'GPa');
				UpdateTraces('Traceplot-31-Res', dataRes, 'Apparent Resistivity', 'Ohm/m');
				UpdateTraces('Traceplot-32-ET', dataET, 'Poisson Ratio', 'Ratio');
				UpdateTraces('Traceplot-33-MT', dataMagT, 'Specific Volume', 'm3/kg');
				UpdateTraces('Traceplot-34-PT', dataPT, 'Porespace Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-35-PP', dataPP, 'Porespace Permeability', 'md');
				UpdateTraces('Traceplot-36-MT', dataMT, 'Matrix Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-37-MP', dataMP, 'Matrix Permeability', 'md');
				UpdateTraces('Traceplot-38-PC', dataPC, 'Permeability Contrast', 'Ratio');
				UpdateTraces('Traceplot-39-AP', dataAP, 'Aquifer Probability', '%');
				UpdateTraces('Traceplot-40-Temp', dataTemp, 'Calculated Temperature Estimate', 'degC');
				UpdateTraces('Traceplot-41-AC', dataAquilude, 'Calculated Relative Aquiclude Probability Estimate', '%');
				UpdateTraces('Traceplot-42-OIL', dataOil, 'Calculated Hydrocarbon Potential', '%');
				UpdateTraces('Traceplot-43-SAT', dataSAT, 'Calculated Saturation', '%');
			}

			function UpdateTraces(Chart, DataSet, ChartTitle, Units)
			{
				try {
				let depths = DataSet.map(item => item.depth);
				let values = DataSet.map(item => item.value);
				let trace = {
					x: depths,
					y: values,
					type: 'scatter',
					mode: 'lines',
					orientation: 'h',
					fill: 'tozeroy',
					fillcolor: 'rgba(211,211,211,0.3)',
					line: {
						color: 'black'
					}
				};
				let layout = {
					margin: {t:25,r:5,b:5,l:5},
					title: {
						automargin: true,
						standoff: 5,
						text: '<b>' + ChartTitle + '</b>',
						
						font: {
							size: 16

						}
					},
					xaxis: {
						title: 'Depth (mbgl)',
						automargin: true,
						standoff: 5
					},
					yaxis: {
						title: Units,
						automargin: true,
						standoff: 5
					},
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: 140
				};
				Plotly.newPlot(Chart, [trace], layout);
				} catch (error) {}
			}

			function LogPoint(Index) {
			  var selectElement = document.getElementById("rowSelector");
			  selectElement.selectedIndex = Index;
			}

			function populateDropdown() 
			{
				var dropdown = document.getElementById("rowSelector");
				dropdown.innerHTML = "<option value='' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}

			function DC(Str) {
				try {
					return atob(Str); // atob is a built-in function to decode Base64 strings
				} catch (error) {
					return null; // Return null if decoding fails
				}
			}
			
			function selectRow() 
			{
				var dropdown = document.getElementById("rowSelector");
				var selectedIndex = dropdown.value;
				if (selectedIndex === "") 
				{
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];
				var tableBody = document.getElementById("selectedRow");
				tableBody.innerHTML = "";
				for (var i = 0; i < selectedRowData[6].length; i++) 
				{
					var newRow = document.createElement("tr");
					var rowHeight = Math.floor(Math.abs(selectedRowData[6][i][1] - selectedRowData[6][i][0])*5);
					newRow.style.height = rowHeight + "px";
					var cell = document.createElement("td");
					cell.textContent = i + 1;
					newRow.appendChild(cell);
					var cell2 = document.createElement("td");
					cell2.textContent = '';
					cell2.style.backgroundColor = LithTypeColor[selectedRowData[6][i][2]];
					newRow.appendChild(cell2);
					var cell3 = document.createElement("td");
					cell3.textContent = '';
					cell3.style.backgroundColor = AquiferTypeColor[selectedRowData[6][i][3]];
					newRow.appendChild(cell3);
					for (var x = 0; x < selectedRowData[6][i].length; x++) 
					{
						var cell = document.createElement("td");
						if (x == 2)
						{
							if (selectedRowData[6][i][x] < 11)
							{
								cell.textContent = LithType[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==3)
						{
							if (selectedRowData[6][i][x] < 18)
							{
								cell.textContent = AquiferType[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==4)
						{
							if (selectedRowData[6][i][x] < 18)
							{
								cell.textContent = FormationCondition[selectedRowData[6][i][x]];
							}
							else
							{
								cell.textContent = '';
							}
						}
						else if (x==5)
						{
							if (selectedRowData[6][i][x] == 1)
							{
								cell.textContent = 'Fractured';
							}
							else
							{
								cell.textContent = '';
							}
						}
						else
						{
							if (x == 0)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 1)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 6)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 7)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 8)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 9)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 10)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 11)
							{
								cell.textContent = selectedRowData[6][i][x];//*100;
							}
							else if (x == 12)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 13)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 14)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 15)
							{
								cell.textContent = selectedRowData[6][i][x];
							}
							else if (x == 16)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 17)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 18)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 19)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 20)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 21)
							{
								cell.textContent = selectedRowData[6][i][x];//*100;
							}
							else if (x == 22)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 23)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 24)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 25)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 26)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 27)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 28)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 29)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 30)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 31)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 32)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 33)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 34)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 35)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 36)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 37)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 38)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 39)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 40)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 41)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 42)
							{
								cell.textContent = (selectedRowData[6][i][x] * GlobalTemperature + 10).toExponential(2);
							}
							else if (x == 43)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 44)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
							else if (x == 45)
							{
								cell.textContent = selectedRowData[6][i][x].toExponential(2);
							}
						}
						newRow.appendChild(cell);
					}
					tableBody.appendChild(newRow);
				}
			}
			populateDropdown();
			
			const AAC = DC(datasets['dataset35'].ID) +
						DC(datasets['dataset36'].ID) + 
						DC(datasets['dataset37'].ID) +
						DC(datasets['dataset38'].ID) +
						DC(datasets['dataset39'].ID) +
						DC(datasets['dataset40'].ID) +
						DC(datasets['dataset41'].ID) +
						DC(datasets['dataset42'].ID);
			
			var tableHTML = '<table>';
			tableHTML += '<tr><th>Point</th><th>Rec No.</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th>Vert. Res (m)</th><th>Uncertainty (%)</th><th></th></tr>';
			BoxData.data.forEach(function(row) 
			{
				tableHTML += '<tr>';
				tableHTML += '<td>' + row[0] + '</td>';
				tableHTML += '<td>' + row[4] + '</td>';
				tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>';     // Lat
				tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>';     // Lon
				tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
				tableHTML += '<td>' + row[3][0] + '</td>';
				tableHTML += '<td>' + row[3][1] + '</td>';
				tableHTML += '<td>' + row[3][2] + '</td>';
				tableHTML += '<td>' + row[3][5] + '</td>';
				tableHTML += '<td>' + row[3][6] + '</td>';
				tableHTML += '<td>' + row[3][4] + '</td>';
				tableHTML += '<td>' + row[3][40] + '</td>';
				tableHTML += '<td>' + row[3][41] + '</td>';
				tableHTML += '</tr>';
			});
			tableHTML += '</table>';
			document.getElementById('dataTable').innerHTML = tableHTML;

			function refreshdataTable() {
				// Initialize the table HTML with headers
				var tableHTML = '<table>';
				tableHTML += '<tr><th>Point</th><th>Rec No.</th><th>Lat</th><th>Lon</th><th>Elev (masl)</th><th>Sust. yield (l/s)</th><th>Min yield (l/s)</th><th>Max yield (l/s)</th><th>Risk (%)</th><th>Interp. Confidence (%)</th><th>Drill Depth (mbgl)</th><th>Vert. Res (m)</th><th>Uncertainty (%)</th><th></th></tr>';

				// Loop through BoxData data and populate the table rows
				BoxData.data.forEach(function(row) {
					tableHTML += '<tr>';
					tableHTML += '<td>' + row[0] + '</td>';                            // Point
					tableHTML += '<td>' + row[4] + '</td>';                            // Rec No.
					tableHTML += '<td>' + parseFloat(row[1]).toFixed(6) + '</td>';     // Lat
					tableHTML += '<td>' + parseFloat(row[2]).toFixed(6) + '</td>';     // Lon
					tableHTML += '<td>' + parseFloat(row[3][10]).toFixed(1) + '</td>'; // Elev (masl)
					tableHTML += '<td>' + row[3][0] + '</td>';
					tableHTML += '<td>' + row[3][1] + '</td>';
					tableHTML += '<td>' + row[3][2] + '</td>';
					tableHTML += '<td>' + row[3][5] + '</td>';
					tableHTML += '<td>' + row[3][6] + '</td>';
					tableHTML += '<td>' + row[3][4] + '</td>';
					tableHTML += '<td>' + row[3][40] + '</td>';
					tableHTML += '<td>' + row[3][41] + '</td>';
					tableHTML += '</tr>';
					tableHTML += '</tr>';
				});

				// Close the table tag
				tableHTML += '</table>';

				// Update the DOM with the new table HTML
				document.getElementById('dataTable').innerHTML = tableHTML;
			}
			
			function generateWaypoints(map, data) {
				
				//for (var i = 0; i < GISMapmarkers.length; i++) {
				//		map.removeLayer(GISMapmarkers[i]);
				//	}
				
				//map.eachLayer(function (layer) {
				//	map.removeLayer(layer);
				//});
				
				map.eachLayer(function (layer) {
					// Check if the layer is a marker
					if (layer instanceof L.Marker) {
						map.removeLayer(layer);
					}
				});
				
				//GISMapmarkers = [];
				
				let CurrentIndex = 0;
				data.forEach(function (waypoint) {
					var IconLink = '';
					if ((waypoint[4] <= 9)  && (SiteMapShowRecomendationPoints == true)) {
						IconLink = 'http://maps.google.com/mapfiles/kml/paddle/' + waypoint[4] + '.png';
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [40, 40],
							iconAnchor: [20, 24],
							popupAnchor: [0, -24]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: false }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -20], className: 'text-label' }).openTooltip();

						
					} else {
						IconLink = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle_highlight.png';
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [20, 20],
							iconAnchor: [10, 12],
							popupAnchor: [0, -12]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: false }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -4], className: 'text-label' }).openTooltip();

						
					}
				});
			}
			
			function generateSiteMapWaypoints(map, data) {
				if (SiteMapShowRecPointsOnlychanged == true) {
					for (var i = 0; i < SiteMapmarkers.length; i++) {
						map.removeLayer(SiteMapmarkers[i]);
					}
				}
				else
				{
					for (var i = 0; i < SiteMapmarkers.length; i++) {
						map.removeLayer(SiteMapmarkers[i]);
					}
				}

				SiteMapmarkers = [];

				let CurrentIndex = 0;
				
				data.forEach(function (waypoint) {
					var tableHTML = "<table>";
					tableHTML += "<tr><th>Property</th><th>Value</th><th>Unit</th></tr>";
					tableHTML += "<tr><td>Point</td><td>" + waypoint[0] + "</td><td>no</td></tr>";
					tableHTML += "<tr><td>Recommendation</td><td>" + waypoint[4] + "</td><td>no</td></tr>";
					tableHTML += "<tr><td>Latitude</td><td>" + waypoint[1] + "</td><td>WGS84</td></tr>";
					tableHTML += "<tr><td>Longitude</td><td>" + waypoint[2] + "</td><td>WGS84</td></tr>";
					tableHTML += "<tr><td>Elevation</td><td>" + waypoint[3][10] + "</td><td>masl</td></tr>";
					tableHTML += "<tr><td>Sustainable Yield</td><td>" + waypoint[3][0] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>Minimum Yield</td><td>" + waypoint[3][1] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>Maximum Yield</td><td>" + waypoint[3][2] + "</td><td>l/s</td></tr>";
					tableHTML += "<tr><td>GWL</td><td>" + waypoint[3][3] + "</td><td>mbgl</td></tr>";
					tableHTML += "<tr><td>Drill Depth</td><td>" + waypoint[3][4] + "</td><td>mbgl</td></tr>";
					tableHTML += "<tr><td>Risk</td><td>" + waypoint[3][5] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>Confidence</td><td>" + waypoint[3][6] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>Correlation</td><td>" + waypoint[3][7] + "</td><td>%</td></tr>";
					tableHTML += "<tr><td>SNR</td><td>" + waypoint[3][8] + "</td><td>Ratio</td></tr>";
					tableHTML += "</table>";

					var IconLink = 'http://maps.google.com/mapfiles/kml/paddle/' + waypoint[4] + '.png';
					if ((waypoint[4] <= 9)  && (SiteMapShowRecomendationPoints == true)) {
						var customIcon = L.icon({
							iconUrl: IconLink,
							iconSize: [40, 40],
							iconAnchor: [20, 24],
							popupAnchor: [0, -24]
						});
						// Add draggable: true to enable marker dragging
						var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: true }).addTo(map);
						marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -20], className: 'text-label' }).openTooltip();
						marker.bindPopup(tableHTML, { maxWidth: 500 });
						marker.index = CurrentIndex;
						CurrentIndex = CurrentIndex + 1;
						SiteMapmarkers.push(marker);
					
						marker.on('dragend', function (event) {
							let marker = event.target;
							let position = marker.getLatLng();
							console.log(`Marker moved to: Lat: ${position.lat}, Lng: ${position.lng}`);
							
							document.getElementById("rowSelectorEditPoint").selectedIndex = marker.index+1;
							
							document.getElementById("LatInput").value = position.lat;
							document.getElementById("LonInput").value = position.lng;
							
							BoxData.data[marker.index][1] = parseFloat(document.getElementById("LatInput").value);
							BoxData.data[marker.index][2] = parseFloat(document.getElementById("LonInput").value);
							refreshRecTable();
							refreshdataTable();
							updateAllMaps();
							EditSectionData();
						});
					
					} else {
						if (SiteMapShowRecPointsOnly == false) {
							IconLink = 'http://maps.google.com/mapfiles/kml/shapes/placemark_circle_highlight.png';
							var customIcon = L.icon({
								iconUrl: IconLink,
								iconSize: [20, 20],
								iconAnchor: [10, 12],
								popupAnchor: [0, -12]
							});
							// Add draggable: true to enable marker dragging
							var marker = L.marker([waypoint[1], waypoint[2]], { icon: customIcon, draggable: true }).addTo(map);
							marker.bindTooltip('' + waypoint[0], { permanent: true, direction: 'top', offset: [0, -4], className: 'text-label' }).openTooltip();
							marker.bindPopup(tableHTML, { maxWidth: 500 });
							marker.index = CurrentIndex;
							CurrentIndex = CurrentIndex + 1;
							SiteMapmarkers.push(marker);
						
							marker.on('dragend', function (event) {
								let marker = event.target;
								let position = marker.getLatLng();
								console.log(`Marker moved to: Lat: ${position.lat}, Lng: ${position.lng}`);
								
								document.getElementById("rowSelectorEditPoint").selectedIndex = marker.index+1;
								
								document.getElementById("LatInput").value = position.lat;
								document.getElementById("LonInput").value = position.lng;
								
								BoxData.data[marker.index][1] = parseFloat(document.getElementById("LatInput").value);
								BoxData.data[marker.index][2] = parseFloat(document.getElementById("LonInput").value);
								refreshRecTable();
								refreshdataTable();
								updateAllMaps();
								EditSectionData();
							});
						}
					}
				});
			}

			function updateSiteMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = BoxData.data;  
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));  
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				map1 = L.map('map1', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				SiteMapmarkersInst = map1;
				
				L.tileLayer(`https://{s}.google.com/vt/lyrs=y&x={x}&y={y}&z={z}&key=${AAC}`, {
					maxZoom: 22,
					subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
				}).addTo(map1);
				generateSiteMapWaypoints(map1, pointData);
				L.control.scale().addTo(map1);
				
				L.Control.LatLngAxis = L.Control.extend({
					onAdd: function(map1) {
						var container = L.DomUtil.create('div');
						container.innerHTML = 'Lat: <span id="lat"></span> | Lng: <span id="lng"></span>';
						container.style.background = 'rgba(255, 255, 255, 0.7)';
						container.style.padding = '5px';
						container.style.borderRadius = '5px';
						return container;
					},

					onRemove: function(map1) {
						// Nothing to do here
					}
				});

				L.control.latLngAxis = function(opts) {
					return new L.Control.LatLngAxis(opts);
				};

				L.control.latLngAxis({ position: 'topright' }).addTo(map1);
				
				map1.on('mousemove', function(e) {
					document.getElementById('lat').textContent = e.latlng.lat.toFixed(6);
					document.getElementById('lng').textContent = e.latlng.lng.toFixed(6);
				});
				
				} catch (error) {}
			}
			
			function refreshSiteMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = BoxData.data;  
				generateSiteMapWaypoints(SiteMapmarkersInst, pointData);
				} catch (error) {alert('Error: ' + error);}
			}
			
			function updateAquiferMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map2) 
				{
					map2.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map2 = L.map('map2').setView([avgLat, avgLon], 13);
				//var map2 = L.map('map2', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map2);
				generateWaypoints(map2, pointData);
				L.control.scale().addTo(map2);
				} catch (error) {}
			}
			
			function updateWaterShedMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map6) 
				{
					map6.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map6 = L.map('map6').setView([avgLat, avgLon], 13);
				//var map6 = L.map('map6', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map6);
				generateWaypoints(map6, pointData);
				L.control.scale().addTo(map6);
				} catch (error) {}
			}
			
			function updateGWLMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map3) 
				{
					map3.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map3 = L.map('map3').setView([avgLat, avgLon], 13);
				//var map3 = L.map('map3', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map3);
				generateWaypoints(map3, pointData);
				L.control.scale().addTo(map3);
				} catch (error) {}
			}
			
			function updateFaultMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map4) 
				{
					map4.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map4 = L.map('map4').setView([avgLat, avgLon], 13);
				//var map4 = L.map('map4', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map4);
				generateWaypoints(map4, pointData);
				L.control.scale().addTo(map4);
				} catch (error) {}
			}
			
			function updateLithMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map5) 
				{
					map5.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map5 = L.map('map5').setView([avgLat, avgLon], 13);
				//var map5 = L.map('map5', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map5);
				generateWaypoints(map5, pointData);
				L.control.scale().addTo(map5);
				} catch (error) {}
			}

			function updateSalineMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map7) 
				{
					map7.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map7 = L.map('map7').setView([avgLat, avgLon], 13);
				//var map7 = L.map('map7', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map7);
				generateWaypoints(map7, pointData);
				L.control.scale().addTo(map7);
				} catch (error) {}
			}
			
			function updateGeothermalMap(selectedData) 
			{
				try {
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var newID = dataset.ID;;
				var pointData = BoxData.data;
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var avgLat = minLat + (maxLat - minLat)/2;
				var avgLon = minLon + (maxLon - minLon)/2;
				if (map8) 
				{
					map8.remove();
				}
				var mapboxToken = 'pk.eyJ1IjoiYXRzZ2Vvc3VpdGUiLCJhIjoiY2ozcGtpaG9uMDAyNDJ3a2N1enhvc3d6aCJ9.lmnP-f5pd_7PC15i9LRXTQ';
				map8 = L.map('map8').setView([avgLat, avgLon], 13);
				//var map8 = L.map('map8', {zoomControl: false }).fitBounds([[minLat, minLon], [maxLat, maxLon]]);
				L.tileLayer('https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token=' + mapboxToken, {
					maxZoom: 22,
					attribution: '' +
						'Imagery © <a href="https://www.mapbox.com/">Mapbox</a>',
					id: newID,
					tileSize: 512,
					zoomOffset: -1
				}).addTo(map8);
				generateWaypoints(map8, pointData);
				L.control.scale().addTo(map8);
				} catch (error) {}
			}

			function updateContourPlot(selectedData) 
			{
				try {
				ContourHoldselectedData = selectedData;
				
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.Index;
				var pointData = ContourBoxData;//BoxData.data;
				var gridSize = 25;
				function inverseDistanceWeight(x, y, points, datasetInd) {
					var sum = 0;
					var weightsSum = 0;
					for (var i = 0; i < points.length; i++) 
					{
						var point = points[i];
						var d = Math.sqrt(Math.pow(x - point[2], 2) + Math.pow(y - point[1], 2));
						if (d === 0) return point[3];
						sum += (point[3][datasetInd] / d);
						weightsSum += (1 / d);
					}
					return sum / weightsSum;
				}
				var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				var maxLat = Math.max.apply(null, pointData.map(function(point) { return point[1]; }));
				var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				var interpolatedZ = [];
				for (var i = 0; i < gridSize; i++) 
				{
					var row = [];
					for (var j = 0; j < gridSize; j++) 
					{
						var lat = minLat + (i / (gridSize - 1)) * (maxLat - minLat);
						var lon = minLon + (j / (gridSize - 1)) * (maxLon - minLon);
						var elevation = inverseDistanceWeight(lon, lat, pointData, datasetIndex);
						row.push(elevation);
					}
					interpolatedZ.push(row);
				}
				var scatterData = {
					x: pointData.map(function(point) { return point[2]; }),
					y: pointData.map(function(point) { return point[1]; }),
					mode: 'markers+text',
					marker: {
					  color: 'black',
					  size: 10
					},
					type: 'scatter',
					text: pointData.map(function(point) { return point[0]; }),
					textposition: 'top center',
					textfont: {
					  color: 'black',
					  size: 18
					}
				};
				var contourData = {
					z: interpolatedZ,
					type: 'contour',
					contours: {
					  coloring: 'heatmap'
					},
					colorscale: 'Rainbow',
					x: [],
					y: [],
					colorbar: {
						title: dataset.unit
					}
				};
				for (var i = 0; i < gridSize; i++) 
				{
					contourData.x.push(minLon + i * ((maxLon - minLon) / (gridSize - 1)));
					contourData.y.push(minLat + i * ((maxLat - minLat) / (gridSize - 1)));
				}
				var layout = {
					title: {
					  text: '<b>' + dataset.name + '</b>',
					  font: {
						size: 16
					  }
					},
					xaxis: {title: 'Longitude'},
					yaxis: {title: 'Latitude'},
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7
				};
				
				SiteMapcontourData = contourData; 
				SiteMapscatterData = scatterData;
				HoldSiteMaplayout = layout;
				Plotly.newPlot('plotly-contour', [contourData, scatterData], layout);
				} catch (error) {}
			}
				
			function createMultiDimensionalArray(rows, cols) 
			{
				var multiArray = [];
				for (var i = 0; i < rows; i++) 
				{
					var innerArray = [];
					for (var j = 0; j < cols; j++) 
					{
						innerArray.push(0);
					}
					multiArray.push(innerArray);
				}
				return multiArray;
			}	
				
			function toRadians(degrees) 
			{
				return degrees * Math.PI / 180;
			}	
				
			function calculateDistance(lat1, lon1, lat2, lon2) 
			{
				const earthRadiusKm = 6371;
				const lat1Rad = toRadians(lat1);
				const lon1Rad = toRadians(lon1);
				const lat2Rad = toRadians(lat2);
				const lon2Rad = toRadians(lon2);
				const dLat = lat2Rad - lat1Rad;
				const dLon = lon2Rad - lon1Rad;
				const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1Rad) * Math.cos(lat2Rad) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
				const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
				const distance = earthRadiusKm * c * 1000;
				return distance;
			}	
			
			function updateSectionPlot(selectedData) 
			{
				try {
				HoldselectedData = selectedData;
				if (selectedData == 'dataset44')
				{
				
				
					var DataArray = SectionBoxData;
					const wellLogs = [];
					let Totaldistance = 0.0;
					let PrevLat = DataArray[0][1];
					let PrevLon = DataArray[0][2];

					
					
					function calculateStructDistance(lat1, lon1, lat2, lon2) {
						const earthRadiusKm = 6371;
						const lat1Rad = toRadians(lat1);
						const lon1Rad = toRadians(lon1);
						const lat2Rad = toRadians(lat2);
						const lon2Rad = toRadians(lon2);
						const dLat = lat2Rad - lat1Rad;
						const dLon = lon2Rad - lon1Rad;
						const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
								  Math.cos(lat1Rad) * Math.cos(lat2Rad) *
								  Math.sin(dLon / 2) * Math.sin(dLon / 2);
						const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
						return earthRadiusKm * c * 1000; // Convert to meters
					}

					function interpolateReflectivity(wellLogs) {
						const depths = Array.from(new Set(wellLogs.flatMap(well => well.data.map(d => d.depth)))).sort((a, b) => a - b);
						const lateralPositions = Array.from(new Set(wellLogs.map(well => well.x))).sort((a, b) => a - b);

						const reflectivityGrid = depths.map(() => new Array(lateralPositions.length).fill(NaN));

						wellLogs.forEach(well => {
							well.data.forEach(point => {
								const depthIndex = depths.indexOf(point.depth);
								const lateralIndex = lateralPositions.indexOf(well.x);
								if (depthIndex !== -1 && lateralIndex !== -1) {
									reflectivityGrid[depthIndex][lateralIndex] = point.reflectivity;
								}
							});
						});

						// Directional weighting parameters with non-linear emphasis
						const depthWeight = 2;  // Depth continuity weight
						const lateralWeight = 1; // Lateral continuity weight
						const peakEmphasisFactor = 1.5; // Emphasize peaks and troughs

						// Enhanced interpolation with peak and trough emphasis and directional weighting
						for (let i = 0; i < reflectivityGrid.length; i++) {
							for (let j = 0; j < reflectivityGrid[i].length; j++) {
								if (isNaN(reflectivityGrid[i][j])) {
									let weightedSum = 0, weightTotal = 0;
									for (let di = -1; di <= 1; di++) {
										for (let dj = -1; dj <= 1; dj++) {
											// Check for valid indices and apply weighting within the 45-degree slope constraint
											if (di !== 0 || dj !== 0) { 
												const ni = i + di, nj = j + dj;
												if (ni >= 0 && ni < reflectivityGrid.length && nj >= 0 && nj < reflectivityGrid[i].length && !isNaN(reflectivityGrid[ni][nj])) {
													// Apply directional weights with non-linear emphasis on peaks and troughs
													const reflectivity = reflectivityGrid[ni][nj];
													const weight = ((di !== 0 ? depthWeight : 0) + (dj !== 0 ? lateralWeight : 0)) * Math.pow(Math.abs(reflectivity), peakEmphasisFactor);
													weightedSum += reflectivity * weight;
													weightTotal += weight;
												}
											}
										}
									}
									if (weightTotal > 0) {
										reflectivityGrid[i][j] = weightedSum / weightTotal;
									}
								}
							}
						}

						// Null data outside the well log's top and bottom elevations
						wellLogs.forEach(well => {
							let topDepth = well.data[0].depth;
							let bottomDepth = well.endDepth; // Use endDepth for the bottom boundary
							depths.forEach((depth, depthIndex) => {
								if (depth < bottomDepth || depth > topDepth) {
									const lateralIndex = lateralPositions.indexOf(well.x);
									if (lateralIndex !== -1) {
										reflectivityGrid[depthIndex][lateralIndex] = null;
									}
								}
							});
						});

						return { depths, lateralPositions, reflectivityGrid };
					}

					function toRadians(degrees) {
						return degrees * Math.PI / 180;
					}

					function displayWellLogs(wellLogs) {
						const outputDiv = document.getElementById('wellLogsOutput');
						const wellLogsJson = JSON.stringify(wellLogs, null, 2);
						const preElement = document.createElement('pre');
						preElement.textContent = wellLogsJson;
						outputDiv.innerHTML = '';
						outputDiv.appendChild(preElement);
					}
					
					
					
					for (let i = 0; i < DataArray.length; i++) {
						let distance = calculateStructDistance(PrevLat, PrevLon, DataArray[i][1], DataArray[i][2]);
						Totaldistance += distance;
						PrevLat = DataArray[i][1];
						PrevLon = DataArray[i][2];

						let startDepth = DataArray[i][3][10]; 
						let wellLog = [];
						let reflectivityValue = 0;
						for (let x = 0; x < DataArray[i][5]; x++) {
							let currentDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							if (x == 0)
							{
								reflectivityValue = 0;
							}
							else
							{
								reflectivityValue = (DataArray[i][6][x][27]- DataArray[i][6][x-1][27])/(DataArray[i][6][x][27]+ DataArray[i][6][x-1][27]);
							}
							 
							wellLog.push({ depth: currentDepth, reflectivity: reflectivityValue });
						}
						wellLogs.push({ PointName: DataArray[i][0], x: Totaldistance, data: wellLog, startDepth, endDepth: startDepth - DataArray[i][6][DataArray[i][6].length - 1][1] });
					}

					const { depths, lateralPositions, reflectivityGrid } = interpolateReflectivity(wellLogs);

					const topBoundaryLine = {
						x: wellLogs.map(well => well.x),
						y: wellLogs.map(well => well.data[0].depth), // Top depth of each well
						type: 'scatter',
						mode: 'lines',
						line: { color: 'black', width: 2 },
						name: 'Top Elevation Boundary',
						showlegend: false
					};

					const bottomBoundaryLine = {
						x: wellLogs.map(well => well.x),
						y: wellLogs.map(well => well.endDepth), // Bottom depth defined by endDepth
						type: 'scatter',
						mode: 'lines',
						line: { color: 'black', width: 2 },
						name: 'Bottom Elevation Boundary',
						showlegend: false
					};

					Plotly.newPlot('plotly-Sections', [
						{
							z: reflectivityGrid,
							x: lateralPositions,
							y: depths,
							type: 'heatmap',
							colorscale: 'Greys',
							zsmooth: 'best',
							reversescale: true
						},
						{
							x: wellLogs.map(well => well.x),
							y: wellLogs.map(well => well.startDepth),
							mode: 'markers+text',
							marker: { color: 'black', size: 8 },
							text: wellLogs.map(well => well.PointName),
							textposition: 'top right',
							showlegend: false
						},
						topBoundaryLine,
						bottomBoundaryLine
					], {
						title: {
							text: '<b>' + 'Seismic Reflection' + '</b>',
							font: {
								size: 16
							}
						},
						xaxis: {
							title: 'Distance (m)',
							//showgrid: false,
							range: [Math.min(...lateralPositions), Math.max(...lateralPositions)]
						},
						yaxis: {
							title: 'Depth (masl)',
							//showgrid: false
						},
						width: Math.min(window.outerWidth-100, window.innerWidth-100),
						height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7
						//margin: { t: 30, r: 30, b: 40, l: 50 },
						//paper_bgcolor: 'white',
						//plot_bgcolor: 'white',
					});

				}
				else
				{
				var gridSize = 100;//300;
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.SectionIndex;
				var DataArray = SectionBoxData;
				var rows1 = DataArray.length * 2 * 300;
				var cols1 = 4;
				var TempArray = createMultiDimensionalArray(rows1, cols1);
				var rows2 = DataArray.length;
				var cols2 = 3;
				var TopArray = createMultiDimensionalArray(rows2, cols2);
				var rows3 = DataArray.length;
				var cols3 = 3;
				var BottomArray = createMultiDimensionalArray(rows3, cols3);
				var rows4 = DataArray.length * 2;
				var cols4 = 3;
				var PolyArray = createMultiDimensionalArray(rows4, cols4);
				var Count = 0;
				var PolyCount = 0;
				var distance = 0.0;
				var Totaldistance = 0.0;
				var PrevLat = DataArray[0][1];
				var PrevLon = DataArray[0][2];
				var MaxDistance = 0;
				var minLat = 10000000;
				var maxLat = -10000000;
				var minLon = 10000000;
				var maxLon = -10000000;
				
				let Fracturedata = [];
				
				var MaxVerticalInterpDistance = 5;
				
				var ExtName = 0;
				var ExtPoint = 0;
				var ExtDepth = 0.0;
				var ExtDistance = 0.0;
				var ExtValue = 0.0;
				let ExternalLogdata = [];
				var LastPoint = 0;
				var SecondPointDetected = false;
				
				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				for (var i = 0; i < DataArray.length; i++) 
				{
					var LastDepth = 0.0;
					distance = calculateDistance(PrevLat, PrevLon, DataArray[i][1], DataArray[i][2]);
					Totaldistance = Totaldistance + distance;
					
					//*************************
					//Insert External data here
					//*************************
					if (ExternalDataArray.length > 0)
					{
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							if ( ExternalDataArray[d][0] == DataArray[i][0])
							{
								ExtPoint = DataArray[i][0];
								if (d == 0)
								{
									ExtName = '';
									ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
									ExtValue = null;
									ExtDistance = null;
									LastPoint = ExtPoint;
								}
								else
								{
									if (ExtPoint == LastPoint)
									{
										if (SecondPointDetected == false)
										{
											ExtName = ExternalDataArray[d][3];
											SecondPointDetected = true;
										}
										else
										{
											ExtName = '';
										}
										ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
										ExtValue = ExternalDataArray[d][2];
										ExtDistance = Totaldistance + ExternalDataArray[d][2];
									}
									else
									{
										SecondPointDetected = false;
										ExtName = '';
										ExtDepth = DataArray[i][3][10] - ExternalDataArray[d][1];
										ExtValue = null;
										ExtDistance = null;
										LastPoint = ExtPoint;
									}
								}
								ExternalLogdata.push({ ExtName, ExtDepth, ExtDistance, ExtValue });
							}	
						}
					}
					//*************************
					
					if (Totaldistance < minLon)
					{
						minLon = Totaldistance;
					}
					if (Totaldistance > maxLon)
					{
						maxLon = Totaldistance;
					}

					PrevLat = DataArray[i][1];
					PrevLon = DataArray[i][2];
					if (distance > MaxDistance)
					{
						MaxDistance = distance;
					}
					if (DataArray[i][4] > 9)
					{
						TopArray[i][0] = DataArray[i][0];
					}
					else
					{
						TopArray[i][0] = '<b style="color:grey;">R' + DataArray[i][4] + '</b><br>' + DataArray[i][3][4] + 'm<br>' + DataArray[i][0];
					}
					TopArray[i][1] = DataArray[i][3][10];
					TopArray[i][2] = Totaldistance;
					PolyArray[PolyCount][0] = DataArray[i][0];
					PolyArray[PolyCount][1] = DataArray[i][3][10];
					PolyArray[PolyCount][2] = Totaldistance;
					PolyCount = PolyCount + 1;
					for (var x = 0; x < DataArray[i][5]; x++) 
					{
						if (DataArray[i][3][10] - DataArray[i][6][x][1] < minLat)
						{
							minLat = DataArray[i][3][10] - DataArray[i][6][x][1];
						}
						if (DataArray[i][3][10] - DataArray[i][6][x][0] > maxLat)
						{
							maxLat = DataArray[i][3][10] - DataArray[i][6][x][0];
						}
						
						var Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
						TempArray[Count][0] = DataArray[i][0];
						TempArray[Count][1] = Midpoint;
						TempArray[Count][2] = Totaldistance;
						TempArray[Count][3] = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
						Count = Count + 1;
						LastDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
					}
					BottomArray[i][0] = DataArray[i][0];
					BottomArray[i][1] = LastDepth;
					BottomArray[i][2] = Totaldistance;
					PolyArray[PolyCount][0] = DataArray[i][0];
					PolyArray[PolyCount][1] = LastDepth;
					PolyArray[PolyCount][2] = Totaldistance;
					PolyCount = PolyCount + 1;
				
					//***************************************************
					//add fracture point data
					//***************************************************
					for (var x = 0; x < DataArray[i][7]; x++) 
					{
						var FracDepth = DataArray[i][3][10] - DataArray[i][8][x];
						var FracDistance = Totaldistance;
						Fracturedata.push({ FracDepth, FracDistance });
					}
					//***************************************************
				}

				function LoadSectionLogData() 
				{
					let SectionLogdata = [];
					var LogTotaldistance = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						Logdistance = calculateDistance(FirstLat, FirstLon, DataArray[i][1], DataArray[i][2]);
						LogTotaldistance = LogTotaldistance + Logdistance;
						FirstLat = DataArray[i][1];
						FirstLon = DataArray[i][2];
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							//if (thickness\2.0 > MaxVerticalInterpDistance)
							//{
							//	MaxVerticalInterpDistance = thickness\2.0;
							//}
							
							let NumberofMidPoints = Math.trunc((thickness/MaxVerticalInterpDistance) - 0);
							let PointName = DataArray[i][0];
							let PointDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let PointDistance = LogTotaldistance;
							let PointValue = 0;
							//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							//{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							//}

							if (NumberofMidPoints > 1)
							{
								for (var z = 0; z < NumberofMidPoints; z++) 
								{
									PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + (z*MaxVerticalInterpDistance));
									//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
									//{
										PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
										SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
									//}
								}
							}
							else
							{
								PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2.0));
								//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
								//{
									PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
									SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
								//}
							}
							
							
							PointDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
							//if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							//{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							//}
						}
					}
					return SectionLogdata;
				}
			
				function LoadOverlayLogData() 
				{
					let SectionLogdata = [];
					var LogTotaldistance = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						Logdistance = calculateDistance(FirstLat, FirstLon, DataArray[i][1], DataArray[i][2]);
						LogTotaldistance = LogTotaldistance + Logdistance;
						FirstLat = DataArray[i][1];
						FirstLon = DataArray[i][2];
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let PointName = DataArray[i][0];
							let PointDepth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let PointDistance = LogTotaldistance;
							let PointValue = 0;
							if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							}

							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								PointDepth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
								{
									PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
									SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
								}
							}

							PointDepth = DataArray[i][3][10] - DataArray[i][6][x][1];
							if ( PointDepth > DataArray[i][3][10] - DataArray[i][3][4])
							{
								PointValue = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
								SectionLogdata.push({ PointName, PointDepth, PointDistance, PointValue });
							}
						}
					}
					return SectionLogdata;
				}
				
				var pointData = TempArray;
				
				function isValidFloat(number) 
				{
				  return !isNaN(parseFloat(number)) && isFinite(number);
				}
			  
				function logadjustedInverseDistanceWeight(x, y, points, datasetInd, lateralRadius, verticalRadius) {
					var sum = 0;
					var weightsSum = 0;
					if ( (isValidFloat(x)) && (isValidFloat(y)) && (isValidFloat(lateralRadius)) && (isValidFloat(verticalRadius)))
					{
						for (var i = 0; i < points.length; i++) {
							var point = points[i];
							var lateralDistance = Math.abs(x - point.PointDistance);
							var verticalDistance = Math.abs(y - point.PointDepth);
							if ( (isValidFloat(point.PointDistance)) && (isValidFloat(point.PointDepth)) && (isValidFloat(lateralDistance)) && (isValidFloat(verticalDistance)))
							{
								if (lateralDistance <= lateralRadius && verticalDistance <= verticalRadius) {
									var d = Math.sqrt(Math.pow(lateralDistance, 2) + Math.pow(verticalDistance, 2));
									if (d === 0) return point.PointValue;
									sum += (point.PointValue / d);
									weightsSum += (1 / d);
								}
							}
						
						}
						return sum / (weightsSum);
					}
					else
					{
						return 0;
					}
				}
				
				/*function logadjustedInverseDistanceWeight(x, y, points, datasetInd, lateralRadius, verticalRadius) {
					if (!isValidFloat(x) || !isValidFloat(y) || !isValidFloat(lateralRadius) || !isValidFloat(verticalRadius)) {
						return null;
					}

					let sum = 0;
					let weightsSum = 0;
					let power = 2;
					
					for (let i = 0; i < points.length; i++) {
						let point = points[i];
						let lateralDistance = Math.abs(x - point.PointDistance);
						let verticalDistance = Math.abs(y - point.PointDepth);

						if (!isValidFloat(point.PointDistance) || !isValidFloat(point.PointDepth)) {
							continue;
						}

						if (lateralDistance <= lateralRadius && verticalDistance <= verticalRadius) {
							let d = Math.sqrt(Math.pow(lateralDistance, 2) + Math.pow(verticalDistance, 2));

							if (d === 0) {
								return point.PointValue;  // Exact match found, return the value directly
							}

							// Applying the power parameter to the distance
							let weight = 1 / Math.pow(d, power);
							sum += point.PointValue * weight;
							weightsSum += weight;
						}
					}

					if (weightsSum === 0) {
						return null;  // No valid points found within the radius
					}

					return sum / weightsSum;
				}*/
				
				function isNorthOfLine(pointLat, pointLng, lineCoordinates) 
				{
					var intersectCount = 0;
					for (var i = 0; i < lineCoordinates.length - 1; i++) 
					{
						var lat1 = lineCoordinates[i][1];
						var lng1 = lineCoordinates[i][2];
						var lat2 = lineCoordinates[i+1][1];
						var lng2 = lineCoordinates[i+1][2];
						if (lng1 < pointLng && lng2 >= pointLng || lng2 < pointLng && lng1 >= pointLng) 
						{
							if (lat1 + (pointLng - lng1) / (lng2 - lng1) * (lat2 - lat1) < pointLat) 
							{
								intersectCount++;
							}
						}
					}
					return intersectCount % 2 === 1;
				}

				let LogScatData = LoadSectionLogData();
				let LogOverlayData = LoadOverlayLogData();
				
				//try {
				//var minLat = Math.min.apply(null, pointData.map(function(point) { return point[1]; }));
				//var maxLat = Math.max.apply(null, TopArray.map(function(point) { return point[1]; }));
				//var minLon = Math.min.apply(null, pointData.map(function(point) { return point[2]; }));
				//var maxLon = Math.max.apply(null, pointData.map(function(point) { return point[2]; }));
				
				//} catch (error) {
                //alert(error.message + "\n\n" + error.stack);
				//}
				
				var SectionColorscalemin = Math.min(...LogScatData.map(point => point.PointValue));
				var SectionColorscalemax = Math.max(...LogScatData.map(point => point.PointValue));
				
				
				function setMaxValue(Inarray, UsermaxValue) {
					for (var i = 0; i < Inarray.length; i++) {
						// Assuming each object in the array has a property named 'PointValue'
						if (Inarray[i].PointValue > UsermaxValue) {
							Inarray[i].PointValue = UsermaxValue;
						}
					}
					return Inarray;
				}
				
				LogScatData = setMaxValue(LogScatData,SectionColorscalemax*(UserSetmaxValue/100));
				
				var LateralInterpolationDistance = MaxDistance*4;
				var Interscatter= [];
				var interpolatedZ = [];
				for (var i = 0; i < gridSize; i++) 
				{
					var row = [];
					for (var j = 0; j < gridSize; j++) 
					{
						var lat = minLat + (i / (gridSize - 1)) * (maxLat - minLat);
						var lon = minLon + (j / (gridSize - 1)) * (maxLon - minLon);
						var elevation = logadjustedInverseDistanceWeight(lon, lat, LogScatData, datasetIndex, LateralInterpolationDistance, MaxVerticalInterpDistance+1);
						if ((isNorthOfLine(lat, lon, TopArray)))
						{
							elevation = null;
						}
						if (isNorthOfLine(lat, lon, BottomArray))
						{
						
						}
						else
						{
							var linemaxLat = Math.max.apply(null, BottomArray.map(function(point) { return point[1]; }));
							if (lat < linemaxLat)
							{
								elevation = null;
							}
						}
						row.push(elevation);
						Interscatter.push({ lon, lat, elevation });
					}
					interpolatedZ.push(row);
				}
				
				var FracscatterData = {
					x: Fracturedata.map(function(point) { return point.FracDistance; }),
					y: Fracturedata.map(function(point) { return point.FracDepth; }),
					mode: 'markers',
					name: '',
					//coloring: 'heatmap',
					marker: {
						symbol: 'line-ew',
						color: 'white',
						size: 20,  // Adjust size to set the width of the horizontal lines
						line: {
							width: 3,  // Adjust width to set the height of the horizontal lines
							color: 'white'  // Set the color of the lines to white
						}
					},
					type: 'scatter',
					//text: Fracturedata.map(function(point) { return point.PointName; }),
					//textposition: 'top center',
					showscale: false,
					showlegend: false,
					//textfont: {
					//	  color: 'black',
					//	  size: 18
					//}
				};
				
				var scatterData = {
					x: pointData.map(function(point) { return point[2]; }),
					y: pointData.map(function(point) { return point[1]; }),
					mode: 'markers',
					name: '',
					marker: {
						color: 'black',
						size: 10
					},
					type: 'scatter',
					text: pointData.map(function(point) { return point[0]; }),
					textposition: 'top center',
					showscale: false,
					showlegend: false,
					textfont: {
						color: 'black',
						size: 18
					}
				};
				var LogscatterData = {
					x: LogOverlayData.map(function(point) { return point.PointDistance; }),
					y: LogOverlayData.map(function(point) { return point.PointDepth; }),
					mode: 'markers',
					name: '',
					coloring: 'heatmap',
					marker: {
						  symbol: 'square',
						  color: LogOverlayData.map(function(point) { return point.PointValue; }),
						  opacity: 1,
						  size: 2
					},
					type: 'scatter',
					showscale: false,
					showlegend: false,
					text: LogOverlayData.map(function(point) { return point.PointName; }),
					textposition: 'top center',
					textfont: {
						  color: 'black',
						  size: 18
					}
				};
				var ExtLogscatterData = {
					x: ExternalLogdata.map(function(point) { return point.ExtDistance; }),
					y: ExternalLogdata.map(function(point) { return point.ExtDepth; }),
					mode: 'lines+markers+text',
					name: '',
					line: {  // Add this block to set the line color to white
						color: 'white',
					  },
					coloring: 'white',
					marker: {
						  symbol: 'square',
						  color: ExternalLogdata.map(function(point) { return point.ExtValue; }),
						  opacity: 1,
						  size: 2
					},
					type: 'scatter',
					text: ExternalLogdata.map(function(point) { return point.ExtName; }),
					textposition: 'bottom right',
					showscale: false,
					showlegend: false,
					textfont: {
						  color: 'white',
						  size: 14
					}
				};
				var ToplineData = {
					x: TopArray.map(function(TopArray) { return TopArray[2]; }),
					y: TopArray.map(function(TopArray) { return TopArray[1]; }),
					name: '',
					mode: 'lines+markers+text',
					marker: {
						color: 'black',
						size: 6
					},
					type: 'scatter',
					name: '',
					text: TopArray.map(function(point) { return point[0]; }),
					textposition: 'top center',
					showscale: false,
					showlegend: false,
					textfont: {
						color: 'black',
						size: 14
					}
				};
				var BottomlineData = {
					x: BottomArray.map(function(BottomArray) { return BottomArray[2]; }),
					y: BottomArray.map(function(BottomArray) { return BottomArray[1]; }),
					mode: 'lines',
					name: '',
					marker: {
						color: 'black',
						size: 12
					},
					showscale: false,
					showlegend: false,
					type: 'scatter',
					name: ''
				};
				if (selectedData == 'dataset1')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 11}, (_, i) => i),
							ticktext: LithType
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset2')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: AquiferTypeFull
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset3')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: FormationCondition
						},
						x: [],
						y: []
					};
				}
				else if (selectedData == 'dataset4')
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 2}, (_, i) => i),
							ticktext: FormationFractureCondition
						},
						x: [],
						y: []
					};
				}
				else 
				{
					var contourData = {
						z: interpolatedZ,
						name: '',
						type: 'contour',
						contours: {
							coloring: 'heatmap'
						},
						colorscale: 'Rainbow',
						colorbar: {
							title: dataset.LegendUnit
						},
						x: [],
						y: []
					};
				}
				for (var i = 0; i < gridSize; i++) {
					contourData.x.push(minLon + i * ((maxLon - minLon) / (gridSize - 1)));
					contourData.y.push(minLat + i * ((maxLat - minLat) / (gridSize - 1)));
				}
				var layout = {
					title: {
						text: '<b>' + dataset.SectionName + '</b>',
						font: {
							size: 16
						}
					},
					xaxis: {title: 'Distance (m)'},
					yaxis: {title: 'Depth (masl)'},
					//width: Math.min(window.outerWidth, window.innerWidth, 1100),
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7
				};
				HoldFracscatterData = FracscatterData;
				HoldSectioncontourData = contourData;
				HoldSectionLogscatterData = LogscatterData;
				HoldSectionExtLogscatterData = ExtLogscatterData;
				HoldSectionToplineData = ToplineData;
				HoldSectionBottomlineData = BottomlineData;
				HoldSectionlayout = layout;
				
				if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, FracscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, FracscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, FracscatterData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, FracscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.newPlot('plotly-Sections', [contourData, ExtLogscatterData, ToplineData, BottomlineData], layout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.newPlot('plotly-Sections', [contourData, ToplineData, BottomlineData], layout);
				}
				else
				{
					Plotly.newPlot('plotly-Sections', [contourData, ToplineData, BottomlineData], layout);
				}
				//if (SectionLogsState == 1)
				//{
				//	Plotly.newPlot('plotly-Sections', [contourData, LogscatterData, ToplineData, BottomlineData], layout);
				//}
				//else
				//{
					Plotly.newPlot('plotly-Sections', [contourData, ToplineData, BottomlineData], layout);
				//}
				}
				} catch (error) {}
			}	
					
			function updateVolumePlot(selectedData) 
			{
				try {
				selectedDataHold = selectedData
				
				var VolumeLateralGridCount = 30;
				var VolumeDepthGridCount = 100;
				var SurfaceLateralGridCount = 30;
				var dataset = datasets[selectedData];
				
				HoldModelUnit = dataset.LegendUnit;
				
				var datasetIndex = dataset.SectionIndex;
				var DataArray = ModelBoxData;//BoxData.data;
				let SliceDepthArray = new Array(VolumeDepthGridCount + 1).fill(0);
				let SliceLatArray = new Array(VolumeLateralGridCount + 1).fill(0);
				let SliceLonArray = new Array(VolumeLateralGridCount + 1).fill(0);

				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				function calculateStatsDistance(Points) 
				{
					let Distance3 = 0.0;
					const RenderPointCount = Points.length;
					for (var I = 0; I < RenderPointCount; I++) 
					{
						let Distance2 = 1000000.0;
						for (var J = 0; J < RenderPointCount; J++) 
						{
							if (I != J) 
							{
								let distance = Math.sqrt(Math.pow(Math.abs(Points[I].latitude - Points[J].latitude), 2) + Math.pow(Math.abs(Points[I].longitude - Points[J].longitude), 2));
								if (distance <= Distance2) 
								{
									Distance2 = distance;
								}
							}
						}
						if (Distance2 >= Distance3) 
						{
							Distance3 = Distance2;
						}
					}
					Distance3 = Distance3 + 2.0;
					return Math.trunc(Distance3)
				}

				function adjustedInverseDistanceWeight(x, y, points, Weightpower) 
				{
					var sum = 0;
					var weightsSum = 0;
					for (var i = 0; i < points.length; i++) 
					{
						var point = points[i];
						var d = Math.sqrt(Math.pow(x - point.longitude, 2) + Math.pow(y - point.latitude, 2));
						if (d === 0) return point.depth;
						var weightFactor = 1 / Math.pow(d, Weightpower);
						sum += (point.depth * weightFactor);
						weightsSum += weightFactor;
					}
					return sum / weightsSum;
				}
				
				function DIDWInterpolation(data, gridSize, Surface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolData = [];
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, Surface, SurfaceWeightPower);
							interpolData.push({x: lon, y: lat, z: surfacevalue, value: surfacevalue});
						}
					}
					return interpolData;
				}
				
				function IDWInterpolation(data, gridSize, depthGridSize, power, TopSurface, BottomSurface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolatedData = [];
					var LatCount = 0;
					var LonCount = 0;
					var DepthCount = 0;
					power = 4;
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						SliceLatArray[LatCount] = lat;
						LatCount = LatCount + 1;
						LonCount = 0;
						DepthCount = 0;
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							SliceLonArray[LonCount] = lon;
							LonCount = LonCount + 1;
							DepthCount = 0;
							let Topsurfacevalue = adjustedInverseDistanceWeight(lon, lat, TopSurface, SurfaceWeightPower);
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, BottomSurface, SurfaceWeightPower);
							for (let dep = minDep; dep <= maxDep; dep += ((maxDep-minDep)/depthGridSize)) 
							{
								SliceDepthArray[DepthCount] = dep;
								DepthCount = DepthCount + 1;
								let numerator = 0;
								let denominator = 0;
								for (let point of data) 
								{
									let distance = Math.sqrt(Math.pow(lat - point.latitude, 2) + Math.pow(lon - point.longitude, 2) + Math.pow(dep - point.depth, 2));
									if (distance === 0) 
									{
										if (dep > Topsurfacevalue  || dep < surfacevalue)
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: null});
										}
										else
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: point.amplitude});
										}
										break;
									}
									let weight = 1 / Math.pow(distance, power);
									numerator += weight * point.amplitude;
									denominator += weight;
								}
								if (denominator !== 0) 
								{
									let interpolatedValue = numerator / denominator;
									if (dep > Topsurfacevalue  || dep < surfacevalue)
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: null});
									}
									else
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: interpolatedValue});
									}
								}
							}
						}
					}
					return interpolatedData;
				}

				function LoadBoxData()
				{
					let Volumedata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
							let latitude = (FirstLat - DataArray[i][1])*100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = Midpoint;
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0])
							
							
							let NumberofMidPoints = Math.trunc(thickness/5) 
							if (NumberofMidPoints > 0)
							{	
								for (var z = 0; z < NumberofMidPoints; z++) 
								{
									depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + (z*5));
									Volumedata.push({latitude, longitude, depth, amplitude, thickness});
								}
							}
							else
							{
								Volumedata.push({latitude, longitude, depth, amplitude, thickness});
							}
							
						
						}	
					}
					return Volumedata;
				}

				function LoadLogData() 
				{
					let Logdata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let latitude = (FirstLat - DataArray[i][1]) * 100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Logdata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								Logdata.push({ latitude, longitude, depth, amplitude });
							}
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							Logdata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Logdata;
				}
				
				function LoadTopSurfaceData()
				{
					let Topdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10];
						let name = DataArray[i][0];
						Topdata.push({latitude, longitude, depth, name});	
					}
					return Topdata;
				}
				
				function LoadBottomSurfaceData()
				{
					let Bottomdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10] - DataArray[i][6][DataArray[i][5]-1][1];
						Bottomdata.push({latitude, longitude, depth});	
					}
					return Bottomdata;
				}
				
				function LoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = SliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = SliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = SliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				let rawData = LoadBoxData();
				let logData = LoadLogData();
				let TopSurfaceData = LoadTopSurfaceData();
				let BottomSurfaceData = LoadBottomSurfaceData();
				const InterpolationDistance = calculateStatsDistance(TopSurfaceData)*4;
				let interpolatedData = IDWInterpolation(rawData, VolumeLateralGridCount, VolumeDepthGridCount, InterpolationDistance, TopSurfaceData, BottomSurfaceData, 2);
				VolData = interpolatedData;
				VolDataMax = Math.max(...interpolatedData.map(point => point.value));
				let interpolatedTopSurfaceData = DIDWInterpolation(rawData, SurfaceLateralGridCount, TopSurfaceData, 2) 
				let DepthSliceData = LoadDepthSliceData(DepthSliceCount, interpolatedData);
				let LatSliceData = LoadLatSliceData(LatSliceCount , interpolatedData);
				let lonSliceData = LoadLonSliceData(LonSliceCount , interpolatedData);
				UpdateSliceDepthArray = SliceDepthArray;
				UpdateSliceLatArray = SliceLatArray;
				UpdateSliceLonArray = SliceLonArray;
				var DepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: DepthSliceData.map(point => point.longitude),
					y: DepthSliceData.map(point => point.latitude),
					z: DepthSliceData.map(point => point.depth),
					intensity: DepthSliceData.map(point => point.Amplitude)
				};
				var LatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: LatSliceData.map(point => point.longitude),
					y: LatSliceData.map(point => point.latitude),
					z: LatSliceData.map(point => point.depth),
					intensity: LatSliceData.map(point => point.Amplitude)
				};
				var LonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					showlegend: false,
					x: lonSliceData.map(point => point.longitude),
					y: lonSliceData.map(point => point.latitude),
					z: lonSliceData.map(point => point.depth),
					intensity: lonSliceData.map(point => point.Amplitude)
				};
				if (selectedData == 'dataset1')
				{
					var data = [{
						type: 'volume',
						name: '',
						x: interpolatedData.map(point => point.x),
						y: interpolatedData.map(point => point.y),
						z: interpolatedData.map(point => point.z),
						value: interpolatedData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: interpolatedData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 11}, (_, i) => i),
							ticktext: LithType
						}
					}];
				}
				else if (selectedData == 'dataset2')
				{
					var data = [{
						type: 'volume',
						name: '',
						x: interpolatedData.map(point => point.x),
						y: interpolatedData.map(point => point.y),
						z: interpolatedData.map(point => point.z),
						value: interpolatedData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: interpolatedData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: AquiferTypeFull
						}
					}];
				}
				else if (selectedData == 'dataset3')
				{
					var data = [{
						type: 'volume',
						name: '',
						x: interpolatedData.map(point => point.x),
						y: interpolatedData.map(point => point.y),
						z: interpolatedData.map(point => point.z),
						value: interpolatedData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: interpolatedData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: FormationCondition
						}
					}];
				}
				else if (selectedData == 'dataset4')
				{
					var data = [{
						type: 'volume',
						name: '',
						x: interpolatedData.map(point => point.x),
						y: interpolatedData.map(point => point.y),
						z: interpolatedData.map(point => point.z),
						value: interpolatedData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: interpolatedData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({length: 2}, (_, i) => i),
							ticktext: FormationFractureCondition
						}
					}];
				}
				else 
				{
					var data = [{
						type: 'volume',
						name: '',
						x: interpolatedData.map(point => point.x),
						y: interpolatedData.map(point => point.y),
						z: interpolatedData.map(point => point.z),
						value: interpolatedData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: interpolatedData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: dataset.LegendUnit
						}
					}];
				}
				let rawTopdata = [{
					type: 'scatter3d',
					name: '',
					x: TopSurfaceData.map(point => point.longitude),
					y: TopSurfaceData.map(point => point.latitude),
					z: TopSurfaceData.map(point => point.depth),
					showscale: false,
					showlegend: false,
					mode: 'markers+text',
					text: TopSurfaceData.map(point => point.name),
					  textposition: 'top center',
					  textfont: {
						family:  'Arial, sans-serif',
						size: 12,
						color: 'black'
					  },
					marker: {
						size: 3,
						color: 'red',
						opacity: 1
					},
				}];
				let logscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: logData.map(point => point.longitude),
					y: logData.map(point => point.latitude),
					z: logData.map(point => point.depth),
					value: logData.map(point => point.amplitude),
					showscale: false,
					showlegend: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: logData.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 0.8
					},
				}];
				let TopEndMeshdata = [{
					opacity:0.9,
					name: '',
					type: 'mesh3d',
					name: 'Topography',
					colorscale: 'Greys',
					x: interpolatedTopSurfaceData.map(point => point.x),
					y: interpolatedTopSurfaceData.map(point => point.y),
					z: interpolatedTopSurfaceData.map(point => point.z),
					intensity: interpolatedTopSurfaceData.map(point => point.z),
					showscale: true,
					colorbar: {
						x: -0.1,
						title: 'Elev'
					}
				}];
				let layout = {
					name: '',
					title: {
						text: '<b>' + dataset.SectionName + '</b>',
						font: {
							size: 16
						}
					},
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: Math.min(window.outerWidth - 10, window.innerWidth - 10, 1100) * 0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {
							title: 'Longitude (m)',
							autorange: true
						},
						yaxis: {
							title: 'Latitude (m)',
							autorange: true
						},
						zaxis: {
							title: 'Depth (masl)',
							autorange: true
						},
						aspectmode: 'auto',  // Maintains aspect ratio
						camera: {
							eye: {
								x: 1.5,  // Adjusted to give a better overall view
								y: 1.5,  // Adjusted to give a better overall view
								z: 1.5   // Adjusted to give a better overall view
							}
						}
					},
					autosize: true  // Ensures the plot resizes automatically with the window
				};
				TopEndMeshdataHold = TopEndMeshdata;
				rawTopdataHold = rawTopdata;
				logscatterdataHold = logscatterdata;
				HoldLayout = layout;
				if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [DepthSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [LatSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					SliceCombinedData = [DepthSlice, LatSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [LonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [DepthSlice, LonSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [LatSlice, LonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					SliceCombinedData = [DepthSlice, LatSlice, LonSlice];
				}
				else 
				{
					SliceCombinedData = [DepthSlice, LatSlice, LonSlice];
				}
				if ((TopographyState == 0) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(SliceCombinedData), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(rawTopdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(logscatterdata.concat(SliceCombinedData)), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(logscatterdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData))), layout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData)))), layout);
				}
				else
				{
					Plotly.newPlot('plotly-Model1', data.concat(TopEndMeshdata.concat(rawTopdata.concat(logscatterdata.concat(SliceCombinedData)))), layout);
				}
				} catch (error) {}
			}

			function updateProfilePlot(selectedData) 
			{
				try {
				ProfileselectedDataHold = selectedData
				
				var VolumeLateralGridCount = 30;
				var VolumeDepthGridCount = 100;
				var SurfaceLateralGridCount = 30;
				var dataset = datasets[selectedData];
				var datasetIndex = dataset.SectionIndex;
				var DataArray = BoxData.data;
				var ProfileOneArray = ProfileBoxData[0];
				var ProfileTwoArray = ProfileBoxData[1];
				var ProfileThreeArray = ProfileBoxData[2];
				let SliceDepthArray = new Array(VolumeDepthGridCount + 1).fill(0);
				let SliceLatArray = new Array(VolumeLateralGridCount + 1).fill(0);
				let SliceLonArray = new Array(VolumeLateralGridCount + 1).fill(0);
				var ProfileGridLateralCount = 200;
				var ProfileGridDepthCount = 200;
				
				var TemperatureCal = 1;
				var TemperatureAdd = 0;
				if (datasetIndex == 42)
				{
					TemperatureCal = GlobalTemperature;
					TemperatureAdd = 10;
				}
				
				function ProfileInterpolation(points, lon, lat, dep, lateralRadius, verticalRadius) {
					if (points.length === 0) {
						return null;
					}

					let sum = 0;
					let weightsSum = 0;
					const scaleFactor = 100000;  // Apply this consistently

					for (let i = 0; i < points.length; i++) {
						let point = points[i];
						let LongitudeDistance = Math.abs(lon - point.longitude) * scaleFactor;
						let LatitudeDistance = Math.abs(lat - point.latitude) * scaleFactor;
						let depthDistance = Math.abs(dep - point.depth);

						if (LongitudeDistance <= lateralRadius && LatitudeDistance <= lateralRadius && depthDistance <= verticalRadius) {
							let distance = Math.sqrt(
								Math.pow(LatitudeDistance, 2) +
								Math.pow(LongitudeDistance, 2) +
								Math.pow(depthDistance, 2)
							);

							if (distance === 0) {
								return point.amplitude;
							}

							sum += point.amplitude * (1 / Math.pow(distance, 2));
							weightsSum += 1 / Math.pow(distance, 2);
						}
					}

					if (weightsSum === 0) {
						return null;
					}

					return sum / weightsSum;
				}
				
				function isValidFloat(number) 
				{
				  return !isNaN(parseFloat(number)) && isFinite(number);
				}
				
				function DegToRad(degrees) 
				{
					return degrees * Math.PI / 180;
				}
				
				function RadToDeg(radians) 
				{
					return radians * (180 / Math.PI);
				}
				
				function fmod(x, y) 
				{
					return x - (Math.floor(x / y) * y);
				} 
				
				function LoadProfileLogData(Profile) 
				{
					let Profiledata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < Profile.length; i++) 
					{
						for (var x = 0; x < Profile[i][5]; x++) 
						{
							let thickness = Math.abs(Profile[i][6][x][1] - Profile[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let depth = Profile[i][3][10] - Profile[i][6][x][0];
							let latitude = ((FirstLat - Profile[i][1]) * 100000);
							let longitude = (FirstLon - Profile[i][2]) * 100000;
							let amplitude = Profile[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Profiledata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = Profile[i][3][10] - (Profile[i][6][x][0] + z);
								latitude = ((FirstLat - Profile[i][1]) * 100000);
								Profiledata.push({ latitude, longitude, depth, amplitude });
							}
							depth = Profile[i][3][10] - Profile[i][6][x][1];
							latitude = ((FirstLat - Profile[i][1]) * 100000);
							Profiledata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Profiledata;
				}
				
				function LoadProfileData(Profile, InterpDistance ) 
				{
					var ProfileGridData = [];
					var Profiledata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < Profile.length; i++) 
					{
						for (var x = 0; x < Profile[i][5]; x++) 
						{
							var thickness = Math.abs(Profile[i][6][x][1] - Profile[i][6][x][0]);
							var NumberofMidPoints = Math.trunc(thickness - 1);
							var depth = Profile[i][3][10] - Profile[i][6][x][0];
							var latitude = Profile[i][1];
							var longitude = Profile[i][2];
							var amplitude = Profile[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Profiledata.push({ latitude, longitude, depth, amplitude });
							
							//for (var z = 0; z < NumberofMidPoints; z++) 
							//{
							//	depth = Profile[i][3][10] - (Profile[i][6][x][0] + z);
							//	Profiledata.push({ latitude, longitude, depth, amplitude });
							//}
							
							depth = Profile[i][3][10] - (Profile[i][6][x][0] + ((Profile[i][6][x][1] - Profile[i][6][x][0])/2.0));
							Profiledata.push({ latitude, longitude, depth, amplitude });
							
							depth = Profile[i][3][10] - Profile[i][6][x][1];
							Profiledata.push({ latitude, longitude, depth, amplitude });
						}
					}

					var AllPoints = [];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							var thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							var NumberofMidPoints = Math.trunc(thickness - 1);
							var depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							var latitude = DataArray[i][1];
							var longitude = DataArray[i][2];
							var amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							AllPoints.push({ latitude, longitude, depth, amplitude });
							
							
							//for (var z = 0; z < NumberofMidPoints; z++) 
							//{
							//	depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
							//	AllPoints.push({ latitude, longitude, depth, amplitude });
							//}
							
							depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2.0));
							AllPoints.push({ latitude, longitude, depth, amplitude });
							
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							AllPoints.push({ latitude, longitude, depth, amplitude });
						}
					}
					
					var minDep = Math.min(...AllPoints.map(point => point.depth));
					var maxDep = Math.max(...AllPoints.map(point => point.depth)) + CorrectChart;
					var DistancetoLastMarker = 0;
					var DistanceAddOnDifference = 0;
					var TotalDistance = 0;
					for (var k = 1; k < Profile.length; k++) 
					{
						var lat1 = Profile[k-1][1]; 
						var lon1 = Profile[k-1][2];
						var lat2 = Profile[k][1];
						var lon2 = Profile[k][2];
						var theta = lon1 - lon2;
						var Distance = Math.sin(DegToRad(lat1)) * Math.sin(DegToRad(lat2)) + Math.cos(DegToRad(lat1)) * Math.cos(DegToRad(lat2)) * Math.cos(DegToRad(theta));
						Distance = Math.acos(Distance);
						Distance = RadToDeg(Distance);
						Distance = Distance * 60 * 1.1515 * 1609.344;
						TotalDistance += Distance;
					}

					var DistanceInMeters = TotalDistance / (ProfileGridLateralCount - 1);
					var TestCount = 0;
					var Flip = 0;
					for (let k = 1; k < Profile.length; k++) 
					{
						var lat1 = Profile[k-1][1]; 
						var lon1 = Profile[k-1][2];
						var elev1 = Profile[k-1][3][10];
						var lat2 = Profile[k][1];
						var lon2 = Profile[k][2];
						var elev2 = Profile[k][3][10];
						var radlat1 = DegToRad(lat1);
						var radlon1 = DegToRad(lon1);
						var radlat2 = DegToRad(lat2);
						var radlon2 = DegToRad(lon2);
						var Bearing = Math.atan2(Math.sin(radlon2 - radlon1) * Math.cos(radlat2), (Math.cos(radlat1) * Math.sin(radlat2)) - (Math.sin(radlat1) * Math.cos(radlat2) * Math.cos(radlon2 - radlon1)));
						Bearing = RadToDeg(Bearing);
						Bearing = fmod((Bearing + 360.0), 360);
						var theta = lon1 - lon2;
						var Distance = Math.sin(DegToRad(lat1)) * Math.sin(DegToRad(lat2)) + Math.cos(DegToRad(lat1)) * Math.cos(DegToRad(lat2)) * Math.cos(DegToRad(theta));
						Distance = Math.acos(Distance);
						Distance = RadToDeg(Distance);
						Distance = Distance * 60 * 1.1515 * 1609.344;

						if (Distance + DistancetoLastMarker > DistanceInMeters) 
						{
							if (k !== 1) 
							{
								DistanceAddOnDifference = DistanceInMeters - DistancetoLastMarker;
							}

							var ElevInc = 0.0; 
							var ElevDiff = 0.0;
							var ElevUp = false;
							var ElevDown = false;
							if (elev1 < elev2)
							{
								ElevUp = true;
								ElevDiff = (elev2 - elev1);
								ElevInc = (elev2 - elev1)/(Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters));
							}
							else if (elev1 > elev2)
							{
								ElevDown = true;
								ElevDiff = elev1 - elev2;
								ElevInc = (elev1 - elev2)/(Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters));
							}
							else if (elev1 == elev2)
							{
								ElevDiff = 0.0
								ElevInc = 0.0
							}
							
							for (var I = 0; I <= Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters); I++) 
							{
								if (I === Math.trunc((Distance - DistanceAddOnDifference) / DistanceInMeters)) 
								{
									DistancetoLastMarker = (Distance - DistanceAddOnDifference) - (DistanceInMeters * I);
								}

								var Dist = DistanceAddOnDifference + (DistanceInMeters * I);
								var rEarth = 6371.01;
								var epsilon = 0.000001;
								var rlat1 = DegToRad(lat1);
								var rlon1 = DegToRad(lon1);
								var rbearing = DegToRad(((-1) * Bearing) + 360);
								var rdistance = (Dist / rEarth) / 1000;
								var rlat = Math.asin(Math.sin(rlat1) * Math.cos(rdistance) + Math.cos(rlat1) * Math.sin(rdistance) * Math.cos(rbearing));
								var rlon;
								if (Math.cos(rlat) === 0 || Math.abs(Math.cos(rlat)) < epsilon) {
									rlon = rlon1;
								} else {
									var a = rlon1 - Math.asin(Math.sin(rbearing) * Math.sin(rdistance) / Math.cos(rlat)) + Math.PI;
									var b = 2 * Math.PI;
									rlon = (a - b * Math.trunc(a / b)) - Math.PI;
								}
								var lat = RadToDeg(rlat);
								var lon = RadToDeg(rlon);
								
								var DCount = 0;
								
								for (var dep = maxDep; dep >= minDep; dep -= ((maxDep-minDep)/ProfileGridDepthCount)) 
								{
									 
									var depth = dep;
									var latitude = ((FirstLat - lat) * 100000);
									var longitude = ((FirstLon - lon) * 100000);
									
									let groundElevation = 0.0;
									let BottomElevation = 0.0;
									
									// Find the actual ground elevation at this location from Profile
									if (ElevDown)
									{
										groundElevation = Profile[k][3][10] + (ElevDiff - (ElevInc * I));
										BottomElevation = (Profile[k][3][10] - Profile[k-1][3][39]) + (ElevDiff - (ElevInc * I));
									}
									else if (ElevUp)
									{
										groundElevation = Profile[k][3][10] - (ElevDiff - (ElevInc * I));
										BottomElevation = (Profile[k][3][10] - Profile[k-1][3][39]) - (ElevDiff - (ElevInc * I));
									}
									else
									{
										groundElevation = Profile[k][3][10];
										BottomElevation = Profile[k][3][10] - Profile[k-1][3][39];
									}

									var Amplitude = ((depth > groundElevation) ||(depth < BottomElevation)) ? null : ProfileInterpolation(AllPoints, lon, lat, dep, InterpDistance, 10);

									if ((Amplitude == null)&&(depth <= groundElevation)&&(depth >= BottomElevation))
									{
										Amplitude = 0.0;
									}
									
									ProfileGridData.push({ latitude, longitude, depth, Amplitude });
									DCount = DCount + 1;
									TestCount = TestCount + 1;
								}
							}
						} 
						else 
						{
							DistancetoLastMarker = Distance + DistancetoLastMarker;
						}
					}
					return ProfileGridData;
				}

				function calculateStatsDistance(Points) 
				{
					let Distance3 = 0.0;
					const RenderPointCount = Points.length;
					for (var I = 0; I < RenderPointCount; I++) 
					{
						let Distance2 = 1000000.0;
						for (var J = 0; J < RenderPointCount; J++) 
						{
							if (I != J) 
							{
								let distance = Math.sqrt(Math.pow(Math.abs(Points[I].latitude - Points[J].latitude), 2) + Math.pow(Math.abs(Points[I].longitude - Points[J].longitude), 2));
								if (distance <= Distance2) 
								{
									Distance2 = distance;
								}
							}
						}
						if (Distance2 >= Distance3) 
						{
							Distance3 = Distance2;
						}
					}
					Distance3 = Distance3 + 2.0;
					return Math.trunc(Distance3)
				}

				function adjustedInverseDistanceWeight(x, y, points, Weightpower) 
				{
					var sum = 0;
					var weightsSum = 0;
					for (var i = 0; i < points.length; i++) 
					{
						var point = points[i];
						var d = Math.sqrt(Math.pow(x - point.longitude, 2) + Math.pow(y - point.latitude, 2));
						if (d === 0) return point.depth;
						var weightFactor = 1 / Math.pow(d, Weightpower);
						sum += (point.depth * weightFactor);
						weightsSum += weightFactor;
					}
					return sum / weightsSum;
				}
				
				function DIDWInterpolation(data, gridSize, Surface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolData = [];
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, Surface, SurfaceWeightPower);
							interpolData.push({x: lon, y: lat, z: surfacevalue, value: surfacevalue});
						}
					}
					return interpolData;
				}
				
				function IDWInterpolation(data, gridSize, depthGridSize, power, TopSurface, BottomSurface, SurfaceWeightPower) 
				{
					let minLat = Math.min(...data.map(point => point.latitude));
					let maxLat = Math.max(...data.map(point => point.latitude));
					let minLon = Math.min(...data.map(point => point.longitude));
					let maxLon = Math.max(...data.map(point => point.longitude));
					let minDep = Math.min(...data.map(point => point.depth));
					let maxDep = Math.max(...data.map(point => point.depth));
					let interpolatedData = [];
					var LatCount = 0;
					var LonCount = 0;
					var DepthCount = 0;
					for (let lat = minLat; lat <= maxLat; lat += ((maxLat-minLat)/gridSize)) 
					{
						SliceLatArray[LatCount] = lat;
						LatCount = LatCount + 1;
						LonCount = 0;
						DepthCount = 0;
						for (let lon = minLon; lon <= maxLon; lon += ((maxLon-minLon)/gridSize)) 
						{
							SliceLonArray[LonCount] = lon;
							LonCount = LonCount + 1;
							DepthCount = 0;
							let Topsurfacevalue = adjustedInverseDistanceWeight(lon, lat, TopSurface, SurfaceWeightPower);
							let surfacevalue = adjustedInverseDistanceWeight(lon, lat, BottomSurface, SurfaceWeightPower);
							for (let dep = minDep; dep <= maxDep; dep += ((maxDep-minDep)/depthGridSize)) 
							{
								SliceDepthArray[DepthCount] = dep;
								DepthCount = DepthCount + 1;
								let numerator = 0;
								let denominator = 0;
								for (let point of data) 
								{
									let distance = Math.sqrt(Math.pow(lat - point.latitude, 2) + Math.pow(lon - point.longitude, 2) + Math.pow(dep - point.depth, 2));
									if (distance === 0) 
									{
										if (dep > Topsurfacevalue  || dep < surfacevalue)
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: null});
										}
										else
										{
											interpolatedData.push({x: lon, y: lat, z: dep, value: point.amplitude});
										}
										break;
									}
									let weight = 1 / Math.pow(distance, power);
									numerator += weight * point.amplitude;
									denominator += weight;
								}
								if (denominator !== 0) 
								{
									let interpolatedValue = numerator / denominator;
									if (dep > Topsurfacevalue  || dep < surfacevalue)
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: null});
									}
									else
									{
										interpolatedData.push({x: lon, y: lat, z: dep, value: interpolatedValue});
									}
								}
							}
						}
					}
					return interpolatedData;
				}

				function LoadBoxData()
				{
					let Volumedata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let Midpoint = DataArray[i][3][10] - (DataArray[i][6][x][0] + ((DataArray[i][6][x][1] - DataArray[i][6][x][0])/2));
							let latitude = (FirstLat - DataArray[i][1])*100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = Midpoint;
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0])
							
							Volumedata.push({latitude, longitude, depth, amplitude, thickness});
						}	
					}
					return Volumedata;
				}
				
				function LoadLogData() 
				{
					let Logdata = [];
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						for (var x = 0; x < DataArray[i][5]; x++) 
						{
							let thickness = Math.abs(DataArray[i][6][x][1] - DataArray[i][6][x][0]);
							let NumberofMidPoints = Math.trunc(thickness - 1);
							let latitude = (FirstLat - DataArray[i][1]) * 100000;
							let longitude = (FirstLon - DataArray[i][2]) * 100000;
							let depth = DataArray[i][3][10] - DataArray[i][6][x][0];
							let amplitude = DataArray[i][6][x][datasetIndex] * TemperatureCal + TemperatureAdd;
							Logdata.push({ latitude, longitude, depth, amplitude });
							for (var z = 0; z < NumberofMidPoints; z++) 
							{
								depth = DataArray[i][3][10] - (DataArray[i][6][x][0] + z);
								Logdata.push({ latitude, longitude, depth, amplitude });
							}
							depth = DataArray[i][3][10] - DataArray[i][6][x][1];
							Logdata.push({ latitude, longitude, depth, amplitude });
						}
					}
					return Logdata;
				}
				
				function LoadTopSurfaceData()
				{
					let Topdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10];
						let name = DataArray[i][0];
						Topdata.push({latitude, longitude, depth, name});	
					}
					return Topdata;
				}
				
				function LoadBottomSurfaceData()
				{
					let Bottomdata = [];
					var Count = 0;
					var FirstLat = DataArray[0][1];
					var FirstLon = DataArray[0][2];
					for (var i = 0; i < DataArray.length; i++) 
					{
						let latitude = (FirstLat - DataArray[i][1])*100000;
						let longitude = (FirstLon - DataArray[i][2]) * 100000;
						let depth = DataArray[i][3][10] - DataArray[i][6][DataArray[i][5]-1][1];
						Bottomdata.push({latitude, longitude, depth});	
					}
					return Bottomdata;
				}
				
				function LoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = SliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = SliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function LoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = SliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				//let rawData = LoadBoxData();
				//let logData = LoadLogData();
				let TopSurfaceData = LoadTopSurfaceData();
				//let BottomSurfaceData = LoadBottomSurfaceData();
				const InterpolationDistance = calculateStatsDistance(TopSurfaceData);
				//let interpolatedData = IDWInterpolation(rawData, VolumeLateralGridCount, VolumeDepthGridCount, InterpolationDistance, TopSurfaceData, BottomSurfaceData, 2);
				//VolData = interpolatedData;
				//VolDataMax = Math.max(...interpolatedData.map(point => point.value));
				//let interpolatedTopSurfaceData = DIDWInterpolation(rawData, SurfaceLateralGridCount, TopSurfaceData, 2) 
				//let DepthSliceData = LoadDepthSliceData(DepthSliceCount, interpolatedData);
				//let LatSliceData = LoadLatSliceData(LatSliceCount , interpolatedData);
				//let lonSliceData = LoadLonSliceData(LonSliceCount , interpolatedData);
				//UpdateSliceDepthArray = SliceDepthArray;
				//UpdateSliceLatArray = SliceLatArray;
				//UpdateSliceLonArray = SliceLonArray;

				let TestOne = LoadProfileLogData(ProfileOneArray);
				let ProfileOneSurfaceData = LoadProfileData(ProfileOneArray, InterpolationDistance);
				let ProfileTwoSurfaceData = LoadProfileData(ProfileTwoArray, InterpolationDistance);
				let ProfileThreeSurfaceData = LoadProfileData(ProfileThreeArray, InterpolationDistance);
				var Colorscalemin = Math.min(...ProfileOneSurfaceData.map(point => point.Amplitude),...ProfileTwoSurfaceData.map(point => point.Amplitude),...ProfileThreeSurfaceData.map(point => point.Amplitude));
				var Colorscalemax = Math.max(...ProfileOneSurfaceData.map(point => point.Amplitude),...ProfileTwoSurfaceData.map(point => point.Amplitude),...ProfileThreeSurfaceData.map(point => point.Amplitude));
				
				function DelaunayTriangulation(LateralCount,DepthCount)
				{
					let TriangleArray = [];
					var Trii = 0;
					var Trij = 0;
					var Trik = 0;
					var CurrentIndex = 0;
					for (var l = 0; l < LateralCount - 1; l++)
					{
						for (var v = 0; v < DepthCount - 1; v++)
						{
							Trii = CurrentIndex;
							Trij = CurrentIndex + 1;
							Trik = CurrentIndex + DepthCount;
							TriangleArray.push({ Trii, Trij, Trik });
							CurrentIndex = CurrentIndex + 1;
							Trii = CurrentIndex;
							Trij = CurrentIndex + (DepthCount - 1);
							Trik = CurrentIndex + DepthCount;
							TriangleArray.push({ Trii, Trij, Trik });
						}
						CurrentIndex = CurrentIndex + 1;
					}
					return TriangleArray;
				}
				
				let Triangle = DelaunayTriangulation(ProfileGridLateralCount-1,ProfileGridDepthCount);
				
				if (selectedData == 'dataset1') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					// Create new indices arrays directly from the filtered triangles
					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 11 }, (_, i) => i),
							ticktext: LithType
						}
					};
				} else if (selectedData == 'dataset2') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 18 }, (_, i) => i),
							ticktext: AquiferTypeFull
						}
					};
				} else if (selectedData == 'dataset3') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 18 }, (_, i) => i),
							ticktext: FormationCondition
						}
					};
				} else if (selectedData == 'dataset4') {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit,
							tickvals: Array.from({ length: 2 }, (_, i) => i),
							ticktext: FormationFractureCondition
						}
					};
				} else {
					// Filter out triangles with any null amplitude
					let filteredTriangles = Triangle.filter(triangle => 
						ProfileOneSurfaceData[triangle.Trii].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trij].Amplitude !== null &&
						ProfileOneSurfaceData[triangle.Trik].Amplitude !== null
					);

					let i = filteredTriangles.map(triangle => triangle.Trii);
					let j = filteredTriangles.map(triangle => triangle.Trij);
					let k = filteredTriangles.map(triangle => triangle.Trik);

					var ProfileOneSurface = {
						opacity: 1,
						type: 'mesh3d',
						name: 'Profile One',
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: true,
						x: ProfileOneSurfaceData.map(point => point.longitude),
						y: ProfileOneSurfaceData.map(point => point.latitude),
						z: ProfileOneSurfaceData.map(point => point.depth),
						i: i,
						j: j,
						k: k,
						intensity: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorbar: {
							title: dataset.LegendUnit
						}
					};
				}

				
				
				
				// Helper function to safely process surface data
				function processSurface(surfaceData, surfaceName) {
					let i = [];
					let j = [];
					let k = [];
					let x = [];
					let y = [];
					let z = [];
					let intensity = [];

					Triangle.forEach(triangle => {
						const inBoundsTrii = triangle.Trii >= 0 && triangle.Trii < surfaceData.length;
						const inBoundsTrij = triangle.Trij >= 0 && triangle.Trij < surfaceData.length;
						const inBoundsTrik = triangle.Trik >= 0 && triangle.Trik < surfaceData.length;

						if (!inBoundsTrii || !inBoundsTrij || !inBoundsTrik) {
							console.error(`Out-of-bounds triangle detected in ${surfaceName}: ${JSON.stringify(triangle)}`);
							return;
						}

						const pointA = surfaceData[triangle.Trii];
						const pointB = surfaceData[triangle.Trij];
						const pointC = surfaceData[triangle.Trik];

						if (!pointA || !pointB || !pointC) {
							console.error(`Undefined point detected in ${surfaceName} for triangle: ${JSON.stringify(triangle)}`);
							return;
						}

						if (pointA.Amplitude !== null && pointB.Amplitude !== null && pointC.Amplitude !== null) {
							i.push(x.length);
							j.push(x.length + 1);
							k.push(x.length + 2);

							x.push(pointA.longitude, pointB.longitude, pointC.longitude);
							y.push(pointA.latitude, pointB.latitude, pointC.latitude);
							z.push(pointA.depth, pointB.depth, pointC.depth);
							intensity.push(pointA.Amplitude, pointB.Amplitude, pointC.Amplitude);
						}
					});

					return {
						opacity: 1,
						type: 'mesh3d',
						name: surfaceName,
						colorscale: 'Jet',
						cmin: Colorscalemin,
						cmax: Colorscalemax,
						showscale: false,
						x: x,
						y: y,
						z: z,
						i: i,
						j: j,
						k: k,
						intensity: intensity
					};
				}

				// Process Profile Two Surface
				var ProfileTwoSurface = processSurface(ProfileTwoSurfaceData, 'Profile Two');

				// Process Profile Three Surface
				var ProfileThreeSurface = processSurface(ProfileThreeSurfaceData, 'Profile Three');
				
				var Profilelogscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: TestOne.map(point => point.longitude),
					y: TestOne.map(point => point.latitude),
					z: TestOne.map(point => point.depth),
					value: TestOne.map(point => point.amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: TestOne.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 1
					},
				}];
				var Profilescatterdata = [{
					type: 'scatter3d',
					name: '',
					x: ProfileOneSurfaceData.map(point => point.longitude),
					y: ProfileOneSurfaceData.map(point => point.latitude),
					z: ProfileOneSurfaceData.map(point => point.depth),
					value: ProfileOneSurfaceData.map(point => point.Amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 4,
						color: ProfileOneSurfaceData.map(point => point.Amplitude),
						colorscale: 'Jet',
						opacity: 1
					},
				}];
				let rawTopdata = [{
					type: 'scatter3d',
					name: '',
					x: TopSurfaceData.map(point => point.longitude),
					y: TopSurfaceData.map(point => point.latitude),
					z: TopSurfaceData.map(point => point.depth),
					showscale: false,
					mode: 'markers+text',
					text: TopSurfaceData.map(point => point.name),
					  textposition: 'top center',
					  textfont: {
						family:  'Arial, sans-serif',
						size: 12,
						color: 'black'
					  },
					marker: {
						size: 3,
						color: 'red',
						opacity: 1
					},
				}];
				/*var DepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					x: DepthSliceData.map(point => point.longitude),
					y: DepthSliceData.map(point => point.latitude),
					z: DepthSliceData.map(point => point.depth),
					intensity: DepthSliceData.map(point => point.Amplitude)
				};
				var LatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					x: LatSliceData.map(point => point.longitude),
					y: LatSliceData.map(point => point.latitude),
					z: LatSliceData.map(point => point.depth),
					intensity: LatSliceData.map(point => point.Amplitude)
				};
				var LonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					x: lonSliceData.map(point => point.longitude),
					y: lonSliceData.map(point => point.latitude),
					z: lonSliceData.map(point => point.depth),
					intensity: lonSliceData.map(point => point.Amplitude)
				};
				let data = [{
					type: 'volume',
					name: '',
					x: interpolatedData.map(point => point.x),
					y: interpolatedData.map(point => point.y),
					z: interpolatedData.map(point => point.z),
					value: interpolatedData.map(point => point.value),
					isomin: VolDataMax * (isominValue/100),
					isomax: VolDataMax * (isomaxValue/100),
					opacity: interpolatedData.map(point => point.value)/(VolDataMax),
					opacityscale: 100,
					colorscale: 'Jet',
					colorbar: {
						title: 'Iso Value'
					}
				}];
				
				let logscatterdata = [{
					type: 'scatter3d',
					name: '',
					x: logData.map(point => point.longitude),
					y: logData.map(point => point.latitude),
					z: logData.map(point => point.depth),
					value: logData.map(point => point.amplitude),
					showscale: false,
					mode: 'markers',
					marker: {
						symbol: 'square',
						size: 2,
						color: logData.map(point => point.amplitude),
						colorscale: 'Jet',
						opacity: 0.8
					},
				}];
				let TopEndMeshdata = [{
					opacity:0.9,
					name: '',
					type: 'mesh3d',
					name: 'Topography',
					colorscale: 'Greys',
					x: interpolatedTopSurfaceData.map(point => point.x),
					y: interpolatedTopSurfaceData.map(point => point.y),
					z: interpolatedTopSurfaceData.map(point => point.z),
					intensity: interpolatedTopSurfaceData.map(point => point.z),
					showscale: true,
					colorbar: {
						x: -0.1,
						title: 'Elev'
					}
				}];*/
				let layout = {
					name: '',
					title: {
						text: '<b>' + dataset.SectionName + '</b>',
						font: {
							size: 16
						}
					},
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100) * 0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {
							title: 'Longitude (m)',
							autorange: true
						},
						yaxis: {
							title: 'Latitude (m)',
							autorange: true
						},
						zaxis: {
							title: 'Depth (masl)',
							autorange: true
						},
						aspectmode: 'auto',  // Ensures the aspect ratio is maintained so that data isn't distorted.
						camera: {
							eye: {
								x: 1.5,  // Adjusted to give a better overall view
								y: 1.5,  // Adjusted to give a better overall view
								z: 1.5   // Adjusted to give a better overall view
							}
						}
					},
					autosize: true  // Ensures the plot resizes automatically with the window
				};
				
				var ProfileSurfaceGroup = [ProfileOneSurface, ProfileTwoSurface, ProfileThreeSurface]
				
				HoldProfileSurfaceGroup = ProfileSurfaceGroup;
				HoldProfilerawTopdata = rawTopdata;
				HoldProfileLayout = layout;
				
				//Plotly.newPlot('plotly-Profile1', rawTopdata.concat(Profilelogscatterdata.concat(ProfileSurfaceGroup)), layout);
				Plotly.newPlot('plotly-Profile1', rawTopdata.concat(ProfileSurfaceGroup), layout);
				} catch (error) {}
			}

			function updatePresentationPlot()
			{
				var trace1 = {
					x: [], // Empty data for x-axis
					y: [], // Empty data for y-axis
					mode: 'lines', // Line plot
					name: 'Please select View'
				};

				var data = [trace1];

				var layout = {
					name: '',
					title: {
					  text: '<b>Please Select Presentation View</b>',
					  font: {
						size: 16
					  }
					},
					width: Math.min(window.outerWidth-100, window.innerWidth-100),
					height: Math.min(window.outerWidth-10, window.innerWidth-10, 1100)*0.7,
					margin: {l: 65, r: 50, b: 65, t: 90},
					scene: {
						xaxis: {title: 'Longitude (m)'},
						yaxis: {title: 'Latitude (m)'}
					}
				};

				HoldPresentationLayout = layout;

				Plotly.newPlot('plotly-presentation', data, layout);
			}
			
			document.getElementById('DepthsliceSlider').addEventListener('input', updateDepthslice);
			
			function updateDepthslice() {
			  DepthSliceCount = document.getElementById('DepthsliceSlider').value;
			  RefreshVolumePlot();
			}
			document.getElementById('LatsliceSlider').addEventListener('input', updateLatslice);
		
			function updateLatslice() {
			  LatSliceCount = document.getElementById('LatsliceSlider').value;
			  RefreshVolumePlot();
			}
			
			document.getElementById('LonsliceSlider').addEventListener('input', updateLonslice);

			function updateLonslice() {
			  LonSliceCount = document.getElementById('LonsliceSlider').value;
			  RefreshVolumePlot();
			}

			function toggleDepthSlice() {
				var checkbox = document.getElementById('show-DepthSlice-checkbox');
				if (checkbox.checked) {
					DepthSliceState = 1;
				} else {
					DepthSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLatSlice() {
				var checkbox = document.getElementById('show-LatSlice-checkbox');
				if (checkbox.checked) {
					LatSliceState = 1;
				} else {
					LatSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLonSlice() {
				var checkbox = document.getElementById('show-LonSlice-checkbox');
				if (checkbox.checked) {
					LonSliceState = 1;
				} else {
					LonSliceState = 0;
				}
				RefreshVolumePlot();
			}

			function RefreshVolumePlot() 
			{
				function UpdateLoadDepthSliceData(CurrentDepthSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentSliceDepth = UpdateSliceDepthArray[CurrentDepthSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.z == CurrentSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function UpdateLoadLatSliceData(CurrentLatSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLatSliceDepth = UpdateSliceLatArray[CurrentLatSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.y == CurrentLatSliceDepth)
						{
							let latitude = point.y + (point.z/1000);
							let longitude = point.x;
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				function UpdateLoadLonSliceData(CurrentLonSliceCount, VData)
				{
					let Slicedata = [];
					var CurrentLonSliceDepth = UpdateSliceLonArray[CurrentLonSliceCount];
					for (var i = 0; i < VData.length; i++)
					{
						let point = VData[i];
						if (point.x == CurrentLonSliceDepth)
						{
							let latitude = point.y;
							let longitude = point.x + (point.z/1000);
							let depth = point.z;
							let Amplitude = point.value;
							Slicedata.push({latitude, longitude, depth, Amplitude});
						}
					}
					return Slicedata;
				}
				
				let UpdateDepthSliceData = UpdateLoadDepthSliceData(DepthSliceCount, VolData);
				let UpdateLatSliceData = UpdateLoadLatSliceData(LatSliceCount , VolData);
				let UpdatelonSliceData = UpdateLoadLonSliceData(LonSliceCount , VolData);
				var UpdateDepthSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Depth Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdateDepthSliceData.map(point => point.longitude),
					y: UpdateDepthSliceData.map(point => point.latitude),
					z: UpdateDepthSliceData.map(point => point.depth),
					intensity: UpdateDepthSliceData.map(point => point.Amplitude)
				};
				var UpdateLatSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lat Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdateLatSliceData.map(point => point.longitude),
					y: UpdateLatSliceData.map(point => point.latitude),
					z: UpdateLatSliceData.map(point => point.depth),
					intensity: UpdateLatSliceData.map(point => point.Amplitude)
				};
				var UpdateLonSlice = {
					opacity:1,
					type: 'mesh3d',
					name: 'Lon Slice',
					colorscale: 'Jet',
					showscale: false,
					x: UpdatelonSliceData.map(point => point.longitude),
					y: UpdatelonSliceData.map(point => point.latitude),
					z: UpdatelonSliceData.map(point => point.depth),
					intensity: UpdatelonSliceData.map(point => point.Amplitude)
				};

				if (selectedDataHold == 'dataset1')
				{
					var Updatedata = [{
						type: 'volume',
						name: '',
						x: VolData.map(point => point.x),
						y: VolData.map(point => point.y),
						z: VolData.map(point => point.z),
						value: VolData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: VolData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: HoldModelUnit,
							tickvals: Array.from({length: 11}, (_, i) => i),
							ticktext: LithType
						}
					}];
				}
				else if (selectedDataHold == 'dataset2')
				{
					var Updatedata = [{
						type: 'volume',
						name: '',
						x: VolData.map(point => point.x),
						y: VolData.map(point => point.y),
						z: VolData.map(point => point.z),
						value: VolData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: VolData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: HoldModelUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: AquiferTypeFull
						}
					}];
				}
				else if (selectedDataHold == 'dataset3')
				{
					var Updatedata = [{
						type: 'volume',
						name: '',
						x: VolData.map(point => point.x),
						y: VolData.map(point => point.y),
						z: VolData.map(point => point.z),
						value: VolData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: VolData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: HoldModelUnit,
							tickvals: Array.from({length: 18}, (_, i) => i),
							ticktext: FormationCondition
						}
					}];
				}
				else if (selectedDataHold == 'dataset4')
				{
					var Updatedata = [{
						type: 'volume',
						name: '',
						x: VolData.map(point => point.x),
						y: VolData.map(point => point.y),
						z: VolData.map(point => point.z),
						value: VolData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: VolData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: HoldModelUnit,
							tickvals: Array.from({length: 2}, (_, i) => i),
							ticktext: FormationFractureCondition
						}
					}];
				}
				else 
				{
					var Updatedata = [{
						type: 'volume',
						name: '',
						x: VolData.map(point => point.x),
						y: VolData.map(point => point.y),
						z: VolData.map(point => point.z),
						value: VolData.map(point => point.value),
						isomin: VolDataMax * (isominValue/100),
						isomax: VolDataMax * (isomaxValue/100),
						opacity: VolData.map(point => point.value)/(VolDataMax),
						opacityscale: 100,
						colorscale: 'Jet',
						colorbar: {
							title: HoldModelUnit
						}
					}];
				}
				/*let Updatedata = [{
					type: 'volume',
					name: '',
					x: VolData.map(point => point.x),
					y: VolData.map(point => point.y),
					z: VolData.map(point => point.z),
					value: VolData.map(point => point.value),
					isomin: VolDataMax * (isominValue/100),
					isomax: VolDataMax * (isomaxValue/100),
					opacity: VolData.map(point => point.value)/(VolDataMax),
					opacityscale: 100,
					colorscale: 'Jet',
					colorbar: {
						title: 'Iso Value'
					}
				}];*/
				
				if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateLatSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 0)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateLonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 0) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLonSlice];
				}
				else if ((DepthSliceState == 0) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateLatSlice, UpdateLonSlice];
				}
				else if ((DepthSliceState == 1) && (LatSliceState == 1) && (LonSliceState == 1)) 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice, UpdateLonSlice];
				}
				else 
				{
					UpdateSliceCombinedData = [UpdateDepthSlice, UpdateLatSlice, UpdateLonSlice];
				}
				if ((TopographyState == 0) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(UpdateSliceCombinedData), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(rawTopdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 0))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(logscatterdataHold.concat(UpdateSliceCombinedData)), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 0) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 0) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData))), HoldLayout);
				}
				else if ((TopographyState == 1) && (PointsState == 1) && (LogState == 1))
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData)))), HoldLayout);
				}
				else
				{
					Plotly.react('plotly-Model1', Updatedata.concat(TopEndMeshdataHold.concat(rawTopdataHold.concat(logscatterdataHold.concat(UpdateSliceCombinedData)))), HoldLayout);
				}
			}

			document.getElementById('isomin-slider').addEventListener('input', updateIsomin);
			document.getElementById('isomax-slider').addEventListener('input', updateIsomax);
		
			function updateIsomin() {
			  isominValue = document.getElementById('isomin-slider').value;
			  document.getElementById('isomin-value').innerHTML = isominValue;
			  RefreshVolumePlot();
			}

			function updateIsomax() {
			  isomaxValue = document.getElementById('isomax-slider').value;
			  document.getElementById('isomax-value').innerHTML = isomaxValue;
			  RefreshVolumePlot();
			}

			function toggleTopography() {
				var checkbox = document.getElementById('show-topography-checkbox');
				if (checkbox.checked) {
					TopographyState = 1;
				} else {
					TopographyState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleSurveyPoints() {
				var checkbox = document.getElementById('show-survey-points-checkbox');
				if (checkbox.checked) {
					PointsState = 1;
				} else {
					PointsState = 0;
				}
				RefreshVolumePlot();
			}

			function toggleLogs() {
				var checkbox = document.getElementById('show-logs-checkbox');
				if (checkbox.checked) {
					LogState = 1;
				} else {
					LogState = 0;
				}
				RefreshVolumePlot();
			}
		
			function togglesectionLogs() {
				var checkbox = document.getElementById('show-sectionlogs-checkbox');
				if (checkbox.checked) {
					SectionLogsState = 1;
				} else {
					SectionLogsState = 0;
				}
				RefreshSectionPlot();
			}

			function togglefracturePoints() {
				var checkbox = document.getElementById('show-Fracturepoints-checkbox');
				if (checkbox.checked) {
					FracturePointState = 1;
				} else {
					FracturePointState = 0;
				}
				RefreshSectionPlot();
			}
			
			function toggleExternalData() {
				var checkbox = document.getElementById('show-ExternalData-checkbox');
				if (checkbox.checked) {
					ExternalDataState = 1;
				} else {
					ExternalDataState = 0;
				}
				RefreshSectionPlot();
			}
			
			function RefreshSectionPlot() {
				if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldFracscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldFracscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 1 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldFracscatterData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 1 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldFracscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 1)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionExtLogscatterData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else if (SectionLogsState == 0 && FracturePointState == 0 && ExternalDataState == 0)
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
				else
				{
					Plotly.react('plotly-Sections', [HoldSectioncontourData, HoldSectionToplineData, HoldSectionBottomlineData],HoldSectionlayout);
				}
			}
			
			window.addEventListener('resize', resizeCharts);
			
			function resizeCharts() 
			{
				var MapContainer = document.getElementById('plotly-contour');
				var SectionContainer = document.getElementById('plotly-Sections');
				var VolumeContainer = document.getElementById('plotly-Model1');
				var ProfileContainer = document.getElementById('plotly-Profile1');
				UpdateTraces('Traceplot-0-Lith', HolddataLith, 'Lithology Type', 'Type');
				UpdateTraces('Traceplot-1-Aqui', HolddataAqui, 'Aquifer Type', 'Type');
				UpdateTraces('Traceplot-2-Cond', HolddataCond, 'Condition Type', 'Type');
				UpdateTraces('Traceplot-3-Frac', HolddataFrac, 'Fractured Aquifer', 'Presences');
				UpdateTraces('Traceplot-4-Min', HolddataMin, 'Minimum Yield', 'l/s');
				UpdateTraces('Traceplot-5-Max', HolddataMax, 'Maximum Yield', 'l/s');
				UpdateTraces('Traceplot-6-Sus', HolddataSus, 'Sustainable Yield', 'l/s');
				UpdateTraces('Traceplot-7-PrimK', HolddataPrimK, 'PoreSpace Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-8-SecK', HolddataSecK, 'Matrix Hydraulic Conductivity', 'm/d');
				UpdateTraces('Traceplot-9-Poro', HolddataPoro, 'Porosity', '%');
				UpdateTraces('Traceplot-10-SStor', HolddataSStor, 'Specific Storage', '1/m');
				UpdateTraces('Traceplot-11-Stor', HolddataStor, 'Storativity', 'Unitless');
				UpdateTraces('Traceplot-12-Diff', HolddataDiff, 'Porespace Diffusivity', 'm2/s');
				UpdateTraces('Traceplot-13-Clay', HolddataClay, 'Clay Content', '%');
				UpdateTraces('Traceplot-14-Dens', HolddataDens, 'Density', 'kg/m3');
				UpdateTraces('Traceplot-15-Shear', HolddataShear, 'Shear Modulus', 'Pa');
				UpdateTraces('Traceplot-16-Bulk', HolddataBulk, 'Bulk Modulus', 'Pa');
				UpdateTraces('Traceplot-17-Comp', HolddataComp, 'Compressibility', '1/Pa');
				UpdateTraces('Traceplot-18-Yong', HolddataYong, 'Youngs Modulus', 'Pa');
				UpdateTraces('Traceplot-19-WQ', HolddataWQ, 'Relative Water Quality', 'Rel %');
				UpdateTraces('Traceplot-20-AI', HolddataAI, 'Aquifer Indicator', 'Presence');
				UpdateTraces('Traceplot-21-FC', HolddataFC, 'Formation Fracturing', 'Count');
				UpdateTraces('Traceplot-22-SPTN', HolddataSPTN, 'SPTN', 'Unitless');
				UpdateTraces('Traceplot-23-SPTRQD', HolddataSPTRQD, 'SPTRQD', 'Unitless');
				UpdateTraces('Traceplot-24-SV', HolddataSV, 'Seismic P-Wave Velocity', 'm/s');
				UpdateTraces('Traceplot-25-AcouI', HolddataAcouI, 'Acoustic Impeadance', 'Pa s/m3');
				UpdateTraces('Traceplot-26-FR', HolddataFR, 'Frenzel Radius', 'm');
				UpdateTraces('Traceplot-27-TC', HolddataTC, 'Transmittion Coefficient', 'Coeff');
				UpdateTraces('Traceplot-28-CA', HolddataCA, 'Critical Angle', 'Deg');
				UpdateTraces('Traceplot-29-QP', HolddataQP, 'Seismic Attenuation Qp', 'GPa');
				UpdateTraces('Traceplot-30-QS', HolddataQS, 'Seismic Attenuation Qs', 'GPa');
				UpdateTraces('Traceplot-31-Res', HolddataRes, 'Apparent Resistivity', 'Ohm/m');
				UpdateTraces('Traceplot-32-ET', HolddataET, 'Poisson Ratio', 'Ratio');
				UpdateTraces('Traceplot-33-MT', HolddataMagT, 'Specific Volume', 'm3/kg');
				UpdateTraces('Traceplot-34-PT', HolddataPT, 'Porespace Transmissivity', 'm2/d');
				UpdateTraces('Traceplot-35-PP', HolddataPP, 'Porespace Permeability', 'md');
				UpdateTraces('Traceplot-36-MT', HolddataMT, 'Matrix Transmisivity', 'm2/d');
				UpdateTraces('Traceplot-37-MP', HolddataMP, 'Matrix Permeability', 'md');
				UpdateTraces('Traceplot-38-PC', HolddataPC, 'Permeability Contrast', 'Ratio');
				UpdateTraces('Traceplot-39-AP', HolddataAP, 'Aquifer Probability', '%');
				UpdateTraces('Traceplot-40-Temp', HolddataTemp, 'Calculated Temperature Estimate', 'degC');
				UpdateTraces('Traceplot-41-AC', HolddataAquilude, 'Calculated Relative Aquiclude Probability Estimate', '%');
				UpdateTraces('Traceplot-42-OIL', HolddataOil, 'Calculated Hydrocarbon Potential', '%');
				UpdateTraces('Traceplot-43-SAT', HolddataSAT, 'Calculated Saturation', '%');
				MapContainer.style.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				SectionContainer.style.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				VolumeContainer.style.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				ProfileContainer.style.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldSiteMaplayout.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldSiteMaplayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				Plotly.react('plotly-contour', [SiteMapcontourData, SiteMapscatterData], HoldSiteMaplayout);
				HoldSectionlayout.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldSectionlayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshSectionPlot();
				HoldLayout.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshVolumePlot();
				HoldProfileLayout.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldProfileLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshProfilePlot();
				HoldPresentationLayout.width = Math.min(window.outerWidth-100, window.innerWidth-100);
				HoldPresentationLayout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
				RefreshPresentationPlot();
			}
			
			function RefreshPresentationPlot()
			{
				Plotly.react('plotly-presentation', HoldPresentationLayout);
			}
			
			function RefreshProfilePlot()
			{
				Plotly.react('plotly-Profile1', HoldProfilerawTopdata.concat(HoldProfileSurfaceGroup), HoldProfileLayout);
			}
			
			const collapsibleBtn = document.querySelector('.collapsible');
			const contentDiv = document.querySelector('.desccontent');
			collapsibleBtn.addEventListener('click', function() {
			contentDiv.classList.toggle('active');
				if (contentDiv.classList.contains('active')) 
				{
					contentDiv.style.display = 'block';
				} 
				else 
				{
					contentDiv.style.display = 'none';
				}
			});
			
			function playAudioSurveySiteMap() {
			  var audio = document.getElementById("audioPlayerSurveySiteMap");
			  audio.play();
			}
			
			function playAudioRecommendations() {
			  var audio = document.getElementById("audioPlayerRecommendations");
			  audio.play();
			}
			
			function playAudioSurveyPoints() {
			  var audio = document.getElementById("audioPlayerSurveyPoints");
			  audio.play();
			}
			
			function playAudioViewDataSetDescriptions() {
			  var audio = document.getElementById("audioPlayerViewDataSetDescriptions");
			  audio.play();
			}
			
			function playAudioAquiferClassification() {
			  var audio = document.getElementById("audioPlayerAquiferClassification");
			  audio.play();
			}
			
			function playAudioWaterSheds() {
			  var audio = document.getElementById("audioPlayerWaterSheds");
			  audio.play();
			}
			
			function playAudioLithology() {
			  var audio = document.getElementById("audioPlayerLithology");
			  audio.play();
			}
			
			function playAudioGroundwaterLevel() {
			  var audio = document.getElementById("audioPlayerGroundwaterLevel");
			  audio.play();
			}
			
			function playAudioFaulting() {
			  var audio = document.getElementById("audioPlayerFaulting");
			  audio.play();
			}
			
			function playAudioSalineAquifers() {
			  var audio = document.getElementById("audioPlayerSalineAquifers");
			  audio.play();
			}
			
			function playAudioGeothermal() {
			  var audio = document.getElementById("audioPlayerGeothermal");
			  audio.play();
			}
			
			function playAudioSiteParameterMaps() {
			  var audio = document.getElementById("audioPlayerSiteParameterMaps");
			  audio.play();
			}
			
			function playAudioSiteSectionLine() {
			  var audio = document.getElementById("audioPlayerSiteSectionLine");
			  audio.play();
			}
			
			function playAudioSectionSettings() {
			  var audio = document.getElementById("audioPlayerSectionSettings");
			  audio.play();
			}
			
			function playAudioSelectSectionPoints() {
			  var audio = document.getElementById("audioPlayerSelectSectionPoints");
			  audio.play();
			}
			
			function playAudioSiteModels() {
			  var audio = document.getElementById("audioPlayerSiteModels");
			  audio.play();
			}
			
			function playAudioModelSettings() {
			  var audio = document.getElementById("audioPlayerModelSettings");
			  audio.play();
			}
			
			function playAudioSliceSettings() {
			  var audio = document.getElementById("audioPlayerSliceSettings");
			  audio.play();
			}
			
			function playAudioPointDataTraces() {
			  var audio = document.getElementById("audioPlayerPointDataTraces");
			  audio.play();
			}
			
			function playAudioPointVirtualLogs() {
			  var audio = document.getElementById("audioPlayerPointVirtualLogs");
			  audio.play();
			}

			function playAudioSelectModelPoints() {
			  var audio = document.getElementById("audioPlayerSelectModelPoints");
			  audio.play();
			}
			
			function playSiteMapSettings() {
			  var audio = document.getElementById("audioPlayerSiteMapSettings");
			  audio.play();
			}
						
			function playReportDataElevationSettings() {
			  var audio = document.getElementById("audioPlayerReportDataElevationSettings");
			  audio.play();
			}
						
			function playViewGISDataMaps() {
			  var audio = document.getElementById("audioPlayerViewGISDataMaps");
			  audio.play();
			}
						
			function playCreateSiteParameterMapViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteParameterMapViews");
			  audio.play();
			}
						
			function playCreatePresentationViews() {
			  var audio = document.getElementById("audioPlayerCreatePresentationViews");
			  audio.play();
			}
						
			function playCreateSiteSectionLineViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteSectionLineViews");
			  audio.play();
			}
						
			function playSectionAmplitudeSettings() {
			  var audio = document.getElementById("audioPlayerSectionAmplitudeSettings");
			  audio.play();
			}
						
			function playCreateSiteProfileViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteProfileViews");
			  audio.play();
			}
						
			function playCreateSiteModelViews() {
			  var audio = document.getElementById("audioPlayerCreateSiteModelViews");
			  audio.play();
			}
						
			function playViewControls() {
			  var audio = document.getElementById("audioPlayerViewControls");
			  audio.play();
			}
						
			function playPresentationViews() {
			  var audio = document.getElementById("audioPlayerPresentationViews");
			  audio.play();
			}
			
			document.addEventListener("DOMContentLoaded", function() 
			{
				const tabs = document.querySelectorAll('.tab-link');
				const slides = document.querySelectorAll('.slides');
				tabs.forEach(tab => {
					tab.addEventListener('click', function(e) {
						e.preventDefault();
						const targetSlide = this.getAttribute('data-slide');
						tabs.forEach(tab => tab.classList.remove('active'));
						slides.forEach(slide => slide.classList.remove('active'));
						this.classList.add('active');
						document.getElementById(targetSlide).classList.add('active');
					});
				});
			});

			function toggleProfileOneForm() {
				var form = document.getElementById("profileFormOne");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleProfileTwoForm() {
				var form = document.getElementById("profileFormTwo");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleProfileThreeForm() {
				var form = document.getElementById("profileFormThree");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}

			function toggleModelForm() {
				var form = document.getElementById("ModelcheckboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function toggleSectionForm() {
				var form = document.getElementById("checkboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}

			function toggleContourForm() {
				var form = document.getElementById("ContourcheckboxForm");
				if (form.style.display === "none") {
					form.style.display = "block";
				} else {
					form.style.display = "none";
				}
			}
			
			function startAnimation() {
				animationInterval = setInterval(function() {
					rotate('scene', Math.PI / 180);
				}, 50); // Adjust animation speed here
			}

			function stopAnimation() {
				clearInterval(animationInterval);
			}

			function rotate(id, angle) {
				var eye0 = gd.layout[id].camera.eye;
				var rtz = xyz2rtz(eye0);
				rtz.t += angle;
	  
				var eye1 = rtz2xyz(rtz);
				Plotly.relayout(gd, id + '.camera.eye', eye1);
			}

			function xyz2rtz(xyz) {
				return {
					r: Math.sqrt(xyz.x * xyz.x + xyz.y * xyz.y),
					t: Math.atan2(xyz.y, xyz.x),
					z: xyz.z
				};
			}

			function rtz2xyz(rtz) {
				return {
					x: rtz.r * Math.cos(rtz.t),
					y: rtz.r * Math.sin(rtz.t),
					z: rtz.z
				};
			}

			animationButton.addEventListener('click', function() {
				if (!isAnimating) {
					startAnimation();
					animationButton.textContent = 'Stop Model Rotation';
				} else {
					stopAnimation();
					animationButton.textContent = 'Start Model Rotation';
				}
				isAnimating = !isAnimating;
			});
			
			function ProfstartAnimation() {
				ProfanimationInterval = setInterval(function() {
					Profrotate('scene', Math.PI / 180);
				}, 50); // Adjust animation speed here
			}

			function ProfstopAnimation() {
				clearInterval(ProfanimationInterval);
			}

			function Profrotate(id, angle) {
				var eye0 = Profgd.layout[id].camera.eye;
				var rtz = Profxyz2rtz(eye0);
				rtz.t += angle;
	  
				var eye1 = Profrtz2xyz(rtz);
				Plotly.relayout(Profgd, id + '.camera.eye', eye1);
			}

			function Profxyz2rtz(xyz) {
				return {
					r: Math.sqrt(xyz.x * xyz.x + xyz.y * xyz.y),
					t: Math.atan2(xyz.y, xyz.x),
					z: xyz.z
				};
			}

			function Profrtz2xyz(rtz) {
				return {
					x: rtz.r * Math.cos(rtz.t),
					y: rtz.r * Math.sin(rtz.t),
					z: rtz.z
				};
			}

			ProfanimationButton.addEventListener('click', function() {
				if (!ProfisAnimating) {
					ProfstartAnimation();
					ProfanimationButton.textContent = 'Stop Profile Rotation';
				} else {
					ProfstopAnimation();
					ProfanimationButton.textContent = 'Start Profile Rotation';
				}
				ProfisAnimating = !ProfisAnimating;
			});
			
			function toggleSiteMapRecPoints() {
				var checkBox = document.getElementById("RecPoints-checkbox");
				if (checkBox.checked) {
					SiteMapShowRecPointsOnly = true;
					SiteMapShowRecPointsOnlychanged = true;
					refreshSiteMap('dataset1');
					
				} else {
					SiteMapShowRecPointsOnly = false;
					SiteMapShowRecPointsOnlychanged = true;
					refreshSiteMap('dataset1');
					
				}
			}
			
			document.getElementById('Sectionmax-value').textContent = document.getElementById('range-slider').value;

			function updateMaxValue() {
			  var maxValue = parseInt(document.getElementById('range-slider').value);
			  UserSetmaxValue = maxValue;
			  updateSectionPlot(HoldselectedData);
			  document.getElementById('Sectionmax-value').textContent = maxValue;
			}

			document.getElementById('range-slider').addEventListener('input', updateMaxValue);
			
			function downloadStaticMap1() {
				leafletImage(map1, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Site map.png';
					link.click();
				});
			}

			function downloadStaticMap2() {
				leafletImage(map2, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Aquifer map.png';
					link.click();
				});
			}
			
			function downloadStaticMap3() {
				leafletImage(map3, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Groundwater level map.png';
					link.click();
				});
			}
			
			function downloadStaticMap4() {
				leafletImage(map4, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Faulting map.png';
					link.click();
				});
			}
			
			function downloadStaticMap5() {
				leafletImage(map5, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Lithology map.png';
					link.click();
				});
			}
			
			function downloadStaticMap6() {
				leafletImage(map6, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Water shed map.png';
					link.click();
				});
			}
			
			function downloadStaticMap7() {
				leafletImage(map7, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Saline aquifer map.png';
					link.click();
				});
			}
			
			function downloadStaticMap8() {
				leafletImage(map8, function(err, canvas) {
					var dataURL = canvas.toDataURL('image/png');
					var byteString = atob(dataURL.split(',')[1]);
					var mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
					var ab = new ArrayBuffer(byteString.length);
					var ia = new Uint8Array(ab);
					for (var i = 0; i < byteString.length; i++) {
						ia[i] = byteString.charCodeAt(i);
					}
					var blob = new Blob([ab], { type: mimeString });
					var link = document.createElement('a');
					link.href = window.URL.createObjectURL(blob);
					link.download = 'Geothermal map.png';
					link.click();
				});
			}
			
			document.getElementById('download-btn1').addEventListener('click', downloadStaticMap1);
			document.getElementById('download-btn2').addEventListener('click', downloadStaticMap2);
			document.getElementById('download-btn3').addEventListener('click', downloadStaticMap3);
			document.getElementById('download-btn4').addEventListener('click', downloadStaticMap4);
			document.getElementById('download-btn5').addEventListener('click', downloadStaticMap5);
			document.getElementById('download-btn6').addEventListener('click', downloadStaticMap6);
			document.getElementById('download-btn7').addEventListener('click', downloadStaticMap7);
			document.getElementById('download-btn8').addEventListener('click', downloadStaticMap8);
			
			function savePlot1() {
				const plotDiv = document.getElementById('plotly-contour');
				const selectedIndex = document.getElementById('viewSelector1').value;
				const description = document.getElementById('description1').value;
				plotDataStorage1[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot1() {
				const selectedIndex = document.getElementById('viewSelector1').value;
				const plotData = plotDataStorage1[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-contour', plotData.data, plotData.layout);
					document.getElementById('description1').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile1() {
				const blob = new Blob([JSON.stringify(plotDataStorage1)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteParameterMapViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile1(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage1.splice(0, plotDataStorage1.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription1() {
				const selectedIndex = document.getElementById('viewSelector1').value;
				const plotData = plotDataStorage1[selectedIndex];
				document.getElementById('description1').value = plotData.description;
			}

			function prevView1() {
				const viewSelector = document.getElementById('viewSelector1');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription1();
					loadPlot1();
				}
			}

			function nextView1() {
				const viewSelector = document.getElementById('viewSelector1');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription1();
					loadPlot1();
				}
			}

			function savePlot2() {
				const plotDiv = document.getElementById('plotly-Sections');
				const selectedIndex = document.getElementById('viewSelector2').value;
				const description = document.getElementById('description2').value;
				plotDataStorage2[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot2() {
				const selectedIndex = document.getElementById('viewSelector2').value;
				const plotData = plotDataStorage2[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Sections', plotData.data, plotData.layout);
					document.getElementById('description2').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile2() {
				const blob = new Blob([JSON.stringify(plotDataStorage2)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteSectionLineViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile2(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage2.splice(0, plotDataStorage2.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription2();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription2() {
				const selectedIndex = document.getElementById('viewSelector2').value;
				const plotData = plotDataStorage2[selectedIndex];
				document.getElementById('description2').value = plotData.description;
			}

			function prevView2() {
				const viewSelector = document.getElementById('viewSelector2');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription2();
					loadPlot2();
				}
			}

			function nextView2() {
				const viewSelector = document.getElementById('viewSelector2');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription2();
					loadPlot2();
				}
			}

			function savePlot3() {
				const plotDiv = document.getElementById('plotly-Profile1');
				const selectedIndex = document.getElementById('viewSelector3').value;
				const description = document.getElementById('description3').value;
				plotDataStorage3[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot3() {
				const selectedIndex = document.getElementById('viewSelector3').value;
				const plotData = plotDataStorage3[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Profile1', plotData.data, plotData.layout);
					document.getElementById('description3').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile3() {
				const blob = new Blob([JSON.stringify(plotDataStorage3)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteProfileViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile3(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage3.splice(0, plotDataStorage3.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription3();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription3() {
				const selectedIndex = document.getElementById('viewSelector3').value;
				const plotData = plotDataStorage3[selectedIndex];
				document.getElementById('description3').value = plotData.description;
			}

			function prevView3() {
				const viewSelector = document.getElementById('viewSelector3');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription3();
					loadPlot3();
				}
			}

			function nextView3() {
				const viewSelector = document.getElementById('viewSelector3');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription3();
					loadPlot3();
				}
			}

			function savePlot4() {
				const plotDiv = document.getElementById('plotly-Model1');
				const selectedIndex = document.getElementById('viewSelector4').value;
				const description = document.getElementById('description4').value;
				plotDataStorage4[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot4() {
				const selectedIndex = document.getElementById('viewSelector4').value;
				const plotData = plotDataStorage4[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Model1', plotData.data, plotData.layout);
					document.getElementById('description4').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile4() {
				const blob = new Blob([JSON.stringify(plotDataStorage4)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'SiteModelViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile4(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage4.splice(0, plotDataStorage4.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription4();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription4() {
				const selectedIndex = document.getElementById('viewSelector4').value;
				const plotData = plotDataStorage4[selectedIndex];
				document.getElementById('description4').value = plotData.description;
			}

			function prevView4() {
				const viewSelector = document.getElementById('viewSelector4');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription4();
					loadPlot4();
				}
			}

			function nextView4() {
				const viewSelector = document.getElementById('viewSelector4');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription4();
					loadPlot4();
				}
			}

			function savePlot5() {
				const plotDiv = document.getElementById('plotly-contour');
				const selectedIndex = document.getElementById('viewSelector5').value;
				const description = document.getElementById('description5').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot5() {
				const selectedIndex = document.getElementById('viewSelector5').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-contour', plotData.data, plotData.layout);
					document.getElementById('description5').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile5() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile5(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription5();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription5() {
				const selectedIndex = document.getElementById('viewSelector5').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description5').value = plotData.description;
			}

			function prevView5() {
				const viewSelector = document.getElementById('viewSelector5');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription5();
					loadPlot5();
				}
			}

			function nextView5() {
				const viewSelector = document.getElementById('viewSelector5');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription5();
					loadPlot5();
				}
			}

			function savePlot6() {
				const plotDiv = document.getElementById('plotly-Sections');
				const selectedIndex = document.getElementById('viewSelector6').value;
				const description = document.getElementById('description6').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot6() {
				const selectedIndex = document.getElementById('viewSelector6').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Sections', plotData.data, plotData.layout);
					document.getElementById('description6').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile6() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile6(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription6();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription6() {
				const selectedIndex = document.getElementById('viewSelector6').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description6').value = plotData.description;
			}

			function prevView6() {
				const viewSelector = document.getElementById('viewSelector6');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription6();
					loadPlot6();
				}
			}

			function nextView6() {
				const viewSelector = document.getElementById('viewSelector6');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription6();
					loadPlot6();
				}
			}

			function savePlot7() {
				const plotDiv = document.getElementById('plotly-Profile1');
				const selectedIndex = document.getElementById('viewSelector7').value;
				const description = document.getElementById('description7').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot7() {
				const selectedIndex = document.getElementById('viewSelector7').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Profile1', plotData.data, plotData.layout);
					document.getElementById('description7').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile7() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile7(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription7();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription7() {
				const selectedIndex = document.getElementById('viewSelector7').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description7').value = plotData.description;
			}

			function prevView7() {
				const viewSelector = document.getElementById('viewSelector7');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription7();
					loadPlot7();
				}
			}

			function nextView7() {
				const viewSelector = document.getElementById('viewSelector7');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription7();
					loadPlot7();
				}
			}

			function savePlot8() {
				const plotDiv = document.getElementById('plotly-Model1');
				const selectedIndex = document.getElementById('viewSelector8').value;
				const description = document.getElementById('description8').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot8() {
				const selectedIndex = document.getElementById('viewSelector8').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-Model1', plotData.data, plotData.layout);
					document.getElementById('description8').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile8() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile8(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription8();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription8() {
				const selectedIndex = document.getElementById('viewSelector8').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description8').value = plotData.description;
			}

			function prevView8() {
				const viewSelector = document.getElementById('viewSelector8');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription8();
					loadPlot8();
				}
			}

			function nextView8() {
				const viewSelector = document.getElementById('viewSelector8');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription8();
					loadPlot8();
				}
			}

			function savePlot9() {
				const plotDiv = document.getElementById('plotly-presentation');
				const selectedIndex = document.getElementById('viewSelector9').value;
				const description = document.getElementById('description9').value;
				plotDataStorage5[selectedIndex] = {
					data: plotDiv.data,
					layout: plotDiv.layout,
					description: description
				};
				alert(`Plot and description saved to View ${parseInt(selectedIndex) + 1}`);
			}

			function loadPlot9() {
				const selectedIndex = document.getElementById('viewSelector9').value;
				const plotData = plotDataStorage5[selectedIndex];
				if (plotData.data) {
					plotData.layout.width = Math.min(window.outerWidth-100, window.innerWidth-100),
					plotData.layout.height = Math.min(window.outerWidth, window.innerWidth, 1100)*0.7;
					Plotly.react('plotly-presentation', plotData.data, plotData.layout);
					document.getElementById('description9').value = plotData.description;
				} else {
					alert(`No plot data saved for View ${parseInt(selectedIndex) + 1}`);
				}
			}

			function saveAllPlotsToFile9() {
				const blob = new Blob([JSON.stringify(plotDataStorage5)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'PresentationViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadPlotsFromFile9(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData);
						alert('Plots loaded from file');
						updateDescription9();
					};
					reader.readAsText(file);
				}
			}

			function updateDescription9() {
				const selectedIndex = document.getElementById('viewSelector9').value;
				const plotData = plotDataStorage5[selectedIndex];
				document.getElementById('description9').value = plotData.description;
			}

			function prevView9() {
				const viewSelector = document.getElementById('viewSelector9');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex > 0) {
					viewSelector.value = selectedIndex - 1;
					updateDescription9();
					loadPlot9();
				}
			}

			function nextView9() {
				const viewSelector = document.getElementById('viewSelector9');
				const selectedIndex = parseInt(viewSelector.value);
				if (selectedIndex < viewSelector.options.length - 1) {
					viewSelector.value = selectedIndex + 1;
					updateDescription9();
					loadPlot9();
				}
			}

			function combineArrays() {
				return [
					plotDataStorage1,
					plotDataStorage2,
					plotDataStorage3,
					plotDataStorage4,
					plotDataStorage5
				];
			}

			function saveAllDataToFile() {
				const combinedData = combineArrays();
				const blob = new Blob([JSON.stringify(combinedData)], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = 'GeoVueViews.json';
				a.click();
				URL.revokeObjectURL(url);
			}

			function loadAllDataFromFile(event) {
				const file = event.target.files[0];
				if (file) {
					const reader = new FileReader();
					reader.onload = function(e) {
						const contents = e.target.result;
						const loadedData = JSON.parse(contents);
						if (loadedData.length === 5) {
							plotDataStorage1.splice(0, plotDataStorage1.length, ...loadedData[0]);
							plotDataStorage2.splice(0, plotDataStorage2.length, ...loadedData[1]);
							plotDataStorage3.splice(0, plotDataStorage3.length, ...loadedData[2]);
							plotDataStorage4.splice(0, plotDataStorage4.length, ...loadedData[3]);
							plotDataStorage5.splice(0, plotDataStorage5.length, ...loadedData[4]);
							alert('Data successfully loaded from file');
						} else {
							alert('Invalid data format in file');
						}
					};
					reader.readAsText(file);
				}
			}
			
			function exportTableToExcel(tableID, filename = ''){
				var table = document.getElementById(tableID);
				var worksheet = XLSX.utils.table_to_sheet(table);
				var workbook = XLSX.utils.book_new();
				XLSX.utils.book_append_sheet(workbook, worksheet, "Sheet1");
				XLSX.writeFile(workbook, filename ? filename + '.xlsx' : 'exported_data.xlsx');
			}
			
			function toggleZero()
			{
				var checkBox = document.getElementById("ZeroElevation-checkbox");
				var checkBox2 = document.getElementById("SRTMElevation-checkbox");

				if (checkBox2.checked)
				{
					checkBox2.checked = false;
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxData.data[i][3][10] = BoxElevationArray[i];
					}
				}
								
				if (checkBox.checked) 
				{
					BoxElevationArray = [];
					let elevationList = "Zero Elevations Applied:\n";
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxElevationArray.push(BoxData.data[i][3][10]);
						BoxData.data[i][3][10] = 0;
						elevationList += `Location ${i + 1}: ${0} meters\n`;
					}
					elevationList += "Please Refresh the Report Charts";
					alert(elevationList);
				} 
				else 
				{
					let elevationList = "GPS Elevations Restored:\n";
					for (let i = 0; i < BoxData.data.length; i++) 
					{
						BoxData.data[i][3][10] = BoxElevationArray[i];
						elevationList += `Location ${i + 1}: ${BoxElevationArray[i]} meters\n`;
					}
					elevationList += "Please Refresh the Report Charts";
					alert(elevationList);
				}
				refreshRecTable();
				refreshdataTable();
			}
			
			async function toggleSRTM() {
				const checkBox = document.getElementById("SRTMElevation-checkbox");
				const checkBox2 = document.getElementById("ZeroElevation-checkbox");
				const locations = [];

				// Function to load Google Maps API dynamically
				function loadGoogleMapsApi(callback) {
					if (typeof google !== 'undefined' && google.maps) {
						// Google Maps API is already loaded
						callback();
					} else {
						// Create a script element to load Google Maps API
						const script = document.createElement('script');
						script.src = `https://maps.googleapis.com/maps/api/js?key=${AAC}`;
						script.async = true;
						script.defer = true;
						script.onload = callback; // Execute the callback after the script is loaded
						document.head.appendChild(script);
					}
				}

				// Function to handle elevation data once Google Maps API is loaded
				function handleElevation() {
					if (checkBox2.checked) {
						checkBox2.checked = false;
						for (let i = 0; i < BoxData.data.length; i++) {
							BoxData.data[i][3][10] = BoxElevationArray[i];
						}
					}

					if (checkBox.checked) {
						if (SRTMLoaded == 0) {
							for (let i = 0; i < BoxData.data.length; i++) {
								locations.push(new google.maps.LatLng(BoxData.data[i][1], BoxData.data[i][2]));
								BoxElevationArray.push(BoxData.data[i][3][10]);
							}

							const elevator = new google.maps.ElevationService();
							const positionalRequest = {
								locations: locations
							};

							elevator.getElevationForLocations(positionalRequest, function(results, status) {
								if (status === 'OK') {
									if (results.length === BoxData.data.length) {
										SRTMelevations = results.map(result => result.elevation);

										let elevationList = "SRTM Elevations Applied:\n";
										for (let i = 0; i < SRTMelevations.length; i++) {
											BoxData.data[i][3][10] = SRTMelevations[i];
											elevationList += `Location ${i + 1}: ${SRTMelevations[i]} meters\n`;
										}
										SRTMLoaded = 1;
										elevationList += "Please Refresh the Report Charts";
										alert(elevationList);
									} else {
										alert('There was an error collecting the elevation data 2');
									}
								} else {
									alert('Elevation service failed due to: ' + status);
								}
							});
						} else {
							let elevationList = "SRTM Elevations Applied:\n";
							for (let i = 0; i < SRTMelevations.length; i++) {
								BoxData.data[i][3][10] = SRTMelevations[i];
								elevationList += `Location ${i + 1}: ${SRTMelevations[i]} meters\n`;
							}
							elevationList += "Please Refresh the Report Charts";
							alert(elevationList);
						}
					} else {
						let elevationList = "GPS Elevations Restored:\n";
						for (let i = 0; i < BoxData.data.length; i++) {
							BoxData.data[i][3][10] = BoxElevationArray[i];
							elevationList += `Location ${i + 1}: ${BoxElevationArray[i]} meters\n`;
						}
						elevationList += "Please Refresh the Report Charts";
						alert(elevationList);
					}
				}

				// Load Google Maps API and then handle elevation
				loadGoogleMapsApi(handleElevation);
				refreshRecTable();
				refreshdataTable();
			}
			
			const collapsibleBtn2 = document.querySelector('.GIScollapsible');
			const contentDiv2 = document.querySelector('.GIScontent');
			collapsibleBtn2.addEventListener('click', function() {
			contentDiv2.classList.toggle('active');
				if (contentDiv2.classList.contains('active')) 
				{
					contentDiv2.style.display = 'block';
				} 
				else 
				{
					contentDiv2.style.display = 'none';
				}
			});
			
			function updateTemperature() {
				const input = document.getElementById('temperatureInput').value;
				const temp = parseFloat(input);

				if (isNaN(temp)) {
					alert('Please enter a valid number');
					document.getElementById('temperatureInput').value = GlobalTemperature;
					return;
				}

				GlobalTemperature = temp;
			}
			
			function AutoCalibrateTemperature() {
				var DataArray = BoxData.data;
				var MaxDepth = 0.0;
				var Gradient = 0.025;
				var ThermalMax = 0.0;
				for (var i = 0; i < DataArray.length; i++) 
				{
					if (DataArray[i][3][39] > MaxDepth)
					{
						MaxDepth = DataArray[i][3][39];
					}
				}				
				ThermalMax = MaxDepth * Gradient;
				document.getElementById('temperatureInput').value = ThermalMax;
				GlobalTemperature = ThermalMax;
			}
			
			// Add event listener to the checkbox
			document.getElementById('correct-chart-checkbox').addEventListener('change', handleCorrectCheckboxChange);
			// Function to handle checkbox change
			function handleCorrectCheckboxChange(event) {
				if (event.target.checked) 
				{
					CorrectChart = 3;  // Update the global variable to 3 when checked
				} 
				else 
				{
					CorrectChart = 0;  // Reset to 0 when unchecked
				}
				updateProfilePlot(ProfileselectedDataHold);
			}

			// Add event listener to the button to trigger the fetch
			document.getElementById('fetchButton').addEventListener('click', fetchTextFile);
			// Function to fetch the file and store its contents in a variable
			async function fetchTextFile() {
				const url = 'https://raw.githubusercontent.com/GeoVue/GV/main/PT.txt';
				try {
					// Fetch the file from the server
					const response = await fetch(url);

					// Check if the request was successful
					if (!response.ok) {
						throw new Error(`HTTP error! Status: ${response.status}`);
					}

					// Read the response as text
					const text = await response.text();

					// Display the contents of the file in the <pre> element
					//document.getElementById('fileContents').textContent = text;

					const placeholder = '&&&###';

					const modifiedObjectString = `var BoxData = ${JSON.stringify(BoxData)};`;
					let modifiedData = text.replace(placeholder, modifiedObjectString);
					
					//const Rep1 =  '{\"name\":\"Calculated Sustainable Yield Estimate(l/s)\",\"ID\":\"atsgeosuite/cjegt9c5l1x672qqghx7cya9p\",\"data\"}';
					//const Rep2 =  "{name:\'Calculated Sustainable Yield Estimate(l/s)\',ID:\'atsgeosuite/cjegt9c5l1x672qqghx7cya9p\',data}";
					
					const Rep1 =  '\"name\"';
					const Rep2 =  '\"Calculated Sustainable Yield Estimate(l/s)\"';
					const Rep3 =  '\"ID\"';
					const Rep4 =  '\"atsgeosuite/cjegt9c5l1x672qqghx7cya9p\"';
					const Rep5 =  '\"data\"';
					
					const Mod1 =  'name';
					const Mod2 =  '\'Calculated Sustainable Yield Estimate(l/s)\'';
					const Mod3 =  'ID';
					const Mod4 =  '\'atsgeosuite/cjegt9c5l1x672qqghx7cya9p\'';
					const Mod5 =  'data';
					
					modifiedData = modifiedData.replace(Rep1, Mod1);
					modifiedData = modifiedData.replace(Rep2, Mod2);
					modifiedData = modifiedData.replace(Rep3, Mod3);
					modifiedData = modifiedData.replace(Rep4, Mod4);
					modifiedData = modifiedData.replace(Rep5, Mod5);
					
					const placeholder2 = '%%%@@@';

					const modifiedObjectString1 = `const selectionPointArray = ${JSON.stringify(selectionPointArray)};`;
					modifiedData = modifiedData.replace(placeholder2, modifiedObjectString1);
					
					
					const placeholder3 = '$$$ABC@@@';

					const modifiedObjectString2 = `const plotDataStorage1 = ${JSON.stringify(plotDataStorage1)};`;
					modifiedData = modifiedData.replace(placeholder3, modifiedObjectString2);
					
					const placeholder4 = '$$$DEF@@@';

					const modifiedObjectString3 = `const plotDataStorage2 = ${JSON.stringify(plotDataStorage2)};`;
					modifiedData = modifiedData.replace(placeholder4, modifiedObjectString3);
					
					const placeholder5 = '$$$GHI@@@';

					const modifiedObjectString4 = `const plotDataStorage3 = ${JSON.stringify(plotDataStorage3)};`;
					modifiedData = modifiedData.replace(placeholder5, modifiedObjectString4);
					
					const placeholder6 = '$$$JKL@@@';

					const modifiedObjectString5 = `const plotDataStorage4 = ${JSON.stringify(plotDataStorage4)};`;
					modifiedData = modifiedData.replace(placeholder6, modifiedObjectString5);
					
					const placeholder7 = '$$$MNO@@@';

					const modifiedObjectString6 = `const plotDataStorage5 = ${JSON.stringify(plotDataStorage5)};`;
					modifiedData = modifiedData.replace(placeholder7, modifiedObjectString6);
					
					const placeholder8 = '$$$PQR@@@';

					const modifiedObjectString7 = `let ExternalDataArray = ${JSON.stringify(ExternalDataArray)};`;
					modifiedData = modifiedData.replace(placeholder8, modifiedObjectString7);
					
					//document.getElementById('fileContents').textContent = modifiedData;
					
					const combinedData = modifiedData;
					const blob = new Blob([combinedData], { type: 'text/html' });
					const urll = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = urll;
					a.download = 'SavedPresentation.html';
					a.click();
					URL.revokeObjectURL(urll);
					
					
					// Log the contents of the file to the console
					console.log(text);
				} catch (error) {
					// Handle any errors that occurred during the fetch
					console.error('Error fetching the text file:', error);
					//document.getElementById('fileContents').textContent = error;
				}
			}

			function EditPoint(Index) {
				var selectElement = document.getElementById("rowSelectorEditPoint");
				selectElement.selectedIndex = Index;
				selectRowEditPoint(); // Ensure the row is selected
			}

			function populateDropdownEditPoint() {
				var dropdown = document.getElementById("rowSelectorEditPoint");
				dropdown.innerHTML = "<option value='-1' disabled selected>Select Point</option>";
				var numRows = BoxData.data.length;
				for (var i = 0; i < numRows; i++) {
					var option = document.createElement("option");
					option.value = i;
					option.textContent = "Point " + (BoxData.data[i][0]);
					dropdown.appendChild(option);
				}
			}

			// Add event listener to call selectRowEditPoint when the dropdown value changes
			document.getElementById("rowSelectorEditPoint").addEventListener('change', selectRowEditPoint);

			function selectRowEditPoint() {
				var dropdown = document.getElementById("rowSelectorEditPoint");
				var selectedIndex = parseInt(dropdown.value, 10); // Ensure selectedIndex is an integer
				if (selectedIndex === -1 || isNaN(selectedIndex)) {
					return;
				}
				var selectedRowData = BoxData.data[selectedIndex];

				document.getElementById("LatInput").value = selectedRowData[1];
				document.getElementById("LonInput").value = selectedRowData[2];
				document.getElementById("ElevInput").value = selectedRowData[3][10];
			}

			// Call to populate the dropdown on page load
			populateDropdownEditPoint();
			
			function UpdatePointData()
			{
				var dropdown = document.getElementById("rowSelectorEditPoint");
				var selectedIndex = parseInt(dropdown.value, 10); // Ensure selectedIndex is an integer
				if (selectedIndex === -1 || isNaN(selectedIndex)) {
					return;
				}

				BoxData.data[selectedIndex][1] = parseFloat(document.getElementById("LatInput").value);
				BoxData.data[selectedIndex][2] = parseFloat(document.getElementById("LonInput").value);
				BoxData.data[selectedIndex][3][10] = parseFloat(document.getElementById("ElevInput").value);
				//updateSiteMap('dataset1');
				//updateMarkerCoordinates(selectedIndex, BoxData.data[selectedIndex][1], BoxData.data[selectedIndex][2]);
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}
			
			function updateMarkerCoordinates(markerId, newLat, newLng) {
				// Check if the marker exists in the markers object
				if (markers[markerId]) {
					markers[markerId].setLatLng([newLat, newLng]); // Update the marker position
				} else {
					console.error('Marker not found!');
				}
			}
			
			function updateAllMaps()
			{
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
			}
			
			function EditSectionData() 
			{
				var DataArray = BoxData.data;
				SectionBoxData = [];
				for (let i = 0; i < DataArray.length; i++) 
				{
					SectionBoxData.push(DataArray[i]);
				}
			}

			// Trigger file input click to select a file
			function selectAndLoadFile() {
				document.getElementById('fileInput').click();
			}
			
			function loadCorrFile() {
				const fileInput = document.getElementById('fileInput');
				const file = fileInput.files[0];

				if (!file) {
					alert("Please select a KML, KMZ, GPX, or CSV file.");
					return;
				}

				const reader = new FileReader();

				reader.onload = function(event) {
					const content = event.target.result;
					const fileName = file.name.toLowerCase();

					if (fileName.endsWith('.kml')) {
						parseKMLCorr(content);
					} else if (fileName.endsWith('.kmz')) {
						parseKMZCorr(content);
					} else if (fileName.endsWith('.gpx')) {
						parseGPXCorr(content);
					} else if (fileName.endsWith('.csv')) {
						parseCSVCorr(content);
					} else {
						alert("Unsupported file format. Please select a KML, KMZ, GPX, or CSV file.");
					}
				};

				if (file.name.toLowerCase().endsWith('.kmz')) {
					reader.readAsArrayBuffer(file); // Read KMZ as binary
				} else {
					reader.readAsText(file); // Read others as text
				}
			}

			// Parse KML files
			function parseKMLCorr(kmlContent) {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(kmlContent, 'application/xml');
				var DataArray = BoxData.data;
				const waypoints = [];
				const placemarks = xmlDoc.getElementsByTagName('Placemark');

				for (let i = 0; i < placemarks.length; i++) {
					const placemark = placemarks[i];
					const name = placemark.getElementsByTagName('name')[0]?.textContent || 'Unnamed';

					const point = placemark.getElementsByTagName('Point')[0];
					if (point) {
						const coordinates = point.getElementsByTagName('coordinates')[0].textContent.trim();
						const [longitude, latitude, elevation] = coordinates.split(',').map(Number);
						//waypoints.push({ name, latitude, longitude, elevation });
					
						for (let j = 0; j < DataArray.length; j++) 
						{
							if (DataArray[j][0] == name)
							{
								DataArray[j][1] = parseFloat(latitude);
								DataArray[j][2] = parseFloat(longitude);
								DataArray[j][3][10] = parseFloat(elevation);
							}
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}

			// Parse KMZ files
			function parseKMZCorr(kmzContent) {
				JSZip.loadAsync(kmzContent).then(zip => {
					const kmlFile = Object.keys(zip.files).find(name => name.toLowerCase().endsWith('.kml'));
					if (kmlFile) {
						zip.files[kmlFile].async('text').then(parseKMLCorr);
					} else {
						alert("No KML file found in KMZ.");
					}
				}).catch(error => {
					alert("Error reading KMZ file.");
					console.error(error);
				});
			}

			// Parse GPX files
			function parseGPXCorr(gpxContent) {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(gpxContent, 'application/xml');
				var DataArray = BoxData.data;
				const waypoints = [];
				const wpts = xmlDoc.getElementsByTagName('wpt');

				for (let i = 0; i < wpts.length; i++) {
					const wpt = wpts[i];
					const name = wpt.getElementsByTagName('name')[0]?.textContent || 'Unnamed';
					const latitude = parseFloat(wpt.getAttribute('lat'));
					const longitude = parseFloat(wpt.getAttribute('lon'));
					const elevation = parseFloat(wpt.getElementsByTagName('ele')[0]?.textContent || '0');

					//waypoints.push({ name, latitude, longitude, elevation });
					
					for (let j = 0; j < DataArray.length; j++) 
					{
						if (DataArray[j][0] == name)
						{
							DataArray[j][1] = parseFloat(latitude);
							DataArray[j][2] = parseFloat(longitude);
							DataArray[j][3][10] = parseFloat(elevation);
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}

			// Parse CSV files
			function parseCSVCorr(csvContent) {
				const lines = csvContent.split('\n');
				const waypoints = [];
				var DataArray = BoxData.data;
				for (let i = 0; i < lines.length; i++) {
					const line = lines[i].trim();
					if (!line || i === 0) continue; // Skip empty lines and header

					const [name, latitude, longitude, elevation] = line.split(',').map(item => item.trim());
					//waypoints.push({ name, latitude, longitude, elevation });
					
					for (let j = 0; j < DataArray.length; j++) 
					{
						if (DataArray[j][0] == name)
						{
							DataArray[j][1] = parseFloat(latitude);
							DataArray[j][2] = parseFloat(longitude);
							DataArray[j][3][10] = parseFloat(elevation);
						}
					}
				}
				generateSiteMapWaypoints(map1, BoxData.data);
				generateWaypoints(map2, BoxData.data);
				generateWaypoints(map3, BoxData.data);
				generateWaypoints(map4, BoxData.data);
				generateWaypoints(map5, BoxData.data);
				generateWaypoints(map6, BoxData.data);
				generateWaypoints(map7, BoxData.data);
				generateWaypoints(map8, BoxData.data);
				EditSectionData();
				refreshRecTable();
				refreshdataTable();
			}
			
			
			const collapsibleBtn5 = document.querySelector('.CORRcollapsible');
			const contentDiv5 = document.querySelector('.CORRcontent');
			collapsibleBtn5.addEventListener('click', function() {
			contentDiv5.classList.toggle('active');
				if (contentDiv5.classList.contains('active')) 
				{
					contentDiv5.style.display = 'block';
				} 
				else 
				{
					contentDiv5.style.display = 'none';
				}
			});
			
			const collapsibleBtn6 = document.querySelector('.SAVEcollapsible');
			const contentDiv6 = document.querySelector('.SAVEcontent');
			collapsibleBtn6.addEventListener('click', function() {
			contentDiv6.classList.toggle('active');
				if (contentDiv6.classList.contains('active')) 
				{
					contentDiv6.style.display = 'block';
				} 
				else 
				{
					contentDiv6.style.display = 'none';
				}
			});
			
			const collapsibleBtn7 = document.querySelector('.Importcollapsible');
			const contentDiv7 = document.querySelector('.Importcontent');
			collapsibleBtn7.addEventListener('click', function() {
			contentDiv7.classList.toggle('active');
				if (contentDiv7.classList.contains('active')) 
				{
					contentDiv7.style.display = 'block';
				} 
				else 
				{
					contentDiv7.style.display = 'none';
				}
			});

			// Button to trigger the file input
			document.getElementById('loadExtDataButton').addEventListener('click', function() {
				document.getElementById('ExtfileInput').click();
			});

			// Handle the file selection
			document.getElementById('ExtfileInput').addEventListener('change', function(event) {
				const file = event.target.files[0];
				if (file) {
					ExternalDataArray = [];
					const reader = new FileReader();
					reader.onload = function(e) {
						const text = e.target.result;
						ExternalDataArray = parseCSV(text); // Parse the CSV file and store it in the array
						var MaxExtDataValue = 0.0
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							if (ExternalDataArray[d][2] > MaxExtDataValue)
							{
								MaxExtDataValue = ExternalDataArray[d][2];
							}
						}
						if (MaxExtDataValue === 0.0)
						{
							MaxExtDataValue = 1.0;
						}
						for (var d = 0; d < ExternalDataArray.length; d++) 
						{
							ExternalDataArray[d][2] = (ExternalDataArray[d][2]/MaxExtDataValue);
						}
						alert('The data has been imported');
					};
					reader.readAsText(file);
				}
			});

			// Function to parse CSV text into an array
			function parseCSV(text) {
				const lines = text.split('\n');
				return lines.map(line => line.split(','));
			}
			
			const TemperaturecollapsibleBtn2 = document.querySelector('.Temperaturecollapsible');
			const TemperaturecontentDiv2 = document.querySelector('.Temperaturecontent');
			TemperaturecollapsibleBtn2.addEventListener('click', function() {
			TemperaturecontentDiv2.classList.toggle('active');
				if (TemperaturecontentDiv2.classList.contains('active')) 
				{
					TemperaturecontentDiv2.style.display = 'block';
				} 
				else 
				{
					TemperaturecontentDiv2.style.display = 'none';
				}
			});

			function generateSiteMapLines(map,data,LineLabel) 
			{
				for (var i = 0; i < SiteMaplines.length; i++) {
					map.removeLayer(SiteMaplines[i]);
				}
				
				SiteMaplines = [];

				if (SiteMapShowLines == true)
				{
					if(data.length > 0)
					{
						let lineCoordinates = [];
						data.forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						var polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip(LineLabel, { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
				}
			}
			
			
			function generateSiteMapProfileLines(map) 
			{
				for (var i = 0; i < SiteMaplines.length; i++) {
					map.removeLayer(SiteMaplines[i]);
				}
				
				SiteMaplines = [];

				if (SiteMapShowLines == true)
				{				
					if(ProfileBoxData[0].length > 0)
					{
						let lineCoordinates = [];
						ProfileBoxData[0].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 1", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
						
					if(ProfileBoxData[1].length > 0)
					{	
						let lineCoordinates = [];
						ProfileBoxData[1].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 2", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
					
					if(ProfileBoxData[2].length > 0)
					{
						let lineCoordinates = [];
						ProfileBoxData[2].forEach(function (point) {
							lineCoordinates.push([point[1], point[2]]);  // Push latitude and longitude from SectionBoxData into the array
						});
						let polyline = L.polyline(lineCoordinates, { color: 'white', weight: 3 }).addTo(map);
						
						polyline.bindTooltip("Profile 3", { permanent: true, direction: 'center right' }).openTooltip();
						
						SiteMaplines.push(polyline);
					}
				}
			}

			function toggleSiteMapShowLines() 
			{
				var checkBox = document.getElementById("ShowLines-checkbox");
				if (checkBox.checked) {
					SiteMapShowLines = true;
					
				} 
				else 
				{
					SiteMapShowLines = false;
					for (var i = 0; i < SiteMaplines.length; i++) 
					{
						map1.removeLayer(SiteMaplines[i]);
					}
					SiteMaplines = [];
				}
			}
			
			//<input type="checkbox" id="ShowRecomendations-checkbox" onchange="toggleSiteMapShowRecomendations()" unchecked>
			function toggleSiteMapShowRecomendations() 
			{
				var checkBox = document.getElementById("ShowRecomendations-checkbox");
				if (checkBox.checked) 
				{
					SiteMapShowRecomendationPoints = true;
					refreshSiteMap('dataset1');
				} 
				else 
				{
					SiteMapShowRecomendationPoints = false;
					refreshSiteMap('dataset1');
				}
			}
			
			function AutoLineCreate() 
			{
			  var DataArray = BoxData.data;
			  var LNum = 1;
			  var tolerance = 1;
			  var StartPoint = 0;
			  var EndPoint = 0;
			  
			  // Function to calculate the angle between three points (p1, p2, p3)
			  function angleBetweenPoints(p1, p2, p3) 
			  {
				const angle1 = Math.atan2(p2[1] - p1[1], p2[2] - p1[2]);
				const angle2 = Math.atan2(p3[1] - p2[1], p3[2] - p2[2]);
				return Math.abs(angle1 - angle2);
			  }

			  let currentProfile = [DataArray[0]];
			  StartPoint = DataArray[0][0];
			  
			  for (let i = 1; i < DataArray.length - 1; i++) 
			  {
				const p1 = DataArray[i - 1];
				const p2 = DataArray[i];
				const p3 = DataArray[i + 1];
				
				const angle = angleBetweenPoints(p1, p2, p3);
				
				// If the angle is below the tolerance, add the point to the current profile
				if (Math.abs(angle) < tolerance) 
				{
				  currentProfile.push(p2);
				} 
				else 
				{
					EndPoint = p2[0];
					if (currentProfile.length > 5)
					{
						currentProfile.push(p2);
						selectionPointArray.push({
								name: "Line" + LNum + " - Point " + StartPoint + " to " + EndPoint,
								data: currentProfile				
							});
						LNum++;
					
					
					}
					currentProfile = [p2];
					StartPoint = p2[0];
				}
			  }
			  
			  RefreshSelectionDropdownLists();
			  
			  alert(LNum - 1 + " - Lines have been created and added to the Selection lists");
			  
			  return true;
			}
			//AutoLineCreate();

			function DeleteSelectionContour() 
			{
				var Deldropdown = document.getElementById("ContourSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			}
			
			function DeleteSelectionSection() 
			{
				var Deldropdown = document.getElementById("SectionSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileOne() 
			{
				var Deldropdown = document.getElementById("ProfileOneSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileTwo() 
			{
				var Deldropdown = document.getElementById("ProfileTwoSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionProfileThree() 
			{
				var Deldropdown = document.getElementById("ProfileThreeSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			function DeleteSelectionModel() 
			{
				var Deldropdown = document.getElementById("ModelSelectionDropdown");
				var DelselectedText = Deldropdown.options[Deldropdown.selectedIndex].text;
				
				var confirmDeletion = confirm("Are you sure you want to delete the selection: " + DelselectedText + "?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name === DelselectedText) {
							if (selectionPointArray[i].name !== "All") {
								selectionPointArray.splice(i, 1);
							}
						}
					}
					RefreshSelectionDropdownLists();
					alert(DelselectedText + " has been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			
			}
			
			
			function DeleteSelectionAll()
			{
				var confirmDeletion = confirm("Are you sure you want to delete all created line selections?");

				if (confirmDeletion) {
					for (let i = selectionPointArray.length - 1; i >= 0; i--) {
						if (selectionPointArray[i].name !== "All") {
							selectionPointArray.splice(i, 1);
						}
					}
					RefreshSelectionDropdownLists();
					alert("All created line selections have been deleted.");
				} else {
					alert("Deletion canceled.");
				}

				return true;
			}			
			
			function showContentAndRunScript() 
			{
				var divdis = document.querySelector('.disclaimer-box');
				divdis.style.display = 'none';
				document.getElementById("acceptButton").style.display = "none";
				var divnote = document.querySelector('.note-box');
				divnote.style.display = 'none';
				document.getElementById("content").style.display = "block";
				AutoCalibrateTemperature();
				updateSiteMap('dataset1');
				updateAquiferMap('dataset1');
				updateGWLMap('dataset2');
				updateFaultMap('dataset3');
				updateLithMap('dataset4');
				updateWaterShedMap('dataset5');
				updateSalineMap('dataset6');
				updateGeothermalMap('dataset7');
				
				contentDiv2.style.display = 'none';
				
				updateContourPlot('dataset1');
				updateSectionPlot('dataset40','plotly-Sections');
				updateProfilePlot('dataset40');
				updateVolumePlot('dataset40');
				updatePresentationPlot();
				selectTracePoint(1);
				selectPoint();
				LogPoint(1);
				EditPoint(1);
				selectRow();
				document.getElementById("warning-box").style.display = "none";
			}
	
			const LimitscollapsibleBtn2 = document.querySelector('.Limitscollapsible');
			const LimitscontentDiv2 = document.querySelector('.Limitscontent');
			LimitscollapsibleBtn2.addEventListener('click', function() {
			LimitscontentDiv2.classList.toggle('active');
				if (LimitscontentDiv2.classList.contains('active')) 
				{
					LimitscontentDiv2.style.display = 'block';
				} 
				else 
				{
					LimitscontentDiv2.style.display = 'none';
				}
			});
			
			const MethcollapsibleBtn2 = document.querySelector('.Methcollapsible');
			const MethcontentDiv2 = document.querySelector('.Methcontent');
			MethcollapsibleBtn2.addEventListener('click', function() {
			MethcontentDiv2.classList.toggle('active');
				if (MethcontentDiv2.classList.contains('active')) 
				{
					MethcontentDiv2.style.display = 'block';
				} 
				else 
				{
					MethcontentDiv2.style.display = 'none';
				}
			});
			
			document.getElementById("acceptButton").addEventListener('click', async function() {
				setTimeout(function() {
					document.getElementById('waitOverlay').style.display = 'flex';
				}, 500);

				setTimeout(function() {
					showContentAndRunScript();
				}, 2000);
				
				setTimeout(function() {
					document.getElementById('waitOverlay').style.display = 'none';
				}, 3000);
			});
		</script>
	</body>
</html>